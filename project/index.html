<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>T&C - Staff Rota</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 10px;
      color: #333;
      /* Hide scrollbars on mobile */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* Internet Explorer 10+ */
    }
    
    body::-webkit-scrollbar {
      display: none; /* Safari and Chrome */
    }
    
    /* Standardized Font System for All Tables */
    :root {
      --table-font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      --table-header-font-size: 14px;
      --table-header-font-weight: 600;
      --table-header-letter-spacing: 0.5px;
      --table-cell-font-size: 14px;
      --table-cell-font-weight: 400;
      --table-large-font-size: 16px;
      --table-small-font-size: 12px;
      --table-header-color: #374151;
      --table-cell-color: #111827;
      --table-secondary-color: #6b7280;
    }

    /* Comprehensive text wrapping for all table cells */
    table td, table th {
      word-wrap: break-word !important;
      overflow-wrap: break-word !important;
      white-space: normal !important;
      word-break: break-word !important;
      hyphens: auto !important;
    }

    /* Specific overrides for tables that need different behavior */
    .table-container {
      overflow-x: auto;
      white-space: normal;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* Internet Explorer 10+ */
    }

    .table-container::-webkit-scrollbar {
      display: none; /* Safari and Chrome */
    }

    .table-container table {
      white-space: normal !important;
    }

    .table-container table td,
    .table-container table th {
      white-space: normal !important;
      word-wrap: break-word !important;
      overflow-wrap: break-word !important;
      word-break: break-word !important;
    }

    /* Rota Table Specific Styles - Bold Fonts */
    #rota-tab table {
      font-weight: 700 !important;
    }
    
    #rota-tab table th,
    #rota-tab table td {
      font-weight: 700 !important;
    }
    
    #rota-tab table .editable-cell {
      font-weight: 700 !important;
    }
    
    /* Center align rota tables */
    #tables-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      padding: 20px;
    }
    
    /* Week 1 header with print button on same line */
    .week1-header-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    
    .week1-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 1200px;
    }
    
    .week1-header h2 {
      margin: 0;
      flex: 1;
    }
    
    .week1-header .print-btn {
      margin: 0;
      flex-shrink: 0;
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }

    /* Time-Off Tab Content Width Constraints */
    #timeoff-tab {
      max-width: 1600px;
      margin: 0 auto;
      width: 100%;
      box-sizing: border-box;
    }
    
    #timeoff-tab .time-off-dashboard {
      max-width: 100%;
      margin: 0;
    }
    
    #timeoff-tab .dashboard-grid {
      max-width: 100%;
      padding: 30px;
      box-sizing: border-box;
    }

    /* Refresh Button Styles */
    .refresh-btn {
      background: #3b82f6;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .refresh-btn:hover {
      background: #2563eb;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .container {
      max-width: 1600px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(10px);
      padding: 30px;
    }
    
    table {
      border-collapse: collapse;
      margin-bottom: 30px;
      width: 100%;
      max-width: 1400px;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
      background: white;
      font-family: var(--table-font-family);
      font-size: var(--table-cell-font-size);
      overflow-x: auto;
      display: block;
      white-space: normal;
    }
    
    thead, tbody, tr {
      display: table;
      width: 100%;
      table-layout: fixed;
    }
    
    th, td {
      border: 2px solid #333;
      padding: 24px 18px;
      text-align: center;
      transition: all 0.3s ease;
      min-width: 160px;
      font-family: var(--table-font-family);
      font-weight: var(--table-cell-font-weight);
      font-size: var(--table-cell-font-size);
      word-wrap: break-word;
      overflow-wrap: break-word;
      white-space: normal;
      word-break: break-word;
      hyphens: auto;
      max-width: 200px;
    }
    th {
      background: white;
      color: var(--table-header-color);
      font-weight: var(--table-header-font-weight);
      font-size: var(--table-header-font-size);
      letter-spacing: var(--table-header-letter-spacing);
      text-shadow: none;
      border: 2px solid #333;
      padding: 26px 18px;
    }
    .color1 { background-color: #ffcccc; } /* Light Red */
    .color2 { background-color: #ccffcc; } /* Light Green */
    .color3 { background-color: #ccccff; } /* Light Blue */
    .color4 { background-color: #ffffcc; } /* Light Yellow */
    .color5 { background-color: #ffccff; } /* Light Pink */
    .color6 { background-color: #cce5ff; } /* Light Cyan */
    
    .editable-cell {
      cursor: pointer;
      position: relative;
      transition: all 0.2s ease;
    }
    
    .editable-cell:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      z-index: 10;
      position: relative;
    }
    
    /* Multi-select styles */
    .editable-cell.selected {
      background-color: #4f46e5 !important;
      color: white !important;
      box-shadow: 0 0 0 3px #7c3aed;
      transform: scale(1.02);
    }
    
    .editable-cell.selected:hover {
      transform: scale(1.05);
    }
    
    .multi-select-mode .editable-cell {
      cursor: crosshair;
    }
    
    .multi-select-mode .editable-cell:hover {
      background-color: rgba(79, 70, 229, 0.1) !important;
    }
    
    .multi-select-mode .editable-cell {
      position: relative;
    }
    
    .multi-select-mode .editable-cell::before {
      content: '📋';
      position: absolute;
      top: 2px;
      right: 2px;
      font-size: 10px;
      opacity: 0.7;
      pointer-events: none;
    }
    
    /* Context menu styles */
    /* Context menu styles removed */
    
    /* Multi-select toolbar */
    .multi-select-toolbar {
      position: fixed;
      top: 20px;
      right: 20px;
      background: white;
      border: 2px solid #4f46e5;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      padding: 12px;
      z-index: 10001;
      display: none;
      min-width: 200px;
    }
    
    .multi-select-toolbar.show {
      display: block;
    }
    
    .multi-select-toolbar button {
      margin: 0 4px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s ease;
    }
    
    .multi-select-toolbar .delete-btn {
      background-color: #dc3545;
      color: white;
    }
    
    .multi-select-toolbar .delete-btn:hover {
      background-color: #c82333;
    }
    
    .multi-select-toolbar .cancel-btn {
      background-color: #6c757d;
      color: white;
    }
    
    .multi-select-toolbar .cancel-btn:hover {
      background-color: #5a6268;
    }
    
    .dropdown {
      position: absolute;
      width: 300px;
      max-width: 90vw;
      background: white;
      border: 2px solid #4f46e5;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      z-index: 1000;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .dropdown-option {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid #eee;
      transition: all 0.2s ease;
      font-weight: 500;
      font-size: 16px;
    }
    
    .dropdown-option:hover {
      background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
      color: white;
      transform: translateX(5px);
    }
    
    .dropdown-option:last-child {
      border-bottom: none;
    }
    
    /* Autocomplete dropdown styles */
    .staff-dropdown {
      animation: dropdownSlideIn 0.2s ease-out;
    }
    
    .dropdown-item {
      transition: all 0.2s ease;
    }
    
    .dropdown-item:hover {
      background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%) !important;
      color: white !important;
      transform: translateX(3px);
    }
    
    .staff-input:focus {
      border-color: #4f46e5;
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
      outline: none;
    }
    
    .dropdown-toggle:hover {
      background: #e9ecef !important;
      color: #495057 !important;
    }
    
    .dropdown-toggle:active {
      background: #dee2e6 !important;
    }
    
    .auto-save-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(40, 167, 69, 0.9);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      z-index: 10001;
      animation: fadeInOut 1.5s ease-in-out;
    }
    
    @keyframes fadeInOut {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
    }
    
    @keyframes dropdownSlideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Professional Staff Management Dashboard */
    .staff-management-dashboard {
      background: #ffffff;
      border-radius: 0;
      box-shadow: none;
      overflow: visible;
    }
    
    /* Shift Summary Dashboard - Optimized */
    .shift-summary-dashboard {
      background: #ffffff;
      border-radius: 0;
      box-shadow: none;
      overflow: visible;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Main Content Layout */
    .summary-main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2rem;
      padding: 2rem;
    }

    /* Controls Section */
    .summary-controls {
      background: #f8fafc;
      border-radius: 16px;
      padding: 1.5rem;
      border: 1px solid #e2e8f0;
    }

    /* Summary Cards - Optimized Grid */
    .summary-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
      margin: 0;
    }

    .summary-card {
      background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      border: 1px solid #e2e8f0;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }

    .summary-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #3b82f6, #8b5cf6);
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }

    .summary-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
    }

    .summary-card:hover::before {
      transform: scaleX(1);
    }

    .summary-card .card-icon {
      font-size: 2rem;
      margin-bottom: 1rem;
      opacity: 0.8;
    }

    .summary-card .card-content {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .summary-card .card-title {
      font-size: 0.875rem;
      font-weight: 500;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .summary-card .card-value {
      font-size: 2rem;
      font-weight: 700;
      color: #1e293b;
      line-height: 1;
    }

    /* Table Section */
    .summary-table-section {
      background: #ffffff;
      border-radius: 16px;
      border: 1px solid #e2e8f0;
      overflow: hidden;
    }

    .table-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.5rem;
      background: #f8fafc;
      border-bottom: 1px solid #e2e8f0;
    }

    .table-header h4 {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 600;
      color: #1e293b;
    }

    .table-actions {
      display: flex;
      gap: 0.75rem;
    }

    .export-btn {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1rem;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .export-btn:hover {
      background: #2563eb;
      transform: translateY(-1px);
    }

    .print-btn {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 14px;
    }

    .print-btn:hover {
      background: linear-gradient(135deg, #047857 0%, #065f46 100%);
      transform: translateY(-1px);
    }

    /* Rota tab header */
    .rota-tab-header {
      display: none; /* Hidden since print button is moved to Week 1 header */
    }
    /* Print-specific styles */
    @media print {
      @page {
        margin: 0.3in;
        size: A4;
        @top-left { content: ""; }
        @top-center { content: ""; }
        @top-right { content: ""; }
        @bottom-left { content: ""; }
        @bottom-center { content: ""; }
        @bottom-right { content: ""; }
      }
      
      body * {
        visibility: hidden;
      }
      
      .print-content, .print-content * {
        visibility: visible;
      }
      
      .print-content {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
      }
      
      /* Hide navigation and controls */
      .navigation-header,
      .tab-container,
      .multi-select-toolbar {
        display: none !important;
      }
      
      /* Page layout for weeks 1-2 and 3-4 */
      .print-page {
        page-break-after: always;
        margin-bottom: 0;
        padding: 10px;
      }
      
      .print-page:last-child {
        page-break-after: auto;
      }
      
      /* Ensure tables fit on page and preserve colors */
      .print-content table {
        page-break-inside: avoid;
        margin-bottom: 25px;
        margin-top: 10px;
        font-size: 16px;
        -webkit-print-color-adjust: exact !important;
        color-adjust: exact !important;
        print-color-adjust: exact !important;
        width: 100%;
        border-collapse: collapse;
      }
      
      .print-content th,
      .print-content td {
        padding: 15px 10px;
        border: 1px solid #000;
        -webkit-print-color-adjust: exact !important;
        color-adjust: exact !important;
        print-color-adjust: exact !important;
        text-align: center;
        vertical-align: middle;
        word-wrap: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
        min-width: 120px;
        max-width: 180px;
        font-weight: 500;
      }
      
      /* Special styling for Shift Type column */
      .print-content th:first-child,
      .print-content td:first-child {
        min-width: 150px;
        max-width: 200px;
        text-align: left;
        padding-left: 15px;
        font-weight: 600;
      }
      
      /* Enhanced table headers */
      .print-content th {
        background-color: #f1f5f9;
        font-weight: bold;
        font-size: 12px;
        border-bottom: 2px solid #4f46e5;
        word-wrap: break-word;
        overflow-wrap: break-word;
        hyphens: auto;
        line-height: 1.1;
        padding: 10px 6px;
        white-space: nowrap;
        min-width: 100px;
        max-width: 140px;
      }
      
      /* Table row spacing */
      .print-content tr {
        border-bottom: 1px solid #000;
      }
      
      .print-content tr:nth-child(even) {
        background-color: #f8fafc;
      }
      
      /* Preserve all cell colors and backgrounds */
      .print-content * {
        -webkit-print-color-adjust: exact !important;
        color-adjust: exact !important;
        print-color-adjust: exact !important;
      }
      
      /* Ensure specific cell types maintain their colors */
      .print-content .editable-cell,
      .print-content .staff-cell,
      .print-content .role-cell,
      .print-content .shift-cell {
        -webkit-print-color-adjust: exact !important;
        color-adjust: exact !important;
        print-color-adjust: exact !important;
      }
      
      /* Print main title */
      .print-main-title {
        font-family: 'Times New Roman', serif;
        font-size: 48px;
        font-weight: bold;
        color: #4f46e5;
        text-align: center;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        line-height: 1.1;
        background: transparent;
        padding: 20px;
        border-radius: 10px;
        -webkit-print-color-adjust: exact !important;
        color-adjust: exact !important;
        print-color-adjust: exact !important;
      }

      /* Print subtitle */
      .print-subtitle {
        font-size: 24px;
        font-weight: normal;
        color: #333333;
        text-align: center;
        margin-bottom: 20px;
        margin-top: 10px;
      }
      
      /* Page header container */
      .print-content .page-header {
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #e2e8f0;
      }

      /* Original print header (if still used) */
      .print-header {
        text-align: center;
        margin-bottom: 20px;
        font-size: 18px;
        font-weight: bold;
      }
      
      /* Week titles */
      .print-content .week-title {
        font-size: 16px;
        font-weight: bold;
        margin: 15px 0 8px 0;
        color: #333;
        border-bottom: 2px solid #4f46e5;
        padding-bottom: 5px;
        text-align: center;
        background-color: #f8fafc;
        padding: 10px;
        border-radius: 6px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      
      /* Add spacing between week sections */
      .print-content .week-title:first-child {
        margin-top: 5px;
      }
      
      /* Table container spacing */
      .print-content table + .week-title {
        margin-top: 20px;
      }
      
      /* Remove current date highlighting in print */
      .print-content .current-date-header {
        background: #f1f5f9 !important;
        color: #333 !important;
        font-weight: bold !important;
        animation: none !important;
      }
      
      .print-content .current-date-cell {
        border: 1px solid #000 !important;
        animation: none !important;
      }
      
      .print-content .current-date-cell::before {
        display: none !important;
      }
      
      /* Assignment cells borders */
      .print-content .staff-cell,
      .print-content .editable-cell,
      .print-content .shift-cell {
        border: 1px solid #000 !important;
      }
      
      /* Print footer styling */
      .print-footer {
        margin-top: 20px;
        padding-top: 10px;
        border-top: 1px solid #e2e8f0;
        text-align: center;
      }
      
      .print-footer-text {
        font-size: 10px;
        color: #666;
        font-family: Arial, sans-serif;
      }
    }

    .shifts-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .shifts-section-header h4 {
      margin: 0;
      color: #374151;
      font-size: 1.1rem;
      font-weight: 600;
    }

    /* Loading States */
    .table-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 3rem;
      color: #64748b;
    }

    .loading-spinner {
      width: 2rem;
      height: 2rem;
      border: 3px solid #e2e8f0;
      border-top: 3px solid #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .summary-main-content {
        padding: 1rem;
        gap: 1.5rem;
      }

      .summary-cards {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 1rem;
      }

      .summary-card {
        padding: 1rem;
      }

      .summary-card .card-value {
        font-size: 1.5rem;
      }

      .table-header {
        flex-direction: column;
        gap: 1rem;
        align-items: stretch;
      }

      .table-actions {
        justify-content: center;
      }
    }

    /* Time-Off Dashboard */
    .time-off-dashboard {
      background: #ffffff;
      border-radius: 0;
      box-shadow: none;
      overflow: visible;
      display: flex;
      flex-direction: column;
      max-width: 100%;
      margin: 0;
      width: 100%;
    }

    /* Dashboard Header */
    .dashboard-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 40px 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    /* Headers without stats - center the content */
    .time-off-dashboard .dashboard-header,
    .shift-summary-dashboard .dashboard-header {
      justify-content: center;
    }
    

    .header-content h2 {
      font-size: 2.5rem;
      font-weight: 800;
      margin-bottom: 8px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .header-subtitle {
      font-size: 1.1rem;
      opacity: 0.9;
      font-weight: 400;
    }

    .header-stats {
      display: flex;
      gap: 20px;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 20px;
      text-align: center;
      min-width: 120px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .stat-number {
      font-size: 2rem;
      font-weight: 800;
      margin-bottom: 4px;
      color: #1f2937;
    }

    .stat-label {
      font-size: 0.9rem;
      color: #4b5563;
      font-weight: 500;
    }

    /* Dashboard Grid */
    .dashboard-grid {
      display: flex;
      flex-direction: column;
      gap: 30px;
      padding: 30px;
      max-width: 100%;
      box-sizing: border-box;
    }

    /* Section Headers */
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 2px solid #f1f5f9;
    }

    .section-header h3 {
      font-size: 1.5rem;
      font-weight: 700;
      color: #374151;
      margin: 0;
      text-transform: none;
    }

    .section-subtitle {
      color: #64748b;
      font-size: 0.95rem;
      margin-top: 5px;
    }

    /* Management Section */
    .management-section {
      background: #f8fafc;
      border-radius: 16px;
      padding: 25px;
      border: 1px solid #e2e8f0;
    }

    .add-staff-btn {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 12px 20px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
    }

    .add-staff-btn:hover {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
    }

    .btn-icon {
      font-size: 16px;
      font-weight: 700;
    }

    /* Add Staff Form */
    .add-staff-form {
      background: white;
      border-radius: 12px;
      padding: 30px;
      margin: 20px 0;
      border: 1px solid #e2e8f0;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      max-width: 600px;
    }

    .add-staff-form .form-group {
      margin-bottom: 20px;
    }

    .add-staff-form label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #374151;
      font-size: 14px;
    }

    .form-group {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .form-input {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s ease;
      background: white;
      width: 100%;
    }

    .add-staff-form .form-input {
      width: 100%;
      flex: none;
    }

    .add-staff-form .form-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid #e5e7eb;
    }

    .form-input:focus {
      outline: none;
      border-color: #10b981;
      box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
    }

    .submit-btn {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 20px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .submit-btn:hover {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      transform: translateY(-1px);
    }

    .cancel-btn {
      background: #f1f5f9;
      color: #64748b;
      border: none;
      border-radius: 8px;
      padding: 12px 20px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .cancel-btn:hover {
      background: #e2e8f0;
      color: #475569;
    }

    /* Team Members Table */
    .team-members-table-container {
      margin-top: 20px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      overflow: hidden;
    }

    .team-members-table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      overflow: hidden;
    }

    .team-members-table th {
      background: #f8fafc;
      color: var(--table-header-color);
      font-family: var(--table-font-family);
      font-weight: var(--table-header-font-weight);
      font-size: var(--table-header-font-size);
      text-transform: uppercase;
      letter-spacing: var(--table-header-letter-spacing);
      padding: 18px 20px;
      text-align: left;
      border-bottom: 1px solid #e5e7eb;
    }

    .team-members-table td {
      padding: 16px 20px;
      border-bottom: 1px solid #f3f4f6;
      vertical-align: middle;
      font-family: var(--table-font-family);
      font-size: var(--table-cell-font-size);
      color: var(--table-cell-color);
    }

    .team-members-table tbody tr:hover {
      background: #f9fafb;
    }

    /* Member Column */
    .member-info {
      display: flex;
      align-items: center;
      gap: 12px;
      position: relative;
    }

    .member-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 16px;
      color: white;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    .member-avatar.red { background: #ef4444; }
    .member-avatar.yellow { background: #fbbf24; }
    .member-avatar.green { background: #10b981; }
    .member-avatar.purple { background: #8b5cf6; }
    .member-avatar.pink { background: #ec4899; }
    .member-avatar.blue { background: #3b82f6; }

    .member-details {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .member-name {
      font-family: var(--table-font-family);
      font-weight: 600;
      color: var(--table-cell-color);
      font-size: var(--table-cell-font-size);
    }

    .member-status {
      font-family: var(--table-font-family);
      font-size: var(--table-small-font-size);
      color: var(--table-secondary-color);
    }

    /* Role Column */
    .role-section {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .role-badge {
      font-size: 12px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-family: var(--table-font-family);
    }

    .role-badge.team-leader {
      background-color: #d4edda;
      color: #155724;
    }

    .role-badge.staff-member {
      background-color: #f8d7da;
      color: #721c24;
    }

    .role-edit-icon {
      width: 16px;
      height: 16px;
      background: #9ca3af;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .role-edit-icon:hover {
      background: #6b7280;
    }

    .history-icon {
      width: 16px;
      height: 16px;
      background: #9ca3af;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-left: 8px;
    }

    .history-icon:hover {
      background: #6b7280;
    }

    /* Pay Rate and Contracted Hours Styles */
    .pay-rate-section,
    .contracted-hours-section {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 4px 0;
    }

    .pay-rate-value,
    .contracted-hours-value {
      font-weight: 600;
      color: #333;
    }

    .pay-rate-edit-icon,
    .contracted-hours-edit-icon {
      width: 16px;
      height: 16px;
      background: #9ca3af;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .pay-rate-edit-icon:hover,
    .contracted-hours-edit-icon:hover {
      background: #6b7280;
    }

    .pay-rate-value {
      color: #28a745;
    }

    .contracted-hours-value {
      color: #007bff;
    }

    /* Employment Date Section Styles */
    .employment-date-section,
    .employment-end-date-section {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 4px 0;
    }

    .employment-date-value,
    .employment-end-date-value {
      font-weight: 600;
      color: #333;
    }

    .employment-date-edit-icon,
    .employment-end-date-edit-icon {
      width: 16px;
      height: 16px;
      background: #9ca3af;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .employment-date-edit-icon:hover,
    .employment-end-date-edit-icon:hover {
      background: #6b7280;
    }

    .employment-date-value {
      color: #dc3545;
    }

    .employment-end-date-value {
      color: #fd7e14;
    }

    /* Avatar hover effect for color editing */
    .member-avatar {
      transition: all 0.2s ease;
    }

    .member-avatar:hover {
      transform: scale(1.1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    /* Status Toggle Styles */
    .status-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 4px 0;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }

    .status-checkbox {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.3s;
      border-radius: 24px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    .status-checkbox:checked + .toggle-slider {
      background-color: #28a745;
    }

    .status-checkbox:checked + .toggle-slider:before {
      transform: translateX(26px);
    }

    .status-checkbox:focus + .toggle-slider {
      box-shadow: 0 0 1px #28a745;
    }

    .status-label {
      font-size: 12px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .status-label.active {
      background-color: #d4edda;
      color: #155724;
    }

    .status-label.inactive {
      background-color: #f8d7da;
      color: #721c24;
    }

    /* Disable inactive staff members in the table */
    .staff-row.inactive {
      opacity: 0.6;
      background-color: #f8f9fa;
    }

    .staff-row.inactive .member-info,
    .staff-row.inactive .role-section,
    .staff-row.inactive .pay-rate-section,
    .staff-row.inactive .contracted-hours-section {
      color: #6c757d;
    }

    .staff-row.inactive .employment-date-section,
    .staff-row.inactive .employment-end-date-section {
      color: #6c757d;
    }

    /* Edit Dialog Styles */
    .pay-rate-edit-dialog,
    .contracted-hours-edit-dialog {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.3s ease-out;
    }

    .pay-rate-edit-content,
    .contracted-hours-edit-content {
      background: white;
      border-radius: 16px;
      padding: 0;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow: hidden;
      animation: slideInUp 0.3s ease-out;
    }

    .pay-rate-edit-header,
    .contracted-hours-edit-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .pay-rate-edit-header h3,
    .contracted-hours-edit-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }

    .close-pay-rate-dialog,
    .close-contracted-hours-dialog {
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      color: white;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      font-weight: bold;
    }

    .close-pay-rate-dialog:hover,
    .close-contracted-hours-dialog:hover {
      background: rgba(255, 255, 255, 0.3);
      border-color: rgba(255, 255, 255, 0.5);
    }

    .pay-rate-edit-body,
    .contracted-hours-edit-body {
      padding: 20px;
    }

    .current-pay-rate-display,
    .current-contracted-hours-display {
      margin-bottom: 20px;
    }

    .current-pay-rate-display label,
    .current-contracted-hours-display label {
      display: block;
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
      font-weight: 600;
    }

    .current-pay-rate-value,
    .current-contracted-hours-value {
      font-size: 16px;
      font-weight: 600;
      color: #333;
      padding: 8px 12px;
      background: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #e9ecef;
    }

    .new-pay-rate-input,
    .new-contracted-hours-input {
      margin-bottom: 20px;
    }

    .new-pay-rate-input label,
    .new-contracted-hours-input label {
      display: block;
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
      font-weight: 600;
    }

    .new-pay-rate-field,
    .new-contracted-hours-field {
      width: 100%;
      padding: 12px;
      border: 2px solid #e9ecef;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.2s;
      box-sizing: border-box;
    }

    .new-pay-rate-field:focus,
    .new-contracted-hours-field:focus {
      outline: none;
      border-color: #667eea;
    }

    .pay-rate-edit-actions,
    .contracted-hours-edit-actions {
      padding: 20px;
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      border-top: 1px solid #e9ecef;
    }

    .cancel-pay-rate-btn,
    .cancel-contracted-hours-btn {
      padding: 10px 20px;
      background: #6c757d;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .cancel-pay-rate-btn:hover,
    .cancel-contracted-hours-btn:hover {
      background: #5a6268;
    }

    .save-pay-rate-btn,
    .save-contracted-hours-btn {
      padding: 10px 20px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }

    .save-pay-rate-btn:hover,
    .save-contracted-hours-btn:hover {
      background: #218838;
    }

    /* Employment Date Edit Dialog Styles */
    .date-edit-dialog,
    .end-date-edit-dialog {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.3s ease-out;
    }

    .date-edit-content,
    .end-date-edit-content {
      background: white;
      border-radius: 16px;
      padding: 0;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow: hidden;
      animation: slideInUp 0.3s ease-out;
    }

    .date-edit-header,
    .end-date-edit-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .date-edit-header h3,
    .end-date-edit-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }

    .close-date-dialog,
    .close-end-date-dialog {
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      color: white;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      font-weight: bold;
    }

    .close-date-dialog:hover,
    .close-end-date-dialog:hover {
      background: rgba(255, 255, 255, 0.3);
      border-color: rgba(255, 255, 255, 0.5);
    }

    .date-edit-body,
    .end-date-edit-body {
      padding: 20px;
    }

    .current-date-display,
    .current-end-date-display {
      margin-bottom: 20px;
    }

    .current-date-display label,
    .current-end-date-display label {
      display: block;
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
      font-weight: 600;
    }

    .current-date-value,
    .current-end-date-value {
      font-size: 16px;
      font-weight: 600;
      color: #333;
      padding: 8px 12px;
      background: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #e9ecef;
    }

    .new-date-input,
    .new-end-date-input {
      margin-bottom: 20px;
    }

    .new-date-input label,
    .new-end-date-input label {
      display: block;
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
      font-weight: 600;
    }

    .new-date-field,
    .new-end-date-field {
      width: 100%;
      padding: 12px;
      border: 2px solid #e9ecef;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.2s;
      box-sizing: border-box;
    }

    .new-date-field:focus,
    .new-end-date-field:focus {
      outline: none;
      border-color: #667eea;
    }

    .end-date-help {
      margin-top: 8px;
      color: #6c757d;
      font-size: 12px;
      font-style: italic;
    }

    .change-details-section {
      margin-bottom: 20px;
    }

    .change-detail-row {
      margin-bottom: 15px;
    }

    .change-detail-row label {
      display: block;
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
      font-weight: 600;
    }

    .changed-by-input,
    .reason-input,
    .effective-date-input {
      width: 100%;
      padding: 10px;
      border: 2px solid #e9ecef;
      border-radius: 6px;
      font-size: 14px;
      transition: border-color 0.2s;
      box-sizing: border-box;
    }

    .changed-by-input:focus,
    .reason-input:focus,
    .effective-date-input:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .effective-date-input {
      background: #fff;
      border-color: #007bff;
    }
    
    .effective-date-input:focus {
      border-color: #0056b3;
      box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
    }

    .date-edit-actions,
    .end-date-edit-actions {
      padding: 20px;
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      border-top: 1px solid #e9ecef;
    }

    .cancel-date-btn,
    .cancel-end-date-btn {
      padding: 10px 20px;
      background: #6c757d;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .cancel-date-btn:hover,
    .cancel-end-date-btn:hover {
      background: #5a6268;
    }

    .save-date-btn,
    .save-end-date-btn {
      padding: 10px 20px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }

    .save-date-btn:hover,
    .save-end-date-btn:hover {
      background: #218838;
    }

    /* Contract History Dialog Styles */
    .contract-history-dialog {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.3s ease-out;
    }

    .contract-history-content-dialog {
      background: white;
      border-radius: 16px;
      padding: 0;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 800px;
      width: 90%;
      max-height: 90vh;
      overflow: hidden;
      animation: slideInUp 0.3s ease-out;
    }

    .contract-history-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .contract-history-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }

    .close-contract-history-dialog {
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      color: white;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      font-weight: bold;
    }

    .close-contract-history-dialog:hover {
      background: rgba(255, 255, 255, 0.3);
      border-color: rgba(255, 255, 255, 0.5);
    }

    .contract-history-body {
      padding: 20px;
      max-height: 60vh;
      overflow-y: auto;
    }

    .current-contract-section,
    .contract-history-section,
    .changes-history-section {
      margin-bottom: 30px;
    }

    .current-contract-section h4,
    .contract-history-section h4,
    .changes-history-section h4 {
      margin: 0 0 15px 0;
      font-size: 16px;
      font-weight: 600;
      color: #333;
      border-bottom: 2px solid #e9ecef;
      padding-bottom: 8px;
    }

    .current-contract-info {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      border: 1px solid #e9ecef;
    }

    .contract-info-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .contract-info-item:last-child {
      margin-bottom: 0;
    }

    .contract-info-item label {
      font-weight: 600;
      color: #666;
      min-width: 120px;
    }

    .current-pay-rate,
    .current-contracted-hours,
    .current-effective-date {
      font-weight: 600;
      color: #333;
    }

    .current-pay-rate {
      color: #28a745;
    }

    .current-contracted-hours {
      color: #007bff;
    }

    .contract-history-items,
    .changes-history-items {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #e9ecef;
      border-radius: 8px;
      background: white;
    }

    .contract-history-item,
    .changes-history-item {
      padding: 12px 15px;
      border-bottom: 1px solid #e9ecef;
      transition: background 0.2s;
    }

    .contract-history-item:last-child,
    .changes-history-item:last-child {
      border-bottom: none;
    }

    .contract-history-item:hover,
    .changes-history-item:hover {
      background: #f8f9fa;
    }

    .contract-history-item.current-contract {
      background: #e8f5e8;
      border-left: 4px solid #28a745;
    }

    .contract-change-info,
    .change-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }

    .contract-details,
    .change-type {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .contract-pay-rate,
    .contract-hours {
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 14px;
    }

    .contract-pay-rate {
      background: #d4edda;
      color: #155724;
    }

    .contract-hours {
      background: #d1ecf1;
      color: #0c5460;
    }

    .current-badge {
      background: #28a745;
      color: white;
      padding: 2px 6px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
    }

    .contract-dates,
    .change-dates {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 12px;
      color: #666;
    }

    .change-type-label {
      font-weight: 600;
      color: #333;
      text-transform: capitalize;
    }

    .change-arrow {
      color: #666;
      font-family: monospace;
    }

    .change-reason {
      margin-top: 8px;
      padding: 8px;
    }

    .change-details {
      margin-top: 12px;
      padding: 12px;
      background: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #e9ecef;
    }

    .change-detail-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .change-detail-row:last-child {
      margin-bottom: 0;
    }

    .change-detail-row label {
      font-weight: 600;
      color: #333;
      min-width: 80px;
      font-size: 14px;
    }

    .changed-by-input,
    .reason-input,
    .effective-date-input {
      flex: 1;
      padding: 6px 10px;
      border: 1px solid #ced4da;
      border-radius: 4px;
      font-size: 14px;
      background: white;
      transition: border-color 0.2s;
    }

    .changed-by-input:focus,
    .reason-input:focus,
    .effective-date-input:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
    }
    
    .effective-date-input {
      border-color: #007bff;
    }

    .change-actions {
      margin-top: 10px;
      display: flex;
      justify-content: flex-end;
    }

    .save-history-btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .save-history-btn:hover {
      background: #0056b3;
    }

    /* Changes History Dialog Styles */
    .changes-history-dialog {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.3s ease-out;
    }

    .changes-history-content-dialog {
      background: white;
      border-radius: 16px;
      padding: 0;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 1200px;
      width: 95%;
      max-height: 95vh;
      overflow: hidden;
      animation: slideInUp 0.3s ease-out;
    }

    .changes-history-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 25px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .changes-history-header h3 {
      margin: 0;
      font-size: 22px;
      font-weight: 600;
    }
    .close-changes-history-dialog {
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background 0.2s;
    }

    .close-changes-history-dialog:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .changes-history-body {
      padding: 30px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .changes-history-actions {
      padding: 20px;
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      border-top: 1px solid #e9ecef;
    }

    .close-changes-history-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
      background: #6c757d;
      color: white;
    }

    .close-changes-history-btn:hover {
      background: #5a6268;
    }

    /* History Table Styles */
    .history-table-container {
      overflow-x: auto;
      margin-top: 10px;
    }

    .history-table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      font-family: var(--table-font-family);
      font-size: var(--table-cell-font-size);
    }

    .history-table thead {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .history-table th {
      padding: 12px 8px;
      text-align: left;
      font-family: var(--table-font-family);
      font-weight: var(--table-header-font-weight);
      font-size: var(--table-header-font-size);
      border: none;
    }

    .history-table tbody tr {
      border-bottom: 1px solid #e9ecef;
      transition: background-color 0.2s;
    }

    .history-table tbody tr:hover {
      background-color: #f8f9fa;
    }

    .history-table tbody tr:last-child {
      border-bottom: none;
    }

    .history-table td {
      padding: 10px 8px;
      font-family: var(--table-font-family);
      font-size: var(--table-cell-font-size);
      color: var(--table-cell-color);
      vertical-align: middle;
    }

    .change-type-cell {
      font-weight: 600;
      color: #495057;
    }

    .change-type-label {
      background: #e9ecef;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .old-value-cell, .new-value-cell {
      font-family: 'Courier New', monospace;
      font-weight: 500;
    }

    .old-value-cell {
      color: #dc3545;
    }

    .new-value-cell {
      color: #28a745;
    }

    .changed-by-cell, .reason-cell {
      min-width: 120px;
      color: #495057;
    }

    .effective-date-cell, .changed-date-cell {
      color: #6c757d;
      font-size: 12px;
      white-space: normal;
    }



    .no-changes-history {
      text-align: center;
      padding: 40px 20px;
      color: #6c757d;
      font-style: italic;
    }

    .changes-history-error {
      text-align: center;
      padding: 20px;
      color: #dc3545;
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      border-radius: 8px;
      margin: 10px 0;
    }

    /* Change Request Row Styles */
    .change-request-row.pending {
      border-left: 4px solid #ffc107;
    }

    .change-request-row.pending:hover {
      background: #f8f9fa;
    }

    .change-request-row.applied {
      background: #d4edda;
      border-left: 4px solid #28a745;
    }

    .change-request-row.applied:hover {
      background: #c3e6cb;
    }

    /* Delete Button Styles */
    .delete-change-btn {
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3);
    }

    .delete-change-btn:hover {
      background: #c82333;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(220, 53, 69, 0.4);
    }

    .delete-change-btn:active {
      background: #bd2130;
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3);
    }

    .delete-change-btn::before {
      content: '⚠️';
      position: absolute;
      top: -8px;
      right: -8px;
      font-size: 10px;
      background: #ffc107;
      color: #000;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }


    .change-request-row td {
      font-size: 13px;
      padding: 8px 12px;
    }

    /* Status Change Dialog Styles */
    .status-change-dialog {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.3s ease-out;
    }

    .status-change-content {
      background: white;
      border-radius: 16px;
      padding: 0;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      width: 90%;
      max-height: 90vh;
      overflow: hidden;
      animation: slideInUp 0.3s ease-out;
    }

    .status-change-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .status-change-header h3 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }

    .close-status-dialog {
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background 0.2s;
    }

    .close-status-dialog:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .status-change-body {
      padding: 20px;
    }

    .status-change-actions {
      padding: 20px;
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      border-top: 1px solid #e9ecef;
    }

    .cancel-status-btn,
    .confirm-status-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }

    .cancel-status-btn {
      background: #6c757d;
      color: white;
    }

    .cancel-status-btn:hover {
      background: #5a6268;
    }

    .confirm-status-btn {
      background: #28a745;
      color: white;
    }

    .confirm-status-btn:hover {
      background: #218838;
    }

    .change-reason {
      background: #fff3cd;
      border-radius: 4px;
      font-size: 12px;
      color: #856404;
    }

    .contract-history-actions {
      padding: 20px;
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      border-top: 1px solid #e9ecef;
    }

    .close-contract-history-btn,
    .edit-pay-rate-from-history-btn,
    .edit-contracted-hours-from-history-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }

    .close-contract-history-btn:hover {
      background: #5a6268;
    }

    .edit-pay-rate-from-history-btn {
      background: #28a745;
      color: white;
    }

    .edit-pay-rate-from-history-btn:hover {
      background: #218838;
    }

    .edit-contracted-hours-from-history-btn {
      background: #007bff;
      color: white;
    }

    .edit-contracted-hours-from-history-btn:hover {
      background: #0056b3;
    }

    .no-contract-history,
    .no-changes-history,
    .contract-history-error,
    .changes-history-error {
      padding: 20px;
      text-align: center;
      color: #666;
      font-style: italic;
    }

    .contract-history-error,
    .changes-history-error {
      color: #dc3545;
      font-style: normal;
    }

    .loading-contract-history,
    .loading-changes-history {
      padding: 20px;
      text-align: center;
      color: #666;
    }

    /* Actions Column */
    .actions-section {
      display: flex;
      gap: 8px;
    }

    .action-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
      font-family: 'Inter', sans-serif;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .history-btn {
      background: #f3f4f6;
      color: #374151;
    }

    .history-btn:hover {
      background: #e5e7eb;
    }

    .contract-history-btn {
      background: #f0f9ff;
      color: #0369a1;
    }

    .contract-history-btn:hover {
      background: #e0f2fe;
    }

    .remove-btn {
      background: #fef2f2;
      color: #dc2626;
    }

    .remove-btn:hover {
      background: #fee2e2;
    }

    /* Animations for dialogs */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideInUp {
      from { 
        opacity: 0;
        transform: translateY(30px);
      }
      to { 
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Shift History Dialog Styles */
    .shift-history-dialog {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.3s ease-out;
    }

    .shift-history-content-dialog {
      background: white;
      border-radius: 16px;
      padding: 0;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 1200px;
      width: 90%;
      max-height: 90vh;
      overflow: hidden;
      animation: slideInUp 0.3s ease-out;
    }

    .shift-history-header {
      background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
      color: white;
      padding: 20px 25px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .shift-history-header h3 {
      margin: 0;
      font-size: 1.3rem;
      font-weight: 600;
      font-family: 'Inter', sans-serif;
    }

    .close-shift-history-dialog {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      cursor: pointer;
      font-size: 18px;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .close-shift-history-dialog:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(1.1);
    }

    .shift-history-body {
      padding: 25px;
      max-height: calc(90vh - 80px);
      overflow-y: auto;
    }

    .date-range-section,
    .shift-summary-section,
    .detailed-shifts-section {
      margin-bottom: 30px;
    }

    .date-range-section h4,
    .shift-summary-section h4,
    .detailed-shifts-section h4 {
      margin: 0 0 15px 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: #374151;
      font-family: 'Inter', sans-serif;
    }

    .date-inputs {
      display: flex;
      gap: 20px;
      align-items: center;
    }

    .date-input-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .date-input-group label {
      font-size: 14px;
      font-weight: 500;
      color: #6b7280;
    }

    .shift-history-date-input {
      padding: 10px 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 14px;
      font-family: 'Inter', sans-serif;
      background: white;
    }

    .shift-history-date-input:focus {
      outline: none;
      border-color: #8b5cf6;
      box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
    }

    .shift-summary-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 15px;
    }

    .summary-card {
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      transition: all 0.2s ease;
    }

    .summary-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .summary-label {
      font-size: 14px;
      color: #6b7280;
      margin-bottom: 8px;
      font-weight: 500;
    }

    .summary-value {
      font-size: 24px;
      font-weight: 700;
      color: #111827;
    }

    .shifts-table-container {
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      overflow: hidden;
    }

    .shifts-table {
      width: 100%;
      border-collapse: collapse;
      font-family: var(--table-font-family);
      font-size: var(--table-cell-font-size);
    }

    .shifts-table th {
      background: #f9fafb;
      color: var(--table-header-color);
      font-family: var(--table-font-family);
      font-weight: var(--table-header-font-weight);
      font-size: var(--table-header-font-size);
      padding: 12px 16px;
      text-align: left;
      border-bottom: 1px solid #e5e7eb;
    }

    .shifts-table td {
      padding: 12px 16px;
      border-bottom: 1px solid #f3f4f6;
      vertical-align: middle;
      font-family: var(--table-font-family);
      font-size: var(--table-cell-font-size);
      color: var(--table-cell-color);
    }

    .shifts-table tbody tr:hover {
      background: #f9fafb;
    }

    .flags-cell {
      font-size: 12px;
      color: #6b7280;
      max-width: 120px;
      word-wrap: break-word;
    }

    .shift-type-badge {
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
      color: white;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .shift-type-badge.day {
      background: #f97316;
    }

    .shift-type-badge.night {
      background: #8b5cf6;
    }

    .shift-type-badge.holiday {
      background: #10b981;
    }

    .pay-amount {
      color: #3b82f6;
      font-weight: 600;
    }

    .loading-shifts,
    .no-shifts,
    .error-message,
    .no-data {
      text-align: center;
      color: #6b7280;
      font-style: italic;
      padding: 20px;
    }

    /* Mobile responsiveness for shift history */
    @media (max-width: 768px) {
      .shift-history-content-dialog {
        width: 95%;
        max-height: 95vh;
      }

      .shift-history-body {
        padding: 20px;
      }

      .date-inputs {
        flex-direction: column;
        gap: 15px;
      }

      .shift-summary-cards {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 10px;
      }

      .shifts-table-container {
        overflow-x: auto;
      }

      .shifts-table {
        min-width: 700px;
      }
    }

    /* Mobile responsiveness for team members table */
    @media (max-width: 768px) {
      .team-members-table-container {
        overflow-x: auto;
      }
      
      .team-members-table {
        min-width: 600px;
      }
      
      .team-members-table th,
      .team-members-table td {
        padding: 12px 16px;
        font-size: 13px;
      }
      
      .member-avatar {
        width: 32px;
        height: 32px;
        font-size: 14px;
      }
      
      .action-btn {
        padding: 6px 12px;
        font-size: 11px;
      }
    }

    /* Staff Grid (keeping for backward compatibility) */
    .staff-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }

    .staff-item {
      background: white;
      border-radius: 12px;
      padding: 20px;
      border: 1px solid #e2e8f0;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      transition: all 0.3s ease;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      position: relative;
      overflow: hidden;
    }
    
    .staff-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .staff-item:hover::before {
      opacity: 1;
    }
    
    .staff-left-section {
      flex: 1;
    }
    
    .staff-right-section {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    /* Staff filters CSS removed for simplicity */
    
    /* Role Edit Dialog Styles */
    .role-edit-dialog {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.3s ease-out;
    }
    
    .role-edit-content {
      background: white;
      border-radius: 16px;
      padding: 0;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 450px;
      width: 90%;
      max-height: 90vh;
      overflow: hidden;
      animation: slideInUp 0.3s ease-out;
    }
    
    .role-edit-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px 25px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .role-edit-header h3 {
      margin: 0;
      font-size: 1.3rem;
      font-weight: 600;
    }
    .close-role-dialog {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      cursor: pointer;
      font-size: 18px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }
    
    .close-role-dialog:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(1.1);
    }
    
    .role-edit-body {
      padding: 25px;
    }
    
    .current-role-display,
    .new-role-selection {
      margin-bottom: 20px;
    }
    
    .current-role-display label,
    .new-role-selection label {
      display: block;
      font-weight: 600;
      color: #374151;
      margin-bottom: 8px;
      font-size: 14px;
    }
    
    .current-role-badge {
      display: inline-block;
      font-size: 12px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-family: var(--table-font-family);
    }
    
    .current-role-badge.team-leader {
      background-color: #d4edda;
      color: #155724;
    }
    
    .current-role-badge.staff-member {
      background-color: #f8d7da;
      color: #721c24;
    }
    
    .new-role-dropdown {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      background: white;
      color: #374151;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .new-role-dropdown:hover {
      border-color: #10b981;
    }
    
    .new-role-dropdown:focus {
      outline: none;
      border-color: #10b981;
      box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
    }
    
    .role-info {
      margin-top: 8px;
      padding: 12px;
      background: #f8fafc;
      border-radius: 8px;
      border-left: 3px solid #10b981;
    }
    
    .role-info small {
      color: #6b7280;
      line-height: 1.5;
    }
    
    .role-info strong {
      color: #374151;
    }
    
    .role-history-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #e2e8f0;
    }
    
    .role-history-section label {
      display: block;
      font-weight: 600;
      color: #374151;
      margin-bottom: 12px;
      font-size: 14px;
    }
    
    .role-history-content {
      max-height: 200px;
      overflow-y: auto;
      background: #f8fafc;
      border-radius: 8px;
      padding: 12px;
      border: 1px solid #e2e8f0;
    }
    
    .loading-role-history {
      text-align: center;
      color: #6b7280;
      font-style: italic;
      padding: 20px;
    }
    
    .no-role-history {
      text-align: center;
      color: #6b7280;
      font-style: italic;
      padding: 20px;
    }
    
    .role-history-error {
      text-align: center;
      color: #dc3545;
      font-style: italic;
      padding: 20px;
    }
    
    .role-history-item {
      padding: 8px 0;
      border-bottom: 1px solid #e2e8f0;
    }
    
    .role-history-item:last-child {
      border-bottom: none;
    }
    
    .role-change-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    
    .role-change-arrow {
      font-weight: 600;
      color: #374151;
      font-size: 13px;
    }
    
    .role-change-date {
      color: #6b7280;
      font-size: 12px;
      font-weight: 500;
    }
    
    .role-change-reason {
      color: #6b7280;
      font-size: 11px;
      font-style: italic;
      margin-left: 8px;
    }
    .cancel-role-btn {
      background: #6b7280;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .cancel-role-btn:hover {
      background: #4b5563;
      transform: translateY(-1px);
    }
    
    .save-role-btn {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .save-role-btn:hover {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      transform: translateY(-1px);
    }
    
    /* Dialog Animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes slideInUp {
      from { 
        opacity: 0;
        transform: translateY(30px);
      }
      to { 
        opacity: 1;
        transform: translateY(0);
      }
    }

    .staff-item:hover {
      transform: translateY(-3px);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.15);
      border-color: #10b981;
    }
    
    .staff-item:hover .staff-role {
      transform: scale(1.05);
    }

    .staff-name {
      font-weight: 700;
      color: #1e293b;
      font-size: 16px;
      letter-spacing: 0.025em;
    }

    .delete-btn {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 8px 16px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
      min-width: 100px;
    }

    .delete-btn:hover {
      background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
    }
    
    .delete-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
    }
    
    .delete-icon {
      font-size: 16px;
    }
    
    .delete-text {
      font-weight: 600;
      letter-spacing: 0.5px;
    }
    
    /* Delete Confirmation Dialog Styles */
    .delete-confirmation-dialog {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      transform: scale(0.9);
      transition: all 0.2s ease;
    }
    
    .delete-confirmation-content {
      background: white;
      border-radius: 16px;
      padding: 32px;
      max-width: 480px;
      width: 90%;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    
    .delete-confirmation-header {
      margin-bottom: 24px;
    }
    
    .delete-confirmation-icon {
      font-size: 48px;
      display: block;
      margin-bottom: 16px;
    }
    
    .delete-confirmation-header h3 {
      margin: 0;
      color: #dc2626;
      font-size: 24px;
      font-weight: 700;
    }
    
    .delete-confirmation-message {
      font-size: 18px;
      color: #374151;
      margin-bottom: 16px;
      line-height: 1.5;
    }
    
    .delete-confirmation-warning {
      background: #fef2f2;
      border: 1px solid #fecaca;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 24px;
      color: #dc2626;
      font-size: 14px;
      line-height: 1.5;
    }
    
    .delete-confirmation-buttons {
      display: flex;
      gap: 16px;
      justify-content: center;
    }
    
    .delete-confirm-btn {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 24px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 140px;
    }
    
    .delete-confirm-btn:hover {
      background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
    }
    
    .delete-cancel-btn {
      background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 12px 24px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 100px;
    }
    
    .delete-cancel-btn:hover {
      background: linear-gradient(135deg, #4b5563 0%, #374151 100%);
      transform: translateY(-1px);
    }
    
    /* Delete Success Message Styles */
    .delete-success-message {
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      padding: 16px 24px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(16, 185, 129, 0.3);
      z-index: 10001;
      display: flex;
      align-items: center;
      gap: 12px;
      opacity: 0;
      transform: translateY(-20px);
      transition: all 0.3s ease;
      max-width: 400px;
    }
    
    .success-icon {
      font-size: 20px;
    }
    
    .success-text {
      font-weight: 600;
      font-size: 14px;
    }
    

    
    .staff-role {
      font-size: 12px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-family: var(--table-font-family);
      transition: all 0.3s ease;
    }
    
    .staff-role.team-leader {
      background-color: #d4edda;
      color: #155724;
    }
    
    .staff-role.staff-member {
      background-color: #f8d7da;
      color: #721c24;
    }
    
    .edit-role-btn {
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      color: white;
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 8px;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }
    
    .edit-role-btn:hover {
      background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
      transform: scale(1.1);
    }
    
    .history-btn {
      background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
      color: white;
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 8px;
      box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
    }
    
    .history-btn:hover {
      background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
      transform: scale(1.1);
    }

    /* Summary Section */
    .summary-section {
      background: #f8fafc;
      border-radius: 16px;
      padding: 25px;
      border: 1px solid #e2e8f0;
    }

    .period-info {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }

    .info-label {
      color: #64748b;
      font-weight: 500;
    }

    .period-selector {
      background: #ffffff;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 14px;
      color: #334155;
      min-width: 150px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .period-selector:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .period-selector:hover {
      border-color: #cbd5e1;
    }

    .info-value {
      color: #1e293b;
      font-weight: 600;
    }

    /* Summary Cards */
    .summary-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
    }

    .summary-card {
      background: white;
      border-radius: 12px;
      padding: 20px;
      border: 1px solid #e2e8f0;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .summary-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    }

    .card-icon {
      font-size: 24px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f1f5f9;
      border-radius: 10px;
    }

    .card-content {
      flex: 1;
    }

    .card-title {
      font-size: 12px;
      color: #64748b;
      font-weight: 500;
      margin-bottom: 4px;
    }

    .card-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: #1e293b;
    }

    /* Table Header */
    .table-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .table-header h4 {
      font-size: 1.1rem;
      font-weight: 600;
      color: #1e293b;
      margin: 0;
    }

    .table-actions {
      display: flex;
      gap: 10px;
    }

    .action-btn {
      background: #f1f5f9;
      color: #64748b;
      border: none;
      border-radius: 8px;
      padding: 8px 16px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .action-btn:hover {
      background: #e2e8f0;
      color: #475569;
    }

    /* Profiles Section */
    .profiles-section {
      padding: 30px;
      background: #f8fafc;
      border-top: 1px solid #e2e8f0;
    }

    .profiles-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    
    /* Staff name links */
    .staff-name-link {
      color: #3b82f6;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    
    .staff-name-link:hover {
      color: #1d4ed8;
      text-decoration: underline;
    }
    
    /* Profile detail styles */
    .profile-detail {
      background: white;
      border-radius: 16px;
      padding: 30px;
      border: 1px solid #e2e8f0;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
    }
    
    .profile-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 2px solid #f1f5f9;
    }
    
    .profile-info h2 {
      font-size: 2rem;
      font-weight: 700;
      color: #1e293b;
      margin-bottom: 8px;
    }
    
    .profile-role {
      color: #64748b;
      font-size: 1.1rem;
      font-weight: 500;
    }
    
    .profile-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
    }
    
    .stat-item {
      text-align: center;
      padding: 15px;
      background: #f8fafc;
      border-radius: 10px;
      border: 1px solid #e2e8f0;
    }
    
    .stat-label {
      display: block;
      font-size: 0.9rem;
      color: #64748b;
      font-weight: 500;
      margin-bottom: 5px;
    }
    
    .stat-value {
      display: block;
      font-size: 1.5rem;
      font-weight: 700;
      color: #1e293b;
    }
    
    .shifts-container h3 {
      font-size: 1.3rem;
      font-weight: 600;
      color: #1e293b;
      margin-bottom: 20px;
    }
    
    .shifts-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .shift-card {
      background: #f8fafc;
      border-radius: 12px;
      padding: 20px;
      border: 1px solid #e2e8f0;
      transition: all 0.3s ease;
    }
    
    .shift-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    }
    
    .shift-card.night, .shift-card.tom-night, .shift-card.charlotte-night {
      border-left: 4px solid #6366f1;
    }
    
    .shift-card.day, .shift-card.tom-day, .shift-card.charlotte-day {
      border-left: 4px solid #10b981;
    }
    
    .shift-card.holiday {
      border-left: 4px solid #f59e0b;
    }
    .shift-type-badge.double-up {
      background: linear-gradient(135deg, #f3e8ff 0%, #e9d5ff 100%);
      color: #6b21a8;
      border: 1px solid #e9d5ff;
    }
    
    .shift-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
    }
    
    .shift-time, .shift-role {
      font-size: 0.9rem;
      color: #64748b;
    }
    
    .time-label, .role-label {
      font-weight: 600;
      color: #374151;
    }
    
    .close-profile-btn {
      background: #f1f5f9;
      color: #64748b;
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .close-profile-btn:hover {
      background: #e2e8f0;
    }

    /* Time-Off Management Styles */
    .status-badge {
      font-size: 0.8rem;
      font-weight: 700;
      padding: 6px 12px;
      border-radius: 20px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .status-badge.pending {
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      color: #92400e;
      border: 1px solid #fde68a;
    }

    .status-badge.approved {
      background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
      color: #166534;
      border: 1px solid #bbf7d0;
    }

    .status-badge.rejected {
      background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
      color: #991b1b;
      border: 1px solid #fecaca;
    }

    .status-badge.cancelled {
      background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
      color: #374151;
      border: 1px solid #e5e7eb;
    }

    .leave-type-badge {
      font-size: 0.8rem;
      font-weight: 700;
      padding: 6px 12px;
      border-radius: 20px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .leave-type-badge.holiday {
      background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
      color: #1e40af;
      border: 1px solid #bfdbfe;
    }

    .leave-type-badge.sick {
      background: linear-gradient(135deg, #fef2f2 0%, #fecaca 100%);
      color: #dc2626;
      border: 1px solid #fecaca;
    }

    .leave-type-badge.other {
      background: linear-gradient(135deg, #f3e8ff 0%, #e9d5ff 100%);
      color: #7c3aed;
      border: 1px solid #e9d5ff;
    }

    .time-off-action-btn {
      font-size: 0.8rem;
      font-weight: 600;
      padding: 6px 12px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      margin: 2px;
      transition: all 0.3s ease;
    }

    .time-off-action-btn.approve {
      background: #10b981;
      color: white;
    }

    .time-off-action-btn.approve:hover {
      background: #059669;
    }

    .time-off-action-btn.reject {
      background: #ef4444;
      color: white;
    }

    .time-off-action-btn.reject:hover {
      background: #dc2626;
    }

    .time-off-action-btn.view {
      background: #3b82f6;
      color: white;
    }

    .time-off-action-btn.view:hover {
      background: #2563eb;
    }

    .entitlement-progress {
      width: 100%;
      height: 8px;
      background: #e5e7eb;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 4px;
    }

    .entitlement-progress-bar {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s ease;
    }

    .entitlement-progress-bar.available {
      background: linear-gradient(90deg, #10b981 0%, #34d399 100%);
    }

    .entitlement-progress-bar.low {
      background: linear-gradient(90deg, #f59e0b 0%, #fbbf24 100%);
    }

    .entitlement-progress-bar.exhausted {
      background: linear-gradient(90deg, #ef4444 0%, #f87171 100%);
    }

    .pay-amount {
      font-weight: 700;
      font-size: 1.1rem;
    }

    .pay-amount.statutory {
      color: #3b82f6;
    }

    .pay-amount.contractual {
      color: #10b981;
    }

    .pay-amount.final {
      color: #7c3aed;
    }

    .entitlement-status {
      font-size: 0.8rem;
      font-weight: 700;
      padding: 6px 12px;
      border-radius: 20px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .entitlement-status.available {
      background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
      color: #166534;
      border: 1px solid #bbf7d0;
    }

    .entitlement-status.low {
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      color: #92400e;
      border: 1px solid #fde68a;
    }

    .entitlement-status.exhausted {
      background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
      color: #991b1b;
      border: 1px solid #fecaca;
    }

    .entitlement-status.zero-hours {
      background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
      color: #374151;
      border: 1px solid #e5e7eb;
    }

    .action-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .time-off-action-btn {
      padding: 6px 12px;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .time-off-action-btn.approve {
      background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
      color: #166534;
      border: 1px solid #bbf7d0;
    }

    .time-off-action-btn.approve:hover {
      background: linear-gradient(135deg, #bbf7d0 0%, #86efac 100%);
      transform: translateY(-1px);
    }

    .time-off-action-btn.reject {
      background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
      color: #991b1b;
      border: 1px solid #fecaca;
    }

    .time-off-action-btn.reject:hover {
      background: linear-gradient(135deg, #fecaca 0%, #fca5a5 100%);
      transform: translateY(-1px);
    }

    .time-off-action-btn.view {
      background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
      color: #1e40af;
      border: 1px solid #bfdbfe;
    }

    .time-off-action-btn.view:hover {
      background: linear-gradient(135deg, #bfdbfe 0%, #93c5fd 100%);
      transform: translateY(-1px);
    }

    .time-off-action-btn.edit {
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      color: #92400e;
      border: 1px solid #fde68a;
    }

    .time-off-action-btn.edit:hover {
      background: linear-gradient(135deg, #fde68a 0%, #fcd34d 100%);
      transform: translateY(-1px);
    }

    .team-members-table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    .team-members-table th {
      background: linear-gradient(135deg, #374151 0%, #4b5563 100%);
      color: white;
      padding: 16px 12px;
      text-align: left;
      font-weight: 700;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-bottom: 2px solid #6b7280;
    }

    .team-members-table td {
      padding: 16px 12px;
      border-bottom: 1px solid #e5e7eb;
      vertical-align: top;
    }

    .team-members-table tr:hover {
      background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
    }

    .team-members-table tr:last-child td {
      border-bottom: none;
    }
    
    .staff-summary {
      margin-top: 30px;
      padding: 25px;
      border: none;
      border-radius: 16px;
      background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .staff-summary h3 {
      color: #0369a1;
      font-weight: 700;
      font-size: 1.5rem;
      margin-bottom: 20px;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    
    .summary-info {
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 12px;
      border-left: 4px solid #0369a1;
    }
    
    .summary-info p {
      margin: 5px 0;
      color: #374151;
      font-size: 14px;
    }
    
    .summary-table-container {
      overflow-x: auto;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }
    
    .summary-table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      font-family: var(--table-font-family);
      font-size: var(--table-cell-font-size);
    }
    
    .summary-table th {
      background: linear-gradient(135deg, #0369a1 0%, #0284c7 100%);
      color: white;
      font-family: var(--table-font-family);
      font-weight: var(--table-header-font-weight);
      font-size: var(--table-header-font-size);
      padding: 15px 12px;
      text-align: left;
      border: 1px solid #e5e7eb;
    }
    
    .summary-table td {
      padding: 12px;
      border: 1px solid #e5e7eb;
      text-align: left;
      font-family: var(--table-font-family);
      font-size: var(--table-cell-font-size);
      color: var(--table-cell-color);
    }
    
    .summary-table tbody tr:nth-child(even) {
      background-color: #f8fafc;
    }
    
    .summary-table tbody tr:hover {
      background-color: #f1f5f9;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    
    .summary-table .total-shifts {
      font-weight: 600;
      color: #0369a1;
    }
    
    .summary-table .total-hours {
      font-weight: 700;
      color: #059669;
    }
    
    .summary-table .cumulative-hours {
      font-weight: 600;
      color: #7c3aed;
    }
    
    .summary-table .avg-hours {
      font-weight: 600;
      color: #7c3aed;
    }
    
    .role-display {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .role-display.staff-member {
      background-color: #dbeafe;
      color: #1e40af;
    }
    
    .role-display.team-leader {
      background-color: #fef3c7;
      color: #92400e;
    }
    
      .summary-table .pay-amount {
        font-weight: 600;
        color: #8b5cf6;
        background-color: rgba(139, 92, 246, 0.1);
        padding: 4px 8px;
        border-radius: 6px;
      }

      /* Date Range Section */
      .date-range-section {
        margin-bottom: 25px;
        background: white;
        border-radius: 12px;
        padding: 20px;
        border: 1px solid #e2e8f0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }

      .date-range-section h4 {
        margin: 0 0 15px 0;
        font-size: 1.1rem;
        font-weight: 600;
        color: #374151;
        font-family: var(--table-font-family);
      }

      .date-inputs {
        display: flex;
        gap: 20px;
        align-items: end;
        flex-wrap: wrap;
      }

      .date-input-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
        min-width: 150px;
      }

      .date-input-group label {
        font-size: 14px;
        font-weight: 500;
        color: #6b7280;
      }

      .summary-date-input {
        padding: 10px 12px;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        font-size: 14px;
        font-family: 'Inter', sans-serif;
        background: white;
        min-width: 150px;
      }

      .summary-date-input:focus {
        outline: none;
        border-color: #8b5cf6;
        box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
      }



      /* Mobile responsiveness for date range section */
      @media (max-width: 768px) {
        .date-range-section {
          padding: 15px;
        }
        
        .date-inputs {
          flex-direction: column;
          gap: 15px;
          align-items: stretch;
        }
        
        .date-input-group {
          min-width: auto;
        }
        

      }
    
    /* Role history mini button styles removed - no longer needed */

    .shift-history-mini-btn {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      cursor: pointer;
      font-size: 10px;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 4px;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
    }
    
    .shift-history-mini-btn:hover {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      transform: scale(1.1);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
    }
    
    .holiday-requests-mini-btn {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      color: white;
      border: none;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      cursor: pointer;
      font-size: 10px;
      font-weight: 600;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 4px;
      box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
    }
    
    .holiday-requests-mini-btn:hover {
      background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
      transform: scale(1.1);
      box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
    }
    
    .employee-profiles {
      margin-top: 30px;
    }
    
    .employee-profiles h4 {
      color: #0369a1;
      font-weight: 600;
      font-size: 1.2rem;
      margin-bottom: 20px;
    }
    
    .employee-profile {
      background: white;
      border-radius: 16px;
      padding: 25px;
      margin-bottom: 20px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
      border: 1px solid #e2e8f0;
      transition: all 0.3s ease;
    }
    
    .employee-profile:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
    }
    
    .employee-profile-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid #f1f5f9;
    }
    
    .employee-name {
      font-weight: 700;
      font-size: 1.2rem;
      color: #1e293b;
    }
    
    .employee-role {
      color: #64748b;
      font-size: 0.9rem;
      font-weight: 500;
    }
    
    .shift-list {
      max-height: 200px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .shift-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: #f8fafc;
      border-radius: 10px;
      border-left: 4px solid #10b981;
      transition: all 0.3s ease;
    }
    
    .shift-item:hover {
      background: #f1f5f9;
      transform: translateX(2px);
    }
    
    .shift-item.night, .shift-item.tom-night, .shift-item.charlotte-night {
      border-left-color: #6366f1;
    }
    
    .shift-item.holiday {
      border-left-color: #f59e0b;
    }
    
    .shift-item.double-up {
      border-left-color: #8b5cf6;
    }
    
    .shift-date {
      font-weight: 600;
      color: #1e293b;
      font-size: 0.9rem;
    }
    
    .shift-time {
      font-size: 0.8rem;
      color: #64748b;
      margin-top: 2px;
    }
    
    .shift-type {
      font-size: 0.75rem;
      padding: 6px 12px;
      border-radius: 20px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .shift-type.day, .shift-type.tom-day, .shift-type.charlotte-day {
      background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
      color: #166534;
      border: 1px solid #bbf7d0;
    }
    
    .shift-type.night, .shift-type.tom-night, .shift-type.charlotte-night {
      background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
      color: #3730a3;
      border: 1px solid #c7d2fe;
    }
    
    .shift-type.holiday {
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      color: #92400e;
      border: 1px solid #fde68a;
    }
    
    .shift-type.double-up {
      background: linear-gradient(135deg, #f3e8ff 0%, #e9d5ff 100%);
      color: #6b21a8;
      border: 1px solid #e9d5ff;
    }
    
    .no-shifts {
      text-align: center;
      color: #6b7280;
      font-style: italic;
      padding: 20px;
    }
    

    
    .navigation-header {
      margin-bottom: 30px;
      text-align: center;
    }
    
    .main-title {
      font-family: 'Cinzel', 'Times New Roman', serif;
      font-size: 48px;
      font-weight: bold;
      color: #4f46e5;
      text-align: center;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    #period-title {
      font-size: 18px;
      font-weight: normal;
      color: #374151;
      text-align: center;
      margin-bottom: 20px;
    }
    
    .tab-container {
      margin-bottom: 30px;
    }
    
    .tab-buttons {
      display: flex;
      gap: 5px;
      margin-bottom: 20px;
      border-bottom: 2px solid #e5e7eb;
    }
    
    .tab-button {
      background: transparent;
      border: none;
      padding: 12px 24px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      color: #6b7280;
      border-bottom: 3px solid transparent;
      transition: all 0.3s ease;
      border-radius: 8px 8px 0 0;
    }
    
    .tab-button:hover {
      color: #4f46e5;
      background: rgba(79, 70, 229, 0.05);
    }
    
    .tab-button.active {
      color: #4f46e5;
      border-bottom-color: #4f46e5;
      background: rgba(79, 70, 229, 0.1);
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .navigation-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      margin-top: 15px;
    }
    
    .nav-btn {
      background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
      color: white;
      border: none;
      border-radius: 25px;
      padding: 12px 24px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(79, 70, 229, 0.3);
    }
    
    .nav-btn:hover {
      background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(79, 70, 229, 0.4);
    }
    .nav-btn:disabled {
      background: #9ca3af;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .period-selector {
      padding: 12px 20px;
      border: 2px solid #e5e7eb;
      border-radius: 25px;
      font-size: 14px;
      font-weight: 500;
      background-color: white;
      cursor: pointer;
      min-width: 300px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }
    
    .period-selector:focus {
      outline: none;
      border-color: #4f46e5;
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
      transform: translateY(-1px);
    }
    
    .week-heading {
      color: #4f46e5;
      font-weight: 700;
      font-size: 2.2rem;
      margin: 30px 0 20px 0;
      text-align: center;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      body {
        padding: 5px;
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* Internet Explorer 10+ */
      }
      
      body::-webkit-scrollbar {
        display: none; /* Safari and Chrome */
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* Internet Explorer 10+ */
      }
      
      body::-webkit-scrollbar {
        display: none; /* Safari and Chrome */
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* Internet Explorer 10+ */
      }
      
      body::-webkit-scrollbar {
        display: none; /* Safari and Chrome */
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* Internet Explorer 10+ */
      }
      
      body::-webkit-scrollbar {
        display: none; /* Safari and Chrome */
      }
      
      .container {
        padding: 15px;
        border-radius: 10px;
      }
      
      .main-title {
        font-size: 36px;
        margin-bottom: 8px;
      }
      
      #period-title {
        font-size: 16px;
        margin-bottom: 15px;
      }
      
      .navigation-controls {
        flex-direction: column;
        gap: 10px;
      }
      
      .nav-btn {
        padding: 10px 20px;
        font-size: 12px;
        width: 100%;
        max-width: 200px;
      }
      
      .period-selector {
        padding: 10px 15px;
        font-size: 12px;
        min-width: 250px;
        width: 100%;
        max-width: 300px;
      }
      
      .tab-button {
        font-size: 12px;
        padding: 8px 16px;
      }
      
      .staff-management {
        padding: 15px;
        margin-bottom: 20px;
      }
      
      .staff-management h3 {
        font-size: 1.2rem;
        margin-bottom: 15px;
      }
      
      .staff-list {
        gap: 8px;
      }
      
      .staff-item {
        padding: 6px 12px;
        font-size: 14px;
      }
      
      .add-staff-form {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }
      
      .add-staff-input {
        padding: 10px 14px;
        font-size: 14px;
        border-radius: 20px;
      }
      
      .add-btn {
        padding: 10px 20px;
        font-size: 14px;
        border-radius: 20px;
      }
      
      table {
        font-size: 14px;
        margin-bottom: 20px;
        border-radius: 8px;
        display: block;
        overflow-x: auto;
        white-space: normal;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* Internet Explorer 10+ */
      }
      
      table::-webkit-scrollbar {
        display: none; /* Safari and Chrome */
      }
      
      thead, tbody {
        display: table;
        width: 100%;
      }
      
      tr {
        display: table-row;
      }
      
      th, td {
        padding: 12px 8px;
        min-width: 100px;
        font-size: 12px;
        display: table-cell;
      }
      
      th {
        padding: 14px 8px;
        font-size: 11px;
      }
      
      .week-heading {
        font-size: 1.5rem;
        margin: 20px 0 15px 0;
      }
      
      .dropdown {
        width: 280px;
        max-height: 60vh;
      }
      
      .dropdown-option {
        padding: 12px 16px;
        font-size: 14px;
      }
      
      .color-picker {
        position: absolute;
        width: 90%;
        max-width: 280px;
        z-index: 1001;
        padding: 15px;
      }
      
      .recent-colors-grid {
        grid-template-columns: repeat(5, 1fr);
      }
      
      .recent-color-swatch {
        width: 30px;
        height: 30px;
      }
      
      .staff-summary {
        padding: 15px;
        margin-top: 20px;
      }
      
      .staff-summary h3 {
        font-size: 1.2rem;
        margin-bottom: 15px;
      }
      
      .summary-info {
        padding: 10px;
        margin-bottom: 15px;
      }
      
      .summary-info p {
        font-size: 12px;
      }
      
      .summary-table {
        font-size: 12px;
      }
      
      .summary-table th,
      .summary-table td {
        padding: 8px 6px;
      }
      
      .employee-profiles {
        margin-top: 20px;
      }
      
      .employee-profile {
        padding: 15px;
        margin-bottom: 15px;
      }
      
      .employee-profile-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 5px;
      }
      
      .shift-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 5px;
      }
    }
    
    @media (max-width: 480px) {
      .main-title {
        font-size: 28px;
      }
      
      #period-title {
        font-size: 14px;
      }
      
      .period-selector {
        min-width: 200px;
        font-size: 11px;
      }
      
      .nav-btn {
        font-size: 11px;
        padding: 8px 16px;
      }
      
      th, td {
        padding: 8px 4px;
        min-width: 80px;
        font-size: 10px;
      }
      
      th {
        padding: 10px 4px;
        font-size: 9px;
      }
      
      .week-heading {
        font-size: 1.2rem;
      }
      
      .staff-item {
        font-size: 12px;
        padding: 4px 8px;
      }
      
      .delete-btn {
        padding: 2px 6px;
        font-size: 10px;
      }
      
      /* Mobile responsive for new dashboard */
      .dashboard-header {
        flex-direction: column;
        gap: 20px;
        text-align: center;
        padding: 30px 20px;
      }
      
      .header-content h2 {
        font-size: 2rem;
      }
      
      .header-stats {
        justify-content: center;
      }
      
      .dashboard-grid {
        grid-template-columns: 1fr;
        gap: 20px;
        padding: 20px;
      }
      
      .summary-cards {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .staff-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      }
      
      .profiles-grid {
        grid-template-columns: 1fr;
      }
      
      .section-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
      
      .form-group {
        flex-direction: column;
        gap: 10px;
      }
      
      .table-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
      
      /* Mobile responsive for profile */
      .profile-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 20px;
      }
      
      .profile-stats {
        grid-template-columns: 1fr;
        width: 100%;
      }
      
      .shift-details {
        grid-template-columns: 1fr;
      }
      
      .shift-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
    }
    
    .cell-popup {
      position: fixed !important;
      background: white !important;
      border: 2px solid #007bff !important;
      border-radius: 8px !important;
      padding: 15px !important;
      min-width: 300px !important;
      max-width: 400px !important;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15) !important;
      z-index: 10001 !important;
      font-family: Arial, sans-serif !important;
      animation: popupFadeIn 0.2s ease-out !important;
      top: 50% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }
    
    @keyframes popupFadeIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes popupSlideIn {
      from {
        opacity: 0;
        transform: scale(0.95) translateY(-10px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }
    
    @keyframes popupPulse {
      0%, 100% {
        box-shadow: 0 12px 40px rgba(0,123,255,0.3), 0 8px 32px rgba(0,0,0,0.25);
        border-color: #007bff;
      }
      50% {
        box-shadow: 0 12px 40px rgba(0,123,255,0.5), 0 8px 32px rgba(0,0,0,0.35);
        border-color: #0056b3;
      }
    }
    
    .staff-assignment {
      margin-bottom: 10px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f8f9fa;
      transition: all 0.2s ease;
    }
    
    .staff-assignment:hover {
      background: #e9ecef;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .multiple-staff-cell {
      background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%) !important;
      font-weight: 600;
      position: relative;
    }
    
    .multiple-staff-cell::after {
      content: '👥';
      position: absolute;
      top: 2px;
      right: 2px;
      font-size: 10px;
      opacity: 0.7;
    }
    
    /* Flag indicator styles */
    .flag-indicators {
      display: flex;
      justify-content: center;
      gap: 4px;
      margin-top: 4px;
      font-size: 12px;
    }

    .flag-indicator {
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    .flag-indicator.solo-shift {
      background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
      color: white;
    }

    .flag-indicator.training {
      background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
      color: white;
    }


    .flag-indicator.short-notice {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
      color: white;
    }

    .flag-indicator.overtime {
      background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
      color: white;
    }

    .flag-indicator.callout {
      background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      color: white;
    }

    .flag-indicator.payment-period-end {
      background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%);
      color: white;
    }

    /* Note icon styles */
    .note-icon {
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 12px;
      color: #6c757d;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 50%;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      z-index: 5;
      transition: all 0.2s ease;
      cursor: pointer;
    }

    .note-icon:hover {
      transform: scale(1.1);
      color: #495057;
      background: rgba(255, 255, 255, 1);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }

    /* Payment period end column highlighting - borders only */
    .payment-period-end-column {
      border-left: 4px solid #f39c12 !important;
      border-right: 4px solid #f39c12 !important;
      position: relative;
    }

    .payment-period-end-column::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-top: 2px solid #f39c12;
      border-bottom: 2px solid #f39c12;
      pointer-events: none;
      z-index: 1;
    }

    .payment-period-end-column:hover {
      border-left-width: 6px !important;
      border-right-width: 6px !important;
    }

    /* Payment period end header styling */
    .payment-period-end-header {
      background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%) !important;
      color: white !important;
      font-weight: bold !important;
      cursor: pointer !important;
      position: relative;
    }

    .payment-period-end-header::after {
      content: '';
      position: absolute;
      top: 2px;
      right: 5px;
      font-size: 12px;
    }

    .payment-period-end-header:hover {
      background: linear-gradient(135deg, #e67e22 0%, #d35400 100%) !important;
    }

    /* Financial year end column highlighting - borders only */
    .financial-year-end-column {
      border-left: 4px solid #e74c3c !important;
      border-right: 4px solid #e74c3c !important;
      position: relative;
    }

    .financial-year-end-column::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-top: 2px solid #e74c3c;
      border-bottom: 2px solid #e74c3c;
      pointer-events: none;
      z-index: 1;
    }

    .financial-year-end-column:hover {
      border-left-width: 6px !important;
      border-right-width: 6px !important;
    }

    /* Financial year end header styling */
    .financial-year-end-header {
      background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%) !important;
      color: white !important;
      font-weight: bold !important;
      cursor: pointer !important;
      position: relative;
    }

    .financial-year-end-header:hover {
      background: linear-gradient(135deg, #c0392b 0%, #a93226 100%) !important;
    }

    /* Current date highlighting */
    .current-date-header {
      background: linear-gradient(135deg, #00d4aa 0%, #00b894 100%) !important;
      color: white !important;
      font-weight: bold !important;
      cursor: pointer !important;
      position: relative;
      animation: pulse 2s infinite;
    }

    .current-date-header:hover {
      background: linear-gradient(135deg, #00b894 0%, #00a085 100%) !important;
    }

    .current-date-cell {
      border: 3px solid #00d4aa !important;
      position: relative;
      animation: pulse 2s infinite;
    }

    .current-date-cell::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border: 2px solid #00d4aa;
      pointer-events: none;
      z-index: 1;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(0, 212, 170, 0.7);
      }
      70% {
        box-shadow: 0 0 0 10px rgba(0, 212, 170, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(0, 212, 170, 0);
      }
    }
    

  </style>
</head>
<body>


  <div class="container">
    <div class="navigation-header">
      <h1 class="main-title">T&C</h1>
      <h2 id="period-title">Staff Rota: 21 July 2025 to 17 August 2025</h2>
      <div class="navigation-controls">
        <button id="prev-period" class="nav-btn">← Previous 4 Weeks</button>
        <select id="period-selector" class="period-selector">
          <!-- Options will be populated by JavaScript -->
        </select>
        <button id="next-period" class="nav-btn">Next 4 Weeks →</button>
      </div>
    </div>
    
    <div class="tab-container">
      <div class="tab-buttons">
        <button class="tab-button active" data-tab="rota">📅 Rota View</button>
        <button class="tab-button" data-tab="staff">👥 Staff Management</button>
        <button class="tab-button" data-tab="summary">📊 Shift Summary</button>
        <button class="tab-button" data-tab="timeoff">🏖️ Time-Off</button>
      </div>
      
      <div id="rota-tab" class="tab-content active">
        <div class="rota-tab-header">
          <button id="print-rota-btn" class="print-btn" title="Print Rota Tables">
            🖨️ Print
          </button>
        </div>
        
        <div id="tables-container"></div>
        
        <!-- Multi-select toolbar -->
        <div class="multi-select-toolbar" id="multi-select-toolbar">
          <div style="display: flex; align-items: center; gap: 8px;">
            <span style="font-size: 12px; font-weight: bold; color: #4f46e5;">📋 Multi-Select Mode</span>
            <span style="font-size: 12px;">Selected: <span id="selected-count">0</span></span>
          </div>
          <div style="margin-top: 8px;">
            <button class="delete-btn" id="bulk-delete-btn">🗑️ Delete Selected</button>
            <button class="cancel-btn" id="cancel-multi-select-btn">✕ Cancel</button>
          </div>
        </div>
      </div>
      
      <div id="staff-tab" class="tab-content">
        <div class="staff-management-dashboard">
          <!-- Header Section -->
          <div class="dashboard-header">
            <div class="header-content">
              <h2>👥 Staff Management</h2>
              <p class="header-subtitle">Manage your team members and view detailed shift reports</p>
            </div>
            <div class="header-stats">
              <div class="stat-card">
                <div class="stat-number" id="total-staff-count">0</div>
                <div class="stat-label">Total Staff</div>
              </div>
              <div class="stat-card">
                <div class="stat-number" id="team-leaders-count">0</div>
                <div class="stat-label">Team Leaders</div>
              </div>
              <div class="stat-card">
                <div class="stat-number" id="staff-members-count">0</div>
                <div class="stat-label">Staff Members</div>
              </div>
            </div>
          </div>

          <!-- Main Content Grid -->
          <div class="dashboard-grid">
            <!-- Staff Management Section -->
            <div class="management-section">
                            <div class="section-header">
                <h3>TEAM MEMBERS</h3>
                <div style="display: flex; gap: 10px;">
                  <button class="add-staff-btn" id="dashboard-add-staff-btn">
                    <span class="btn-icon">+</span>
                    Add Staff
                  </button>
                </div>
              </div>
              
              <div class="add-staff-form" id="add-staff-form" style="display: none;">
                <div class="form-group">
                  <label for="new-staff-input">Staff Name *</label>
                  <input type="text" id="new-staff-input" class="form-input" placeholder="Enter staff member name" required>
                </div>
                <div class="form-group">
                  <label for="new-staff-role">Role *</label>
                  <select id="new-staff-role" class="form-input" required>
                    <option value="staff member">Staff Member</option>
                    <option value="team leader">Team Leader</option>
                  </select>
                </div>
                <div class="form-group">
                  <label for="new-staff-employment-date">Employment Start Date *</label>
                  <input type="date" id="new-staff-employment-date" class="form-input" required>
                  <script>
                    // Set default date to today
                    document.getElementById('new-staff-employment-date').value = new Date().toISOString().split('T')[0];
                  </script>
                </div>
                <div class="form-group">
                  <label for="new-staff-employment-end-date">Employment End Date</label>
                  <input type="date" id="new-staff-employment-end-date" class="form-input" placeholder="Leave empty if still employed">
                </div>
                <div class="form-group">
                  <label for="new-staff-contracted-hours">Contracted Hours per Week</label>
                  <input type="number" id="new-staff-contracted-hours" class="form-input" placeholder="e.g., 36" min="0" step="0.5">
                </div>
                <div class="form-group">
                  <label for="new-staff-pay-rate">Pay Rate (£/hour)</label>
                  <input type="number" id="new-staff-pay-rate" class="form-input" placeholder="e.g., 12.50" min="0" step="0.01">
                </div>

                <div class="form-group form-actions">
                  <button class="submit-btn" id="submit-staff-btn">Add Staff Member</button>
                  <button class="cancel-btn" id="cancel-staff-btn">Cancel</button>
                </div>
              </div>
              
              <!-- Team Members Table -->
              <div class="team-members-table-container">
                <table class="team-members-table" id="team-members-table">
                  <thead>
                    <tr>
                      <th>MEMBER</th>
                      <th>ROLE</th>
                      <th>STATUS</th>
                      <th>EMPLOYMENT START</th>
                      <th>EMPLOYMENT END</th>
                      <th>PAY RATE</th>
                      <th>CONTRACTED HOURS</th>
                      <th>ACTIONS</th>
                    </tr>
                  </thead>
                  <tbody id="team-members-tbody">
                    <!-- Team members will be populated here -->
                  </tbody>
                </table>
              </div>
                

            </div>


          </div>

          <!-- Employee Profiles Section -->
          <div class="profiles-section" id="profiles-section" style="display: none;">
            <div class="section-header">
              <h3>👤 Employee Profile</h3>
              <button class="close-profile-btn" onclick="closeEmployeeProfile()">
                <span class="btn-icon">×</span>
                Close
              </button>
            </div>
            <div id="employee-profile-detail" class="profile-detail">
              <!-- Individual employee profile will be populated by JavaScript -->
            </div>
          </div>
        </div>
      </div>
      
      <!-- Shift Summary Tab -->
      <div id="summary-tab" class="tab-content">
        <div class="shift-summary-dashboard">
          <!-- Header Section -->
          <header class="dashboard-header">
            <div class="header-content">
              <h2>📊 Shift Summary</h2>
              <p class="header-subtitle">View detailed shift reports and employee breakdowns</p>
            </div>
          </header>

          <!-- Main Content Section -->
          <main class="summary-main-content">
            <!-- Controls Section -->
            <section class="summary-controls">
              <div class="section-header">
                <h3>📊 Shift Summary</h3>
              </div>
                
                <!-- Date Range Selection -->
                <div class="date-range-section">
                  <h4>Select Date Range</h4>
                  <div class="date-inputs">
                    <div class="date-input-group">
                    <label for="summary-from-date">From:</label>
                    <input type="date" id="summary-from-date" class="summary-date-input" aria-label="Start date">
                    </div>
                    <div class="date-input-group">
                    <label for="summary-to-date">To:</label>
                    <input type="date" id="summary-to-date" class="summary-date-input" aria-label="End date">
                    </div>
                </div>
              </div>
            </section>
            
            <!-- Summary Cards Section -->
            <section class="summary-cards" id="summary-cards-container">
              <div class="summary-card" data-metric="total-shifts">
                <div class="card-icon" aria-hidden="true">📅</div>
                  <div class="card-content">
                    <div class="card-title">Total Shifts</div>
                    <div class="card-value" id="total-shifts-value">0</div>
                  </div>
                </div>
              <div class="summary-card" data-metric="day-shifts">
                <div class="card-icon" aria-hidden="true">☀️</div>
                  <div class="card-content">
                    <div class="card-title">Day Shifts</div>
                    <div class="card-value" id="day-shifts-value">0</div>
                  </div>
                </div>
              <div class="summary-card" data-metric="night-shifts">
                <div class="card-icon" aria-hidden="true">🌙</div>
                  <div class="card-content">
                    <div class="card-title">Night Shifts</div>
                    <div class="card-value" id="night-shifts-value">0</div>
                  </div>
                </div>
              <div class="summary-card" data-metric="total-hours">
                <div class="card-icon" aria-hidden="true">⏰</div>
                  <div class="card-content">
                    <div class="card-title">Total Hours</div>
                    <div class="card-value" id="total-hours-value">0</div>
                  </div>
                </div>
              <div class="summary-card" data-metric="total-pay">
                <div class="card-icon" aria-hidden="true">💰</div>
                  <div class="card-content">
                    <div class="card-title">Total Pay</div>
                    <div class="card-value" id="total-pay-value">£0.00</div>
                  </div>
                </div>
            </section>
              
            <!-- Employee Breakdown Table Section -->
            <section class="summary-table-section">
                <div class="table-header">
                  <h4>Employee Breakdown</h4>
                <div class="table-actions">
                  <button id="export-summary-btn" class="export-btn" title="Export data to CSV">
                    <span class="btn-icon">📊</span>
                    Export
                  </button>
                </div>
              </div>
              <div class="summary-table-container">
                <div class="table-loading" id="summary-table-loading" style="display: none;">
                  <div class="loading-spinner"></div>
                  <span>Loading employee data...</span>
                </div>
                <table id="summary-table" class="summary-table" role="table" aria-label="Employee shift summary">
                  <thead>
                    <tr>
                      <th scope="col">Employee</th>
                      <th scope="col">Role</th>
                      <th scope="col">Total</th>
                      <th scope="col">Day</th>
                      <th scope="col">Night</th>
                      <th scope="col">Hours</th>
                      <th scope="col">Cumulative Hours</th>
                      <th scope="col">Pay</th>
                    </tr>
                  </thead>
                  <tbody id="summary-table-body">
                    <!-- Summary data will be populated by JavaScript -->
                  </tbody>
                </table>
            </div>
            </section>
          </main>

          <!-- Employee Profile Modal -->
          <aside class="profiles-section" id="summary-profiles-section" style="display: none;" role="dialog" aria-labelledby="profile-title" aria-modal="true">
            <div class="section-header">
              <h3 id="profile-title">👤 Employee Profile</h3>
              <button class="close-profile-btn" onclick="closeEmployeeProfile()" aria-label="Close employee profile">
                <span class="btn-icon" aria-hidden="true">×</span>
                Close
              </button>
            </div>
            <div id="summary-employee-profile-detail" class="profile-detail">
              <!-- Individual employee profile will be populated by JavaScript -->
            </div>
          </aside>
                </div>
      </div>
    </div>
    
    
  </div>
  
  <!-- Time-Off Management Tab -->
  <div id="timeoff-tab" class="tab-content">
    <div class="time-off-dashboard">
      <!-- Header Section -->
      <div class="dashboard-header">
        <div class="header-content">
          <h2>🏖️ Time-Off Management</h2>
          <p class="header-subtitle">Manage holiday entitlements</p>
        </div>
      </div>

      <!-- Main Content Grid -->
      <div class="dashboard-grid">

        <!-- Holiday Entitlements Section -->
        <div class="management-section">
          <div class="section-header">
            <h3>HOLIDAY ENTITLEMENTS</h3>
          </div>
          
          <!-- Holiday Entitlements Table -->
          <div class="team-members-table-container">
            <table class="team-members-table" id="holiday-entitlements-table">
              <thead>
                <tr>
                  <th>STAFF</th>
                  <th>ENTITLEMENT</th>
                  <th>TAKEN</th>
                  <th>REMAINING</th>
                </tr>
              </thead>
              <tbody id="holiday-entitlements-tbody">
                <!-- Holiday entitlements will be populated here -->
              </tbody>
            </table>
          </div>
        </div>

      </div>
    </div>
  </div>
  <script type="module">
        // Console log capturing for debugging
        window.consoleLogs = [];
        const originalConsoleLog = console.log;
        console.log = function(...args) {
            window.consoleLogs.push(args.join(' '));
            originalConsoleLog.apply(console, args);
        };
    // API service for database operations
    const API_BASE_URL = 'http://localhost:3001/api';
    
    // API service functions
    const apiService = {
      
      // Add color code column to database
      async addColorCodeColumn() {
        try {
          const response = await fetch(`${API_BASE_URL}/migrate/add-color-code`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            }
          });
          const data = await response.json();
          return data;
        } catch (error) {
          console.error('Error adding color code column:', error);
          throw error;
        }
      },
      
      // Update staff member color code
      async updateStaffColorCode(id, colorCode, changedBy = 'system', reason = '', effectiveFromDate = null) {
        try {
          const requestBody = { 
            color_code: colorCode,
            changed_by: changedBy,
            reason: reason
          };
          
          if (effectiveFromDate) {
            requestBody.effective_from_date = effectiveFromDate;
          }
          
          const response = await fetch(`${API_BASE_URL}/staff/${id}/color-code`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody)
          });
          const data = await response.json();
          return data;
        } catch (error) {
          console.error('Error updating staff color code:', error);
          throw error;
        }
      },
      
      // Get color history for a staff member
      async getColorHistory(id) {
        try {
          const response = await fetch(`${API_BASE_URL}/staff/${id}/color-history`);
          const data = await response.json();
          return data;
        } catch (error) {
          console.error('Error fetching color history:', error);
          throw error;
        }
      },
      
      // Get all staff members (current state)
      async getStaffMembers() {
        try {
          const response = await fetch(`${API_BASE_URL}/staff`);
          const data = await response.json();
          
          // Handle the API response structure
          if (data.success && data.data) {
            console.log('✅ Staff members API response:', data);
            return data.data;
          } else {
            console.error('❌ Staff members API error:', data);
            return [];
          }
        } catch (error) {
          console.error('❌ Error fetching staff members:', error);
          return [];
        }
      },
      
      // Get staff members as they were at a specific point in time
      async getHistoricalStaffMembers(date) {
        try {
          console.log('👥 API: Fetching historical staff members for date:', date);
          
          const response = await fetch(`${API_BASE_URL}/staff/historical/${date}`);
          const data = await response.json();
          
          // Handle the API response structure
          if (data.success && data.data) {
            console.log('✅ Historical staff members API response:', data);
            return data.data;
          } else {
            console.error('❌ Historical staff members API error:', data);
            return [];
          }
        } catch (error) {
          console.error('❌ Error fetching historical staff members:', error);
          return [];
        }
      },
      
      // Add new staff member
      async addStaffMember(staffData) {
        try {
          const response = await fetch(`${API_BASE_URL}/staff`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(staffData)
          });
          const data = await response.json();
          return data;
        } catch (error) {
          console.error('Error adding staff member:', error);
          throw error;
        }
      },
      
      // Delete staff member
      async deleteStaffMember(id) {
        try {
          const response = await fetch(`${API_BASE_URL}/staff/${id}`, {
            method: 'DELETE'
          });
          const data = await response.json();
          return data;
        } catch (error) {
          console.error('Error deleting staff member:', error);
          throw error;
        }
      },
      
      // Get all periods
      async getPeriods() {
        try {
          const response = await fetch(`${API_BASE_URL}/periods`);
          const data = await response.json();
          
          // Handle the API response structure
          if (data.success && data.data) {
            console.log('✅ Periods API response:', data);
            return data.data;
          } else {
            console.error('❌ Periods API error:', data);
            return [];
          }
        } catch (error) {
          console.error('❌ Error fetching periods:', error);
          return [];
        }
      },
      
      // Get shifts for a specific period
      async getShiftsForPeriod(periodId) {
        try {
          const response = await fetch(`${API_BASE_URL}/shifts/period/${periodId}`);
          const data = await response.json();
          
          // Handle the API response structure
          if (data.success && data.data) {
            console.log('✅ Shifts for period API response:', data);
            return data.data;
          } else {
            console.error('❌ Shifts for period API error:', data);
            return [];
          }
        } catch (error) {
          console.error('❌ Error fetching shifts for period:', error);
          return [];
        }
      },
      
      // Get all shifts
      async getShifts() {
        try {
          const response = await fetch(`${API_BASE_URL}/shifts`);
          const data = await response.json();
          
          // Handle the API response structure
          if (data.success && data.data) {
            console.log('✅ All shifts API response:', data);
            return data.data;
          } else {
            console.error('❌ All shifts API error:', data);
            return [];
          }
        } catch ( error) {
          console.error('❌ Error fetching shifts:', error);
          return [];
        }
      },
      
      // Get shifts for a specific staff member
      async getShiftsForStaff(staffName) {
        try {
          const response = await fetch(`${API_BASE_URL}/shifts/staff/${encodeURIComponent(staffName)}`);
          const data = await response.json();
          
          // Handle the API response structure
          if (data.success && data.data) {
            console.log('✅ Shifts for staff API response:', data);
            return data.data;
          } else {
            console.error('❌ Shifts for staff API error:', data);
            return [];
          }
        } catch (error) {
          console.error('❌ Error fetching shifts for staff member:', error);
          return [];
        }
      },
      
      // Update staff member role
      async updateStaffRole(staffId, role, changedBy = 'system', reason = '', effectiveFromDate = null) {
        try {
          console.log('👥 API: Updating staff role:', { staffId, role, changedBy, reason, effectiveFromDate });
          
          const requestBody = { 
            role,
            changed_by: changedBy,
            reason: reason
          };
          
          if (effectiveFromDate) {
            requestBody.effective_from_date = effectiveFromDate;
          }
          
          const response = await fetch(`${API_BASE_URL}/staff/${staffId}/role`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody)
          });
          
          console.log('👥 API: Role update response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('👥 API: Error response:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('👥 API: Role update response data:', data);
          return data;
        } catch (error) {
          console.error('👥 API: Error updating staff role:', error);
          throw error;
        }
      },
      
      // Update staff member pay rate
      async updateStaffPayRate(staffId, payRate, changedBy = 'system', reason = '', effectiveFromDate = null) {
        try {
          console.log('💰 API: Updating staff pay rate:', { staffId, payRate, changedBy, reason, effectiveFromDate });
          
          const requestBody = { 
            pay_rate: payRate,
            changed_by: changedBy,
            reason: reason
          };
          
          if (effectiveFromDate) {
            requestBody.effective_from_date = effectiveFromDate;
          }
          
          const response = await fetch(`${API_BASE_URL}/staff/${staffId}/pay-rate`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody)
          });
          
          console.log('💰 API: Pay rate update response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('💰 API: Error response:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('💰 API: Pay rate update response data:', data);
          return data;
        } catch (error) {
          console.error('💰 API: Error updating staff pay rate:', error);
          throw error;
        }
      },

      // Update staff member contracted hours
      async updateStaffContractedHours(staffId, contractedHours, changedBy = 'system', reason = '', effectiveFromDate = null) {
        try {
          console.log('⏰ API: Updating staff contracted hours:', { staffId, contractedHours, changedBy, reason, effectiveFromDate });
          
          const requestBody = { 
            contracted_hours: contractedHours,
            changed_by: changedBy,
            reason: reason
          };
          
          if (effectiveFromDate) {
            requestBody.effective_from_date = effectiveFromDate;
          }
          
          const response = await fetch(`${API_BASE_URL}/staff/${staffId}/contracted-hours`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody)
          });
          
          console.log('⏰ API: Contracted hours update response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('⏰ API: Error response:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('⏰ API: Contracted hours update response data:', data);
          return data;
        } catch (error) {
          console.error('⏰ API: Error updating staff contracted hours:', error);
          throw error;
        }
      },

      // Update staff member employment start date
      async updateStaffEmploymentDate(staffId, employmentDate, changedBy = 'system', reason = '', effectiveFromDate = null) {
        try {
          console.log('📅 API: Updating staff employment start date:', { staffId, employmentDate, changedBy, reason, effectiveFromDate });
          
          const requestBody = { 
            employment_start_date: employmentDate,
            changed_by: changedBy,
            reason: reason
          };
          
          if (effectiveFromDate) {
            requestBody.effective_from_date = effectiveFromDate;
          }
          
          const response = await fetch(`${API_BASE_URL}/staff/${staffId}/employment-date`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody)
          });
          
          console.log('📅 API: Employment date update response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('📅 API: Error response:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('📅 API: Employment date update response data:', data);
          return data;
        } catch (error) {
          console.error('📅 API: Error updating staff employment start date:', error);
          throw error;
        }
      },

      // Update staff member employment end date
      async updateStaffEmploymentEndDate(staffId, employmentEndDate, changedBy = 'system', reason = '', effectiveFromDate = null) {
        try {
          console.log('📅 API: Updating staff employment end date:', { staffId, employmentEndDate, changedBy, reason, effectiveFromDate });
          
          const requestBody = { 
            employment_end_date: employmentEndDate,
            changed_by: changedBy,
            reason: reason
          };
          
          if (effectiveFromDate) {
            requestBody.effective_from_date = effectiveFromDate;
          }
          
          const response = await fetch(`${API_BASE_URL}/staff/${staffId}/employment-end-date`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody)
          });
          
          console.log('📅 API: Employment end date update response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('📅 API: Error response:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('📅 API: Employment end date update response data:', data);
          return data;
        } catch (error) {
          console.error('📅 API: Error updating staff employment end date:', error);
          throw error;
        }
      },

      // Toggle staff member active status
      async toggleStaffActiveStatus(staffId, changedBy = 'system', reason = '', effectiveFromDate = null) {
        try {
          console.log('🔄 API: Toggling staff active status for staff ID:', staffId, { changedBy, reason, effectiveFromDate });
          
          const requestBody = { 
            changed_by: changedBy,
            reason: reason
          };
          
          if (effectiveFromDate) {
            requestBody.effective_from_date = effectiveFromDate;
          }
          
          const response = await fetch(`${API_BASE_URL}/staff/${staffId}/toggle-active`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody)
          });
          
          console.log('🔄 API: Toggle active status response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('🔄 API: Error response:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('🔄 API: Toggle active status response data:', data);
          return data;
        } catch (error) {
          console.error('🔄 API: Error toggling staff active status:', error);
          throw error;
        }
      },
      
      // Get all changes history for a staff member
      async getChangesHistory(staffId) {
        try {
          console.log('📋 API: Fetching changes history for staff ID:', staffId);
          
          const response = await fetch(`${API_BASE_URL}/staff/${staffId}/changes-history?t=${Date.now()}`);
          
          console.log('📋 API: Changes history response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('📋 API: Error response:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('📋 API: Changes history response data:', data);
          return data;
        } catch (error) {
          console.error('📋 API: Error fetching changes history:', error);
          throw error;
        }
      },

      // Get pending change requests for a staff member
      async getChangeRequests(staffId) {
        try {
          console.log('🕐 API: Fetching change requests for staff ID:', staffId);
          
          const response = await fetch(`${API_BASE_URL}/staff/${staffId}/change-requests?t=${Date.now()}`);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('🕐 API: Change requests error response:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('🕐 API: Change requests data received:', data);
          
          if (data.success) {
            return data.data;
          } else {
            throw new Error(data.message || 'Failed to fetch change requests');
          }
        } catch (error) {
          console.error('🕐 API: Error fetching change requests:', error);
          throw error;
        }
      },

      
      // Get role history for a staff member
      async getRoleHistory(staffId) {
        try {
          console.log('👥 API: Fetching role history for staff ID:', staffId);
          
          const response = await fetch(`${API_BASE_URL}/staff/${staffId}/role-history`);
          
          console.log('👥 API: Role history response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('👥 API: Error response:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('👥 API: Role history response data:', data);
          return data;
        } catch (error) {
          console.error('👥 API: Error fetching role history:', error);
          throw error;
        }
      },
      
      // Update shift solo_shift flag
      async updateShiftSoloFlag(shiftId, soloShift) {
        try {
          console.log('📤 API: Updating solo shift flag:', { shiftId, soloShift });
          
          const response = await fetch(`${API_BASE_URL}/shifts/${shiftId}/solo-shift`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ solo_shift: soloShift })
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('📤 API: Solo shift flag update response:', data);
          return data;
        } catch (error) {
          console.error('📤 API: Error updating solo shift flag:', error);
          throw error;
        }
      },
      
      
      // Update shift training flag
      async updateShiftTrainingFlag(shiftId, training) {
        try {
          console.log('📤 API: Updating training flag:', { shiftId, training });
          
          const response = await fetch(`${API_BASE_URL}/shifts/${shiftId}/training`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ training: training })
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('📤 API: Training flag update response:', data);
          return data;
        } catch (error) {
          console.error('📤 API: Error updating training flag:', error);
          throw error;
        }
      },
      
      // Update shift short_notice flag
      async updateShiftShortNoticeFlag(shiftId, shortNotice) {
        try {
          console.log('📤 API: Updating short notice flag:', { shiftId, shortNotice });
          
          const response = await fetch(`${API_BASE_URL}/shifts/${shiftId}/short-notice`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ short_notice: shortNotice })
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('📤 API: Short notice flag update response:', data);
          return data;
        } catch (error) {
          console.error('📤 API: Error updating short notice flag:', error);
          throw error;
        }
      },
      
      // Update shift overtime flag
      async updateShiftOvertimeFlag(shiftId, overtime) {
        try {
          console.log('📤 API: Updating overtime flag:', { shiftId, overtime });
          
          const response = await fetch(`${API_BASE_URL}/shifts/${shiftId}/overtime`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ overtime: overtime })
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('📤 API: Overtime flag update response:', data);
          return data;
        } catch (error) {
          console.error('📤 API: Error updating overtime flag:', error);
          throw error;
        }
      },
      
      // Update shift callout flag
      async updateShiftCalloutFlag(shiftId, callout) {
        try {
          console.log('📤 API: Updating callout flag:', { shiftId, callout });
          
          const response = await fetch(`${API_BASE_URL}/shifts/${shiftId}/call-out`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ call_out: callout })
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('📤 API: Callout flag update response:', data);
          return data;
        } catch (error) {
          console.error('📤 API: Error updating callout flag:', error);
          throw error;
        }
      },
      
      // Check holiday entitlement status for a staff member
      async checkHolidayEntitlementStatus(staffId) {
        try {
          console.log('📤 API: Checking holiday entitlement status for staff ID:', staffId);
          
          const response = await fetch(`${API_BASE_URL}/time-off/holiday-entitlements/${staffId}/status`, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
            }
          });
          
          if (!response.ok) {
            if (response.status === 404) {
              // No holiday entitlement found - this is not an error for our purposes
              return {
                success: true,
                data: {
                  is_fully_utilized: false,
                  employee_type: 'unknown',
                  days_remaining: 0,
                  statutory_entitlement_days: 0
                }
              };
            }
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          const data = await response.json();
          console.log('📤 API: Holiday entitlement status response:', data);
          return data;
        } catch (error) {
          console.error('❌ API: Error checking holiday entitlement status:', error);
          // Return a safe default that won't block the UI
          return {
            success: true,
            data: {
              is_fully_utilized: false,
              employee_type: 'unknown',
              days_remaining: 0,
              statutory_entitlement_days: 0
            }
          };
        }
      },
      
      // Update shift payment_period_end flag
      async updateShiftPaymentPeriodEndFlag(shiftId, paymentPeriodEnd) {
        try {
          console.log('📤 API: Updating payment period end flag:', { shiftId, paymentPeriodEnd });
          
          const response = await fetch(`${API_BASE_URL}/shifts/${shiftId}/payment-period-end`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ payment_period_end: paymentPeriodEnd })
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('📤 API: Payment period end flag update response:', data);
          return data;
        } catch (error) {
          console.error('📤 API: Error updating payment period end flag:', error);
          throw error;
        }
      },
      
      // Update shift notes
      async updateShiftNotes(shiftId, notes) {
        try {
          console.log('📤 API: Updating notes:', { shiftId, notes });
          
          const response = await fetch(`${API_BASE_URL}/shifts/${shiftId}/notes`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ notes: notes })
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('📤 API: Notes update response:', data);
          return data;
        } catch (error) {
          console.error('📤 API: Error updating notes:', error);
          throw error;
        }
      },
      
      // Save or update shift assignment
      async saveShiftAssignment(shiftData) {
        try {
          console.log('📤 API: Sending shift data:', shiftData);
          
          const response = await fetch(`${API_BASE_URL}/shifts`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(shiftData)
          });
          
          console.log('📤 API: Response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('📤 API: Error response:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('📤 API: Response data:', data);
          return data;
        } catch (error) {
          console.error('📤 API: Error saving shift:', error);
          throw error;
        }
      },
      
      // Delete shift assignment
      async deleteShiftAssignment(periodId, weekNumber, shiftStartDatetime, shiftType) {
        try {
          console.log('🗑️ API: Attempting to delete shift assignment:', {
            periodId,
            weekNumber,
            shiftStartDatetime,
            shiftType
          });
          
          const response = await fetch(`${API_BASE_URL}/shifts/delete`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              periodId,
              weekNumber,
              shiftStartDatetime,
              shiftType
            })
          });
          
          console.log('🗑️ API: Response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('🗑️ API: Error response:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('🗑️ API: Delete response:', data);
          
          
          
          return data;
        } catch (error) {
          console.error('🗑️ API: Error deleting shift:', error);
          throw error;
        }
      },
      
      // Clear all shifts for a period
      async clearShifts(periodId, weekNumber, date, shiftType) {
        try {
          console.log('🗑️ API: Attempting to clear shifts:', {
            periodId,
            weekNumber,
            date,
            shiftType
          });
          
          if (!periodId) {
            throw new Error('Period ID is required for clearing shifts');
          }
          
          // Use the direct clear endpoint that works
          const response = await fetch(`${API_BASE_URL}/shifts/clear-direct`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              periodId
            })
          });
          
          console.log('🗑️ API: Clear response status:', response.status);
          
          if (!response.ok) {
            let errorText = 'Unknown error';
            try {
              errorText = await response.text();
            } catch (e) {
              console.warn('Could not parse error response:', e);
            }
            console.error('🗑️ API: Clear error response:', errorText);
            throw new Error(`Clear request failed (HTTP ${response.status}): ${errorText}`);
          }
          
          let data;
          try {
            data = await response.json();
          } catch (e) {
            console.warn('Could not parse response as JSON:', e);
            throw new Error('Invalid response from server');
          }
          
          console.log('🗑️ API: Clear response:', data);
          
          // Ensure the response has the expected structure
          if (typeof data.clearedCount === 'undefined') {
            console.warn('Response missing clearedCount, defaulting to 0');
            data.clearedCount = 0;
          }
          
          
          
          return data;
        } catch (error) {
          console.error('🗑️ API: Error clearing shifts:', error);
          throw error;
        }
      },
      // Update history field
      async updateHistoryField(historyId, field, value) {
        try {
          console.log('📝 API: Updating history field:', { historyId, field, value });
          
          const response = await fetch(`${API_BASE_URL}/history/${historyId}/${field}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ value })
          });
          
          console.log('📝 API: Update history field response status:', response.status);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error('📝 API: Error response:', errorText);
            throw new Error(`HTTP ${response.status}: ${errorText}`);
          }
          
          const data = await response.json();
          console.log('📝 API: Update history field response data:', data);
          return data;
        } catch (error) {
          console.error('📝 API: Error updating history field:', error);
          throw error;
        }
      }
    };

    // Rota data for Week 1 (from document)
    // Start with empty rota data - will be populated from database or user assignments
    const emptyWeekData = [
      { role: 'Tom Day', days: ['', '', '', '', '', '', ''] },
      { role: 'Charlotte Day', days: ['', '', '', '', '', '', ''] },
      { role: 'Double Up', days: ['', '', '', '', '', '', ''] },
      { role: 'Tom Night', days: ['', '', '', '', '', '', ''] },
      { role: 'Charlotte Night', days: ['', '', '', '', '', '', ''] },
      { role: 'HOLIDAY', days: ['', '', '', '', '', '', ''] }
    ];

    // Initialize all weeks with empty data
    window.rotaData = {
      week1: JSON.parse(JSON.stringify(emptyWeekData)),
      week2: JSON.parse(JSON.stringify(emptyWeekData)),
      week3: JSON.parse(JSON.stringify(emptyWeekData)),
      week4: JSON.parse(JSON.stringify(emptyWeekData))
    };

    // Staff color mapping
    let staffColors = {
      '': '',
      'Helen': '#EE0000',
      'Fung': '#FFFF00',
      'Anne': '#00B050',
      'Annie': '#247A00',
      'Lisa': '#CC99FF',
      'Janet': '#FF66FF',
      'Clara': '#0070C0',
      'John': '#00B0F0',
      'Vania': '#7030A0',
      'Yasser': '#C4BC96',
      'Matt': '#FFC000',
      'FW': '#935CC3',
      'HC': '#D52BD5'
    };

    // Available staff names for dropdown
    window.availableNames = ['', 'Helen', 'Fung', 'Anne', 'Lisa', 'Janet', 'Clara', 'John', 'Vania', 'Yasser', 'Matt', 'FW', 'HC'];
    availableNames.splice(4, 0, 'Annie'); // Insert Annie after Anne
    
    // Global variable to store staff members with role information
    window.globalStaffMembers = [];

    // Custom cell colors storage
    let customCellColors = {};

    // Recent colors storage (up to 7 colors)


    // Current period tracking will be initialized in initializePeriods()
    
    // Generate all 4-week periods starting from July 21, 2025
    async function generatePeriods() {
      try {
        console.log('📅 Fetching periods from database...');
        const dbPeriods = await apiService.getPeriods();
        console.log('✅ Database periods fetched:', dbPeriods.length);
        
        const periods = [];
        
        // Map database periods to frontend format
        dbPeriods.forEach((dbPeriod, index) => {
          const startDate = new Date(dbPeriod.start_date);
          const endDate = new Date(dbPeriod.end_date);
          
          console.log(`📅 Processing period ${index}:`, {
            period_id: dbPeriod.period_id,
            start_date: dbPeriod.start_date,
            end_date: dbPeriod.end_date,
            startDate: startDate.toISOString(),
            endDate: endDate.toISOString()
          });
          
          // Ensure we're working with the correct dates
          // The database stores dates in local time, but we need to ensure consistency
          const adjustedStartDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
          const adjustedEndDate = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
          
          const weeks = [];
          for (let week = 0; week < 4; week++) {
            const weekStart = new Date(adjustedStartDate);
            weekStart.setDate(adjustedStartDate.getDate() + (week * 7));
            weeks.push(weekStart);
            console.log(`   Week ${week + 1} starts: ${weekStart.toISOString()} (${weekStart.toLocaleDateString('en-GB')})`);
          }
          
          periods.push({
            period_id: dbPeriod.period_id,
            start: adjustedStartDate,
            end: adjustedEndDate,
            weeks: weeks,
            title: `${adjustedStartDate.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })} to ${adjustedEndDate.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })}`
          });
        });
        
        console.log('📅 Processed periods:', periods.length);
        return periods;
      } catch (error) {
        console.error('❌ Error fetching periods:', error);
        // Fallback to generating periods locally if database fails
        const periods = [];
        const startDate = new Date(2025, 6, 21); // July 21, 2025
        
        for (let i = 0; i < 10; i++) { // Generate first 10 periods
          const periodStart = new Date(startDate);
          periodStart.setDate(startDate.getDate() + (i * 28));
          
          const periodEnd = new Date(periodStart);
          periodEnd.setDate(periodStart.getDate() + 27);
          
          const weeks = [];
          for (let week = 0; week < 4; week++) {
            const weekStart = new Date(periodStart);
            weekStart.setDate(periodStart.getDate() + (week * 7));
            weeks.push(weekStart);
          }
          
          periods.push({
            period_id: `fallback-${i}`,
            start: periodStart,
            end: periodEnd,
            weeks: weeks,
            title: `${periodStart.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })} to ${periodEnd.toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })}`
          });
        }
        
        return periods;
      }
    }
    
    window.allPeriods = [];
    window.currentPeriodIndex = 0;
    
    // Initialize periods asynchronously
    async function initializePeriods() {
      try {
        console.log('🔄 Initializing periods...');
        allPeriods = await generatePeriods();
        console.log('✅ Periods initialized:', allPeriods.length);
        
        // Find the period containing today's date
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Reset time to start of day
        
        console.log('📅 Today\'s date:', today.toISOString());
        console.log('📅 Looking for period containing today...');
        
        window.currentPeriodIndex = 0; // Default to first period
        
        for (let i = 0; i < allPeriods.length; i++) {
          const period = allPeriods[i];
          console.log(`📅 Checking period ${i}: ${period.start.toISOString()} to ${period.end.toISOString()}`);
          if (today >= period.start && today <= period.end) {
            window.currentPeriodIndex = i;
            console.log(`📅 Found current period: ${period.title} (index: ${i})`);
            break;
          }
        }
        
        console.log(`📅 Final currentPeriodIndex set to: ${window.currentPeriodIndex}`);
        console.log(`📅 Selected period: ${allPeriods[window.currentPeriodIndex].title}`);
        
        // Update UI
        updatePeriodTitle();
        populatePeriodSelector();
        updateNavigationButtons();
        
        // Sync rotaData with initial period
        syncRotaDataWithCurrentPeriod();
        
        // Load initial data for the current period
        await changePeriod(window.currentPeriodIndex);
        
        console.log('✅ Period initialization complete');
      } catch (error) {
        console.error('❌ Error initializing periods:', error);
      }
    }



    // Function to update period title
    function updatePeriodTitle() {
      const period = allPeriods[currentPeriodIndex];
      document.getElementById('period-title').textContent = `Staff Rota: ${period.title}`;
    }
    
    // Function to populate period selector
    function populatePeriodSelector() {
      const selector = document.getElementById('period-selector');
      selector.innerHTML = '';
      
      allPeriods.forEach((period, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = `Period ${index + 1}: ${period.title}`;
        if (index === currentPeriodIndex) {
          option.selected = true;
        }
        selector.appendChild(option);
      });
    }
    
    // Function to update navigation buttons
    function updateNavigationButtons() {
      const prevBtn = document.getElementById('prev-period');
      const nextBtn = document.getElementById('next-period');
      
      prevBtn.disabled = currentPeriodIndex === 0;
      nextBtn.disabled = currentPeriodIndex === allPeriods.length - 1;
    }
    
    // Function to change period
    async function changePeriod(newIndex) {
      if (newIndex >= 0 && newIndex < allPeriods.length) {
        console.log(`🔄 Changing period from ${currentPeriodIndex} to ${newIndex}`);
        currentPeriodIndex = newIndex;
        
        // Sync rotaData with the new period
        syncRotaDataWithCurrentPeriod();
        
        updatePeriodTitle();
        updateNavigationButtons();
        populatePeriodSelector();
        
        // Load shifts for the new period and then regenerate tables
        console.log('🔄 Loading shifts for new period...');
        const currentPeriod = allPeriods[currentPeriodIndex];
        if (currentPeriod) {
          console.log('📅 New period:', currentPeriod);
          console.log('📅 Period ID:', currentPeriod.period_id);
          
          const shifts = await apiService.getShiftsForPeriod(currentPeriod.period_id);
          console.log('📊 Shifts loaded for new period:', shifts.length);
          
          // Clear existing rota data
          Object.keys(rotaData).forEach(weekKey => {
            rotaData[weekKey].forEach(row => {
              row.days.fill('');
            });
          });
          
          // Group shifts by time slot and shift type to handle multiple staff assignments
          const shiftGroups = {};
          shifts.forEach(shift => {
            // Create a unique key based on period, week, date, shift type, and time slot
            const shiftDate = new Date(shift.shift_start_datetime).toISOString().split('T')[0];
            const shiftTime = new Date(shift.shift_start_datetime).toTimeString().slice(0, 5);
            const groupKey = `${shift.period_id}_${shift.week_number}_${shiftDate}_${shift.shift_type}_${shiftTime}`;
            
            if (!shiftGroups[groupKey]) {
              shiftGroups[groupKey] = [];
            }
            shiftGroups[groupKey].push(shift);
          });
          
          console.log('📊 Shift groups created:', Object.keys(shiftGroups).length);
          
          // Process each unique shift group
          Object.keys(shiftGroups).forEach(groupKey => {
            const shiftAssignments = shiftGroups[groupKey];
            const firstShift = shiftAssignments[0]; // Use first shift for common data
            
            console.log(`🔄 Processing shift group ${groupKey}:`, {
              staffCount: shiftAssignments.length,
              staffNames: shiftAssignments.map(s => s.staff_name),
              weekNumber: firstShift.week_number,
              shiftType: firstShift.shift_type,
              startDate: firstShift.shift_start_datetime
            });
            
            const weekKey = `week${firstShift.week_number}`;
            const weekIndex = firstShift.week_number - 1;
            
            // Calculate the day index based on the shift start date
            const shiftStartDate = new Date(firstShift.shift_start_datetime);
            const weekStartDate = new Date(currentPeriod.weeks[weekIndex]);
            const dayIndex = Math.floor((shiftStartDate - weekStartDate) / (24 * 60 * 60 * 1000));
            
            console.log(`📅 Date calculations:`, {
              shiftStartDate: shiftStartDate.toISOString(),
              weekStartDate: weekStartDate.toISOString(),
              dayIndex: dayIndex,
              shiftStartDateLocal: shiftStartDate.toLocaleDateString(),
              weekStartDateLocal: weekStartDate.toLocaleDateString(),
              dayDifference: Math.floor((shiftStartDate - weekStartDate) / (24 * 60 * 60 * 1000))
            });
            
            // Validate day index
            if (dayIndex < 0 || dayIndex > 6) {
              console.warn(`⚠️ Invalid day index ${dayIndex} for shift group ${groupKey}, skipping. Shift date: ${shiftStartDate.toLocaleDateString()}, Week start: ${weekStartDate.toLocaleDateString()}`);
              return;
            }
            
            // Find the appropriate row based on shift type
            let rowIndex = 0; // Default to first row
            if (firstShift.shift_type === 'Tom Night') {
              rowIndex = 3; // Tom Night
            } else if (firstShift.shift_type === 'Tom Day') {
              rowIndex = 0; // Tom Day
            } else if (firstShift.shift_type === 'Charlotte Day') {
              rowIndex = 1; // Charlotte Day
            } else if (firstShift.shift_type === 'Double Up') {
              rowIndex = 2; // Double Up
            } else if (firstShift.shift_type === 'Charlotte Night') {
              rowIndex = 4; // Charlotte Night
            } else if (firstShift.shift_type === 'HOLIDAY') {
              rowIndex = 5; // HOLIDAY
            }
            
            console.log(`📍 Row assignment:`, {
              shiftType: firstShift.shift_type,
              rowIndex: rowIndex,
              weekKey: weekKey,
              rotaDataExists: !!rotaData[weekKey],
              rowExists: rotaData[weekKey] ? !!rotaData[weekKey][rowIndex] : false
            });
            
            // Update the rota data with complete assignment information including flags
            if (rotaData[weekKey] && rotaData[weekKey][rowIndex]) {
              // Convert shift assignments to the format expected by the UI
              const assignments = shiftAssignments.map(shift => ({
                staffName: shift.staff_name,
                startTime: new Date(shift.shift_start_datetime).toTimeString().slice(0, 5),
                endTime: new Date(shift.shift_end_datetime).toTimeString().slice(0, 5),
                soloShift: shift.solo_shift || false,
                training: shift.training || false,
                shortNotice: shift.short_notice || false,
                callout: shift.call_out || false,
                overtime: shift.overtime || false,
                paymentPeriodEnd: shift.payment_period_end || false,
                notes: shift.notes || '',
                shiftId: shift.shift_id
              }));
              
              // Create the day object with assignments and display text
              const dayObject = {
                assignments: assignments,
                displayText: assignments.map(a => a.staffName).join(', ')
              };
              
              rotaData[weekKey][rowIndex].days[dayIndex] = dayObject;
              console.log(`✅ Loaded shift with flags: ${dayObject.displayText} for ${weekKey}, day ${dayIndex + 1}`, {
                soloShift: assignments[0].soloShift,
                training: assignments[0].training,
                shortNotice: assignments[0].shortNotice,
                callout: assignments[0].callout,
                overtime: assignments[0].overtime,
                paymentPeriodEnd: assignments[0].paymentPeriodEnd,
                notes: assignments[0].notes
              });
              console.log(`🔍 DEBUG: Full assignment object for ${dayObject.displayText}:`, assignments[0]);
            } else {
              console.warn(`⚠️ Could not update rotaData: weekKey=${weekKey}, rowIndex=${rowIndex}, dayIndex=${dayIndex}`);
            }
          });
          
          console.log('📊 Final rotaData after period change:', JSON.stringify(rotaData, null, 2));
        } else {
          console.error('❌ No current period found for period change');
        }

        console.log('🔄 Regenerating tables after period change...');
        await regenerateTables();
        
        // Update Shift Summary date range when period changes
        updateShiftSummaryDateRange();
        
        console.log('✅ Period change completed successfully');
      } else {
        console.warn(`⚠️ Invalid period index: ${newIndex}, valid range: 0-${allPeriods.length - 1}`);
      }
    }

    // Function to update staff list display
    async function updateStaffList() {
      console.log('🔄 Updating staff list...');
      console.log('📊 Available names:', availableNames);
      
      const staffListContainer = document.getElementById('team-members-tbody');
      if (!staffListContainer) {
        console.error('❌ Team members table body not found');
        return;
      }
      
      console.log('✅ Team members table body found, clearing and rebuilding...');
      
      // Force clear the container
      staffListContainer.innerHTML = '';
      
      // Get all staff names from globalStaffMembers and sort them
      let staffNames = window.globalStaffMembers.map(staff => staff.staff_name).filter(name => name !== '');
      
      // Sort staff names: active members first, then inactive members
      staffNames.sort((nameA, nameB) => {
        const staffA = window.globalStaffMembers.find(staff => staff.staff_name === nameA);
        const staffB = window.globalStaffMembers.find(staff => staff.staff_name === nameB);
        
        const isActiveA = staffA && staffA.is_active !== false;
        const isActiveB = staffB && staffB.is_active !== false;
        
        // Active members come first (return -1), inactive members come last (return 1)
        if (isActiveA && !isActiveB) return -1;
        if (!isActiveA && isActiveB) return 1;
        
        // If both have same status, sort alphabetically by name
        return nameA.localeCompare(nameB);
      });
      
      console.log('👥 Staff names to display (sorted):', staffNames);
      
      
      if (staffNames.length === 0) {
        console.log('⚠️ No staff names to display');
        const noStaffMsg = document.createElement('tr');
        noStaffMsg.innerHTML = '<td colspan="8" style="text-align: center; color: #666; padding: 20px; font-style: italic;">No staff members found</td>';
        staffListContainer.appendChild(noStaffMsg);
      } else {
        // Update tab visibility based on current staff status
        const hasActiveStaff = staffNames.some(name => {
          const staffMember = window.globalStaffMembers.find(staff => staff.staff_name === name);
          return staffMember && staffMember.is_active !== false;
        });
        
        // Update tab visibility
        updateTabVisibilityBasedOnStaff(hasActiveStaff);
        
        staffNames.forEach((name, index) => {
          const staffRow = document.createElement('tr');
          
          // Find staff member data including role
          const staffMember = window.globalStaffMembers.find(staff => staff.staff_name === name);
          const currentRole = staffMember ? staffMember.role : 'staff member';
          const isActive = staffMember && staffMember.is_active !== false; // Default to true if not set
          
          // Add inactive class if staff member is not active
          if (!isActive) {
            staffRow.className = 'staff-row inactive';
          } else {
            staffRow.className = 'staff-row';
          }
          
                      // Get color from database or fallback to predefined colors
            const predefinedColors = {
              'Helen': '#EE0000',
              'Fung': '#FFFF00', 
              'Anne': '#00B050',
              'Annie': '#247A00',
              'Lisa': '#CC99FF',
              'Janet': '#FF66FF',
              'Clara': '#0070C0',
              'John': '#00B0F0',
              'Vania': '#7030A0',
              'Yasser': '#C4BC96',
              'Matt': '#FFC000',
              'FW': '#935CC3',
              'HC': '#D52BD5'
            };
            
            const colorCode = staffMember && staffMember.hasOwnProperty('color_code') && staffMember.color_code ? staffMember.color_code : predefinedColors[name] || '#3b82f6';
            
            // Member Column
            const memberCell = document.createElement('td');
            const memberInfo = document.createElement('div');
            memberInfo.className = 'member-info';
            
            const avatar = document.createElement('div');
            avatar.className = 'member-avatar';
            avatar.style.backgroundColor = colorCode;
            avatar.textContent = name.charAt(0).toUpperCase();
            avatar.title = `Click to change color (${colorCode})`;
            avatar.style.cursor = 'pointer';
            avatar.addEventListener('click', () => editStaffColor(name, staffMember, colorCode));
          
          const memberDetails = document.createElement('div');
          memberDetails.className = 'member-details';
          
          const memberName = document.createElement('div');
          memberName.className = 'member-name';
          memberName.textContent = name;
          
          const memberStatus = document.createElement('div');
          memberStatus.className = 'member-status';
          memberStatus.textContent = 'Active Member';
          
          const historyIcon = document.createElement('div');
          historyIcon.className = 'history-icon';
          historyIcon.innerHTML = '📅';
          historyIcon.title = `View ${name}'s complete history (roles, colors, etc.)`;
          historyIcon.addEventListener('click', () => viewStaffHistory(name, staffMember));
          
          memberDetails.appendChild(memberName);
          memberDetails.appendChild(memberStatus);
          memberInfo.appendChild(avatar);
          memberInfo.appendChild(memberDetails);
          memberInfo.appendChild(historyIcon);
          memberCell.appendChild(memberInfo);
          
          // Role Column
          const roleCell = document.createElement('td');
          const roleSection = document.createElement('div');
          roleSection.className = 'role-section';
          
          const roleBadge = document.createElement('span');
          roleBadge.className = `role-badge ${currentRole.replace(' ', '-')}`;
          roleBadge.textContent = currentRole;
          
          const roleEditIcon = document.createElement('div');
          roleEditIcon.className = 'role-edit-icon';
          roleEditIcon.innerHTML = '✏️';
          roleEditIcon.title = `Edit ${name}'s role`;
          roleEditIcon.addEventListener('click', () => editStaffRole(name, staffMember));
          
          roleSection.appendChild(roleBadge);
          roleSection.appendChild(roleEditIcon);
          roleCell.appendChild(roleSection);
          
          // Status Column
          const statusCell = document.createElement('td');
          const statusToggle = document.createElement('div');
          statusToggle.className = 'status-toggle';
          statusToggle.innerHTML = `
            <label class="toggle-switch">
              <input type="checkbox" ${isActive ? 'checked' : ''} class="status-checkbox">
              <span class="toggle-slider"></span>
            </label>
            <span class="status-label ${isActive ? 'active' : 'inactive'}">${isActive ? 'Active' : 'Inactive'}</span>
          `;
          
          // Add click event for status toggle
          const statusCheckbox = statusToggle.querySelector('.status-checkbox');
          const statusLabel = statusToggle.querySelector('.status-label');
          
          statusCheckbox.addEventListener('change', async (event) => {
            const newStatus = event.target.checked;
            
            // Create a simple dialog to collect change information
            const statusDialog = document.createElement('div');
            statusDialog.className = 'status-change-dialog';
            statusDialog.innerHTML = `
              <div class="status-change-content">
                <div class="status-change-header">
                  <h3>${newStatus ? 'Activate' : 'Deactivate'} ${staffMember.staff_name}</h3>
                  <button class="close-status-dialog" onclick="this.closest('.status-change-dialog').remove()">×</button>
                </div>
                <div class="status-change-body">
                  <div class="change-detail-row">
                    <label for="status-changed-by">Changed By:</label>
                    <input type="text" id="status-changed-by" class="changed-by-input" 
                           value="system" placeholder="Enter who made the change">
                  </div>
                  <div class="change-detail-row">
                    <label for="status-reason">Reason:</label>
                    <input type="text" id="status-reason" class="reason-input" 
                           value="" placeholder="Enter reason for change">
                  </div>
                  <div class="change-detail-row">
                    <label for="status-effective-date">Effective From Date & Time:</label>
                    <input type="datetime-local" id="status-effective-date" class="effective-date-input" 
                           value="${new Date().toISOString().slice(0, 16)}">
                  </div>
                </div>
                <div class="status-change-actions">
                  <button class="cancel-status-btn" onclick="this.closest('.status-change-dialog').remove()">Cancel</button>
                  <button class="confirm-status-btn" onclick="confirmStatusChange('${staffMember.unique_id}', ${newStatus}, this)">Confirm</button>
                </div>
              </div>
            `;
            
                        document.body.appendChild(statusDialog);
            
            // Revert the checkbox since we're showing a dialog
            event.target.checked = !newStatus;
          });
          
          statusCell.appendChild(statusToggle);
          
          // Pay Rate Column
          const payRateCell = document.createElement('td');
          const payRateValue = staffMember && staffMember.pay_rate ? `£${staffMember.pay_rate}/hour` : '£0.00/hour';
          payRateCell.innerHTML = `
            <div class="pay-rate-section">
              <span class="pay-rate-value">${payRateValue}</span>
              <div class="pay-rate-edit-icon" title="Edit ${name}'s pay rate">✏️</div>
            </div>
          `;
          
          // Add click event for pay rate editing
          const payRateEditIcon = payRateCell.querySelector('.pay-rate-edit-icon');
          payRateEditIcon.addEventListener('click', () => editStaffPayRate(name, staffMember));
          
          // Contracted Hours Column
          const contractedHoursCell = document.createElement('td');
          const contractedHoursValue = staffMember && staffMember.contracted_hours ? `${staffMember.contracted_hours}h` : '0h';
          contractedHoursCell.innerHTML = `
            <div class="contracted-hours-section">
              <span class="contracted-hours-value">${contractedHoursValue}</span>
              <div class="contracted-hours-edit-icon" title="Edit ${name}'s contracted hours">✏️</div>
            </div>
          `;
          
          // Add click event for contracted hours editing
          const contractedHoursEditIcon = contractedHoursCell.querySelector('.contracted-hours-edit-icon');
          contractedHoursEditIcon.addEventListener('click', () => editStaffContractedHours(name, staffMember));
          
          // Actions Column
          const actionsCell = document.createElement('td');
          const actionsSection = document.createElement('div');
          actionsSection.className = 'actions-section';
          
          const removeBtn = document.createElement('button');
          removeBtn.className = 'action-btn remove-btn';
          removeBtn.innerHTML = '<span>🗑️</span> REMOVE';
          removeBtn.title = `Remove ${name}`;
          removeBtn.addEventListener('click', () => deleteStaffMember(name));
          
          actionsSection.appendChild(removeBtn);
          actionsCell.appendChild(actionsSection);
          
          // Employment Start Date Column
          const employmentDateCell = document.createElement('td');
          const employmentDateValue = staffMember && staffMember.employment_start_date ? 
            new Date(staffMember.employment_start_date).toLocaleDateString('en-GB') : 'Not set';
          employmentDateCell.innerHTML = `
            <div class="employment-date-section">
              <span class="employment-date-value">${employmentDateValue}</span>
              <div class="employment-date-edit-icon" title="Edit ${name}'s employment start date">✏️</div>
            </div>
          `;
          
          // Add click event for employment date editing
          const employmentDateEditIcon = employmentDateCell.querySelector('.employment-date-edit-icon');
          employmentDateEditIcon.addEventListener('click', () => editStaffEmploymentDate(name, staffMember));
          
          // Employment End Date Column
          const employmentEndDateCell = document.createElement('td');
          const employmentEndDateValue = staffMember && staffMember.employment_end_date ? 
            new Date(staffMember.employment_end_date).toLocaleDateString('en-GB') : 'Still employed';
          employmentEndDateCell.innerHTML = `
            <div class="employment-end-date-section">
              <span class="employment-end-date-value">${employmentEndDateValue}</span>
              <div class="employment-end-date-edit-icon" title="Edit ${name}'s employment end date">✏️</div>
            </div>
          `;
          
          // Add click event for employment end date editing
          const employmentEndDateEditIcon = employmentEndDateCell.querySelector('.employment-end-date-edit-icon');
          employmentEndDateEditIcon.addEventListener('click', () => editStaffEmploymentEndDate(name, staffMember));
          
          // Add all cells to the row
          staffRow.appendChild(memberCell);
          staffRow.appendChild(roleCell);
          staffRow.appendChild(statusCell);
          staffRow.appendChild(employmentDateCell);
          staffRow.appendChild(employmentEndDateCell);
          staffRow.appendChild(payRateCell);
          staffRow.appendChild(contractedHoursCell);
          staffRow.appendChild(actionsCell);
          
          staffListContainer.appendChild(staffRow);
          
          console.log(`✅ Added staff member: ${name} with role: ${currentRole}`);
        });
      }
      
      // Update staff count
      const totalStaffCount = document.getElementById('total-staff-count');
      if (totalStaffCount) {
        totalStaffCount.textContent = staffNames.length;
        console.log(`📊 Updated staff count: ${staffNames.length}`);
      }
      
      // Update role counts
      const teamLeadersCount = document.getElementById('team-leaders-count');
      const staffMembersCount = document.getElementById('staff-members-count');
      
      if (teamLeadersCount && staffMembersCount) {
        const teamLeaders = window.globalStaffMembers.filter(staff => staff.role === 'team leader').length;
        const staffMembers = window.globalStaffMembers.filter(staff => staff.role === 'staff member').length;
        
        teamLeadersCount.textContent = teamLeaders;
        staffMembersCount.textContent = staffMembers;
        
        console.log(`📊 Updated role counts: ${teamLeaders} team leaders, ${staffMembers} staff members`);
      }
      
      // Update active shifts count
      const activeShiftsCount = document.getElementById('active-shifts-count');
      if (activeShiftsCount) {
        // This will be updated by displayEmployeeSummaries()
        console.log('📊 Active shifts count will be updated by displayEmployeeSummaries');
      }
      
      console.log('✅ Staff list update complete');
      
      // Update summary tab stats
      updateSummaryTabStats();
      
      // Clear shift summary cache to ensure fresh data
      if (typeof window.clearShiftSummaryCache === 'function') {
        window.clearShiftSummaryCache();
      }
      
      // Add visual feedback
      if (staffListContainer && staffListContainer.children.length > 0) {
        console.log(`✅ Staff list now contains ${staffListContainer.children.length} items`);
        
        // Add a brief highlight to show the update
        staffListContainer.style.backgroundColor = '#f0f8ff';
        setTimeout(() => {
          staffListContainer.style.backgroundColor = '';
        }, 500);
      } else {
        console.log('⚠️ Staff list container is empty after update');
      }
      
      
    }
    // Function to edit staff member role
    window.editStaffRole = async function(staffName, staffMember) {
      console.log('✏️ editStaffRole called for:', staffName, staffMember);
      
      if (!staffMember) {
        console.error('❌ Staff member data not found for:', staffName);
        alert('Staff member data not found. Please refresh the page and try again.');
        return;
      }
      
      const currentRole = staffMember.role;
      
      // Create a custom role selection dialog
      const roleDialog = document.createElement('div');
      roleDialog.className = 'role-edit-dialog';
      roleDialog.innerHTML = `
        <div class="role-edit-content">
          <div class="role-edit-header">
            <h3>Edit ${staffName}'s Role</h3>
            <button class="close-role-dialog" onclick="this.closest('.role-edit-dialog').remove()">×</button>
          </div>
          <div class="role-edit-body">
            <div class="current-role-display">
              <label>Current Role:</label>
              <span class="current-role-badge ${currentRole.replace(' ', '-')}">${currentRole}</span>
            </div>
            <div class="new-role-selection">
              <label for="new-role-select">New Role:</label>
              <select id="new-role-select" class="new-role-dropdown">
                <option value="team leader" ${currentRole === 'team leader' ? 'selected' : ''}>Team Leader</option>
                <option value="staff member" ${currentRole === 'staff member' ? 'selected' : ''}>Staff Member</option>
              </select>
            </div>
            <div class="change-details-section">
              <div class="change-detail-row">
                <label for="role-changed-by">Changed By:</label>
                <input type="text" id="role-changed-by" class="changed-by-input" 
                       value="system" placeholder="Enter who made the change">
              </div>
              <div class="change-detail-row">
                <label for="role-reason">Reason:</label>
                <input type="text" id="role-reason" class="reason-input" 
                       value="" placeholder="Enter reason for change">
              </div>
              <div class="change-detail-row">
                <label for="role-effective-date">Effective From Date & Time:</label>
                <input type="datetime-local" id="role-effective-date" class="effective-date-input" 
                       value="${new Date().toISOString().slice(0, 16)}">
              </div>
            </div>
          </div>
          <div class="role-edit-actions">
            <button class="cancel-role-btn" onclick="this.closest('.role-edit-dialog').remove()">Cancel</button>
            <button class="save-role-btn" onclick="saveStaffRole('${staffName}', '${staffMember.unique_id}', this)">Save Changes</button>
          </div>

        </div>
      `;
      
      console.log('🔍 Role dialog created with:', {
        staffName,
        staffId: staffMember.unique_id,
        currentRole,
        dialogHTML: roleDialog.innerHTML
      });
      
      // Add the dialog to the page
      document.body.appendChild(roleDialog);
      
      // Focus on the dropdown
      setTimeout(() => {
        const dropdown = roleDialog.querySelector('#new-role-select');
        if (dropdown) dropdown.focus();
      }, 100);
    }

    // Function to edit staff member pay rate
    window.editStaffPayRate = async function(staffName, staffMember) {
      console.log('💰 editStaffPayRate called for:', staffName, staffMember);
      
      if (!staffMember) {
        console.error('❌ Staff member data not found for:', staffName);
        alert('Staff member data not found. Please refresh the page and try again.');
        return;
      }
      
      const currentPayRate = staffMember.pay_rate || 0;
      
      // Create a custom pay rate edit dialog
      const payRateDialog = document.createElement('div');
      payRateDialog.className = 'pay-rate-edit-dialog';
      payRateDialog.innerHTML = `
        <div class="pay-rate-edit-content">
          <div class="pay-rate-edit-header">
            <h3>Edit ${staffName}'s Pay Rate</h3>
            <button class="close-pay-rate-dialog" onclick="this.closest('.pay-rate-edit-dialog').remove()">×</button>
          </div>
          <div class="pay-rate-edit-body">
            <div class="current-pay-rate-display">
              <label>Current Pay Rate:</label>
              <span class="current-pay-rate-value">£${currentPayRate}/hour</span>
            </div>
            <div class="new-pay-rate-input">
              <label for="new-pay-rate-input">New Pay Rate (£/hour):</label>
              <input type="number" id="new-pay-rate-input" class="new-pay-rate-field" 
                     value="${currentPayRate}" step="0.01" min="0" max="100">
            </div>
            <div class="change-details-section">
              <div class="change-detail-row">
                <label for="pay-rate-changed-by">Changed By:</label>
                <input type="text" id="pay-rate-changed-by" class="changed-by-input" 
                       value="system" placeholder="Enter who made the change">
              </div>
              <div class="change-detail-row">
                <label for="pay-rate-reason">Reason:</label>
                <input type="text" id="pay-rate-reason" class="reason-input" 
                       value="" placeholder="Enter reason for change">
              </div>
              <div class="change-detail-row">
                <label for="pay-rate-effective-date">Effective From Date & Time:</label>
                <input type="datetime-local" id="pay-rate-effective-date" class="effective-date-input" 
                       value="${new Date().toISOString().slice(0, 16)}">
              </div>
            </div>
          </div>
          <div class="pay-rate-edit-actions">
            <button class="cancel-pay-rate-btn" onclick="this.closest('.pay-rate-edit-dialog').remove()">Cancel</button>
            <button class="save-pay-rate-btn" onclick="saveStaffPayRate('${staffName}', '${staffMember.unique_id}', this)">Save Changes</button>
          </div>
        </div>
      `;
      
      // Add the dialog to the page
      document.body.appendChild(payRateDialog);
      
      // Focus on the input
      setTimeout(() => {
        const input = payRateDialog.querySelector('#new-pay-rate-input');
        if (input) input.focus();
      }, 100);
    }

    // Function to edit staff member contracted hours
    window.editStaffContractedHours = async function(staffName, staffMember) {
      console.log('⏰ editStaffContractedHours called for:', staffName, staffMember);
      
      if (!staffMember) {
        console.error('❌ Staff member data not found for:', staffName);
        alert('Staff member data not found. Please refresh the page and try again.');
        return;
      }
      
      const currentContractedHours = staffMember.contracted_hours || 0;
      
      // Create a custom contracted hours edit dialog
      const contractedHoursDialog = document.createElement('div');
      contractedHoursDialog.className = 'contracted-hours-edit-dialog';
      contractedHoursDialog.innerHTML = `
        <div class="contracted-hours-edit-content">
          <div class="contracted-hours-edit-header">
            <h3>Edit ${staffName}'s Contracted Hours</h3>
            <button class="close-contracted-hours-dialog" onclick="this.closest('.contracted-hours-edit-dialog').remove()">×</button>
          </div>
          <div class="contracted-hours-edit-body">
            <div class="current-contracted-hours-display">
              <label>Current Contracted Hours:</label>
              <span class="current-contracted-hours-value">${currentContractedHours} hours</span>
            </div>
            <div class="new-contracted-hours-input">
              <label for="new-contracted-hours-input">New Contracted Hours:</label>
              <input type="number" id="new-contracted-hours-input" class="new-contracted-hours-field" 
                     value="${currentContractedHours}" step="0.5" min="0" max="168">
            </div>
            <div class="change-details-section">
              <div class="change-detail-row">
                <label for="contracted-hours-changed-by">Changed By:</label>
                <input type="text" id="contracted-hours-changed-by" class="changed-by-input" 
                       value="system" placeholder="Enter who made the change">
              </div>
              <div class="change-detail-row">
                <label for="contracted-hours-reason">Reason:</label>
                <input type="text" id="contracted-hours-reason" class="reason-input" 
                       value="" placeholder="Enter reason for change">
              </div>
              <div class="change-detail-row">
                <label for="contracted-hours-effective-date">Effective From Date & Time:</label>
                <input type="datetime-local" id="contracted-hours-effective-date" class="effective-date-input" 
                       value="${new Date().toISOString().slice(0, 16)}">
              </div>
            </div>
          </div>
          <div class="contracted-hours-edit-actions">
            <button class="cancel-contracted-hours-btn" onclick="this.closest('.contracted-hours-edit-dialog').remove()">Cancel</button>
            <button class="save-contracted-hours-btn" onclick="saveStaffContractedHours('${staffName}', '${staffMember.unique_id}', this)">Save Changes</button>
          </div>
        </div>
      `;
      
      // Add the dialog to the page
      document.body.appendChild(contractedHoursDialog);
      
      // Focus on the input
      setTimeout(() => {
        const input = contractedHoursDialog.querySelector('#new-contracted-hours-input');
        if (input) input.focus();
      }, 100);
    }

    // Function to edit staff member employment start date
    window.editStaffEmploymentDate = async function(staffName, staffMember) {
      console.log('📅 editStaffEmploymentDate called for:', staffName, staffMember);
      
      if (!staffMember) {
        console.error('❌ Staff member data not found for:', staffName);
        alert('Staff member data not found. Please refresh the page and try again.');
        return;
      }
      
      const currentDate = staffMember.employment_start_date || '';
      
      // Create a custom employment date editing dialog
      const dateDialog = document.createElement('div');
      dateDialog.className = 'date-edit-dialog';
      dateDialog.innerHTML = `
        <div class="date-edit-content">
          <div class="date-edit-header">
            <h3>Edit ${staffName}'s Employment Start Date</h3>
            <button class="close-date-dialog" onclick="this.closest('.date-edit-dialog').remove()">×</button>
          </div>
          <div class="date-edit-body">
            <div class="current-date-display">
              <label>Current Employment Start Date:</label>
              <span class="current-date-value">${currentDate ? new Date(currentDate).toLocaleDateString('en-GB') : 'Not set'}</span>
            </div>
            <div class="new-date-input">
              <label for="new-employment-date-input">New Employment Start Date:</label>
              <input type="date" id="new-employment-date-input" class="new-date-field" 
                     value="${currentDate}" required>
            </div>
            <div class="change-details-section">
              <div class="change-detail-row">
                <label for="date-changed-by">Changed By:</label>
                <input type="text" id="date-changed-by" class="changed-by-input" 
                       value="system" placeholder="Enter who made the change">
              </div>
              <div class="change-detail-row">
                <label for="date-reason">Reason:</label>
                <input type="text" id="date-reason" class="reason-input" 
                       value="" placeholder="Enter reason for change">
              </div>
              <div class="change-detail-row">
                <label for="date-effective-date">Effective From Date & Time:</label>
                <input type="datetime-local" id="date-effective-date" class="effective-date-input" 
                       value="${new Date().toISOString().slice(0, 16)}">
              </div>
            </div>
          </div>
          <div class="date-edit-actions">
            <button class="cancel-date-btn" onclick="this.closest('.date-edit-dialog').remove()">Cancel</button>
            <button class="save-date-btn" onclick="saveStaffEmploymentDate('${staffName}', '${staffMember.unique_id}', this)">Save Changes</button>
          </div>
        </div>
      `;
      
      // Add the dialog to the page
      document.body.appendChild(dateDialog);
      
      // Focus on the input
      setTimeout(() => {
        const input = dateDialog.querySelector('#new-employment-date-input');
        if (input) input.focus();
      }, 100);
    }

    // Function to edit staff member employment end date
    window.editStaffEmploymentEndDate = async function(staffName, staffMember) {
      console.log('📅 editStaffEmploymentEndDate called for:', staffName, staffMember);
      
      if (!staffMember) {
        console.error('❌ Staff member data not found for:', staffName);
        alert('Staff member data not found. Please refresh the page and try again.');
        return;
      }
      
      const currentEndDate = staffMember.employment_end_date || '';
      
      // Create a custom employment end date editing dialog
      const endDateDialog = document.createElement('div');
      endDateDialog.className = 'end-date-edit-dialog';
      endDateDialog.innerHTML = `
        <div class="end-date-edit-content">
          <div class="end-date-edit-header">
            <h3>Edit ${staffName}'s Employment End Date</h3>
            <button class="close-end-date-dialog" onclick="this.closest('.end-date-edit-dialog').remove()">×</button>
          </div>
          <div class="end-date-edit-body">
            <div class="current-end-date-display">
              <label>Current Employment End Date:</label>
              <span class="current-end-date-value">${currentEndDate ? new Date(currentEndDate).toLocaleDateString('en-GB') : 'Still employed (no end date set)'}</span>
            </div>
            <div class="new-end-date-input">
              <label for="new-employment-end-date-input">New Employment End Date:</label>
              <input type="date" id="new-employment-end-date-input" class="new-end-date-field" 
                     value="${currentEndDate}">
              <div class="end-date-help">
                <small>Leave empty to clear the end date (mark as still employed)</small>
              </div>
            </div>
            <div class="change-details-section">
              <div class="change-detail-row">
                <label for="end-date-changed-by">Changed By:</label>
                <input type="text" id="end-date-changed-by" class="changed-by-input" 
                       value="system" placeholder="Enter who made the change">
              </div>
              <div class="change-detail-row">
                <label for="end-date-reason">Reason:</label>
                <input type="text" id="end-date-reason" class="reason-input" 
                       value="" placeholder="Enter reason for change">
              </div>
              <div class="change-detail-row">
                <label for="end-date-effective-date">Effective From Date & Time:</label>
                <input type="datetime-local" id="end-date-effective-date" class="effective-date-input" 
                       value="${new Date().toISOString().slice(0, 16)}">
              </div>
            </div>
          </div>
          <div class="end-date-edit-actions">
            <button class="cancel-end-date-btn" onclick="this.closest('.end-date-edit-dialog').remove()">Cancel</button>
            <button class="save-end-date-btn" onclick="saveStaffEmploymentEndDate('${staffName}', '${staffMember.unique_id}', this)">Save Changes</button>
          </div>
        </div>
      `;
      
      // Add the dialog to the page
      document.body.appendChild(endDateDialog);
      
      // Focus on the input
      setTimeout(() => {
        const input = endDateDialog.querySelector('#new-employment-end-date-input');
        if (input) input.focus();
      }, 100);
    }
    
    // Function to edit staff color
    window.editStaffColor = async function(staffName, staffMember) {
      console.log('🎨 editStaffColor called for:', staffName, staffMember);
      
      const currentColor = staffMember && staffMember.color_code ? staffMember.color_code : '#3b82f6';
      
      // Create color edit dialog
      const colorDialog = document.createElement('div');
      colorDialog.className = 'status-change-dialog';
      colorDialog.innerHTML = `
        <div class="status-change-content">
          <div class="status-change-header">
            <h3>Change Color for ${staffName}</h3>
            <button class="close-status-dialog" onclick="this.closest('.status-change-dialog').remove()">×</button>
          </div>
          <div class="status-change-body">
            <div style="margin-bottom: 20px;">
              <label>Current Color: <span style="color: ${currentColor}; font-weight: bold;">${currentColor}</span></label>
            </div>
            <div style="margin-bottom: 20px;">
              <label for="new-color">New Color (hex code):</label>
              <input type="color" id="new-color" value="${currentColor}" style="margin-left: 10px; width: 50px; height: 30px;">
              <input type="text" id="new-color-text" value="${currentColor}" style="margin-left: 10px; width: 100px; padding: 5px;" placeholder="#ef4444">
            </div>
            <div style="margin-bottom: 20px;">
              <label>Quick Colors:</label>
              <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button onclick="setQuickColor('#ef4444')" style="width: 30px; height: 30px; background: #ef4444; border: none; border-radius: 4px; cursor: pointer;" title="Red"></button>
                <button onclick="setQuickColor('#fbbf24')" style="width: 30px; height: 30px; background: #fbbf24; border: none; border-radius: 4px; cursor: pointer;" title="Yellow"></button>
                <button onclick="setQuickColor('#10b981')" style="width: 30px; height: 30px; background: #10b981; border: none; border-radius: 4px; cursor: pointer;" title="Green"></button>
                <button onclick="setQuickColor('#3b82f6')" style="width: 30px; height: 30px; background: #3b82f6; border: none; border-radius: 4px; cursor: pointer;" title="Blue"></button>
                <button onclick="setQuickColor('#8b5cf6')" style="width: 30px; height: 30px; background: #8b5cf6; border: none; border-radius: 4px; cursor: pointer;" title="Purple"></button>
                <button onclick="setQuickColor('#ec4899')" style="width: 30px; height: 30px; background: #ec4899; border: none; border-radius: 4px; cursor: pointer;" title="Pink"></button>
              </div>
            </div>
            <div style="margin-bottom: 20px;">
              <div class="change-detail-row">
                <label for="color-changed-by">Changed By:</label>
                <input type="text" id="color-changed-by" class="changed-by-input" 
                       value="system" placeholder="Enter who made the change">
              </div>
            </div>
            <div style="margin-bottom: 20px;">
              <div class="change-detail-row">
                <label for="color-reason">Reason:</label>
                <input type="text" id="color-reason" class="reason-input" 
                       value="" placeholder="Enter reason for change">
              </div>
            </div>
            <div style="margin-bottom: 20px;">
              <div class="change-detail-row">
                <label for="color-effective-date">Effective From Date & Time:</label>
                <input type="datetime-local" id="color-effective-date" class="effective-date-input" 
                       value="${new Date().toISOString().slice(0, 16)}">
              </div>
            </div>
          </div>
          <div class="status-change-actions">
            <button class="cancel-status-btn" onclick="this.closest('.status-change-dialog').remove()">Cancel</button>
            <button class="confirm-status-btn" onclick="saveStaffColor('${staffMember.unique_id}', '${staffName}')">Save Color</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(colorDialog);
      
      // Sync color picker and text input
      const colorPicker = colorDialog.querySelector('#new-color');
      const colorText = colorDialog.querySelector('#new-color-text');
      
      colorPicker.addEventListener('input', (e) => {
        colorText.value = e.target.value;
      });
      
      colorText.addEventListener('input', (e) => {
        if (/^#[0-9A-F]{6}$/i.test(e.target.value)) {
          colorPicker.value = e.target.value;
        }
      });
      
      // Add quick color function to window
      window.setQuickColor = function(color) {
        colorPicker.value = color;
        colorText.value = color;
      };
      
      // Add save function to window
      window.saveStaffColor = async function(staffId, staffName) {
        // Prevent duplicate calls
        const saveButton = colorDialog.querySelector('.confirm-status-btn');
        if (saveButton.disabled) {
          console.log('🔄 Save button already clicked, ignoring duplicate call');
          return;
        }
        saveButton.disabled = true;
        saveButton.textContent = 'Saving...';
        
        const newColor = colorDialog.querySelector('#new-color-text').value;
        const changedBy = colorDialog.querySelector('#color-changed-by').value || 'system';
        const reason = colorDialog.querySelector('#color-reason').value || '';
        const effectiveFromDate = colorDialog.querySelector('#color-effective-date').value || new Date().toISOString().slice(0, 16);
        
        if (!/^#[0-9A-F]{6}$/i.test(newColor)) {
          alert('Please enter a valid hex color code (e.g., #ef4444)');
          saveButton.disabled = false;
          saveButton.textContent = 'Save Color';
          return;
        }
        
        // Check if the color is actually changing (compare with the original color from staff member data)
        const originalColor = staffMember.color_code || '#3b82f6';
        if (newColor === originalColor) {
          alert('The color is already set to this value. No change needed.');
          saveButton.disabled = false;
          saveButton.textContent = 'Save Color';
          return;
        }
        
        try {
          console.log('🎨 Saving new color for', staffName, ':', newColor, 'changed by:', changedBy, 'reason:', reason);
          const result = await apiService.updateStaffColorCode(staffId, newColor, changedBy, reason, effectiveFromDate);
          
          if (result.success) {
            console.log('✅ Color updated successfully:', result);
            
            // Update local data
            staffColors[staffName] = newColor;
            
            // Refresh data from server to get the latest information
            await forceRefreshStaffList();
            
            // Refresh change request dialog if it's open
            await refreshChangeRequestDialog(staffId);
            
            // Close dialog
            colorDialog.remove();
          } else {
            alert('❌ Failed to update color: ' + result.message);
            saveButton.disabled = false;
            saveButton.textContent = 'Save Color';
          }
        } catch (error) {
          console.error('❌ Error updating color:', error);
          alert('❌ Error updating color: ' + error.message);
          saveButton.disabled = false;
          saveButton.textContent = 'Save Color';
        }
      };
    }
    

    
    // Function to load and display role history
    async function loadRoleHistory(staffId) {
      try {
        console.log('📚 Loading role history for staff ID:', staffId);
        
        const result = await apiService.getRoleHistory(staffId);
        
        if (result.success) {
          displayRoleHistory(staffId, result.data);
        } else {
          console.error('❌ Failed to load role history:', result);
          displayRoleHistoryError(staffId, 'Failed to load role history');
        }
      } catch (error) {
        console.error('❌ Error loading role history:', error);
        displayRoleHistoryError(staffId, 'Error loading role history');
      }
    }
    
    // Function to display role history
    function displayRoleHistory(staffId, historyData) {
      const historyContainer = document.getElementById(`role-history-content-${staffId}`);
      if (!historyContainer) return;
      
      if (historyData.length === 0) {
        historyContainer.innerHTML = '<div class="no-role-history">No role changes recorded yet.</div>';
        return;
      }
      
      const historyHTML = historyData.map(record => {
        const changeDate = new Date(record.changed_at).toLocaleDateString('en-GB', {
          day: 'numeric',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        return `
          <div class="role-history-item">
            <div class="role-change-info">
              <span class="role-change-arrow">${record.previous_role} → ${record.new_role}</span>
              <span class="role-change-date">${changeDate}</span>
            </div>
            ${record.reason ? `<div class="role-change-reason">${record.reason}</div>` : ''}
          </div>
        `;
      }).join('');
      
      historyContainer.innerHTML = historyHTML;
    }
    
    // Function to display role history error
    function displayRoleHistoryError(staffId, errorMessage) {
      const historyContainer = document.getElementById(`role-history-content-${staffId}`);
      if (historyContainer) {
        historyContainer.innerHTML = `<div class="role-history-error">${errorMessage}</div>`;
      }
    }



    // Function to load and display combined history (roles, colors, and other changes)
    async function loadCombinedHistory(staffId) {
      try {
        console.log('📋 Loading combined history for staff ID:', staffId);
        
        // Fetch all changes history (includes roles, colors, and other changes)
        const changesResult = await apiService.getChangesHistory(staffId);
        
        if (changesResult.success) {
          console.log('✅ Changes result:', changesResult.data.length, 'records');
          console.log('📋 Raw data:', JSON.stringify(changesResult.data, null, 2));
          // Sort by changed_at date (most recent first)
          const sortedHistory = changesResult.data.sort((a, b) => new Date(b.changed_at) - new Date(a.changed_at));
          console.log('📊 Sorted history:', sortedHistory.length, 'records');
          displayCombinedHistory(staffId, sortedHistory);
        } else {
          console.error('❌ Failed to load changes history:', changesResult);
          displayCombinedHistory(staffId, []);
        }
      } catch (error) {
        console.error('❌ Error loading combined history:', error);
        displayCombinedHistoryError(staffId, 'Error loading combined history');
      }
    }
    
    // Function to load and display changes history
    async function loadChangesHistory(staffId) {
      try {
        console.log('📋 Loading changes history for staff ID:', staffId);
        
        const result = await apiService.getChangesHistory(staffId);
        
        if (result.success) {
          displayChangesHistory(staffId, result.data);
        } else {
          console.error('❌ Failed to load changes history:', result);
          displayChangesHistoryError(staffId, 'Failed to load changes history');
        }
      } catch (error) {
        console.error('❌ Error loading changes history:', error);
        displayChangesHistoryError(staffId, 'Error loading changes history');
      }
    }
    


    // Function to display changes history
    function displayChangesHistory(staffId, historyData) {
      const historyContainer = document.getElementById(`changes-history-content-${staffId}`);
      if (!historyContainer) return;
      
      if (historyData.length === 0) {
        historyContainer.innerHTML = '<div class="no-changes-history">No changes recorded yet.</div>';
        return;
      }
      
      // Create table structure
      const tableHTML = `
        <div class="history-table-container">
          <table class="history-table">
            <thead>
              <tr>
                <th>Change Type</th>
                <th>Old Value</th>
                <th>New Value</th>
                <th>Changed By</th>
                <th>Reason</th>
                <th>Effective Date</th>
                <th>Changed Date</th>
              </tr>
            </thead>
            <tbody>
              ${historyData.map((record, index) => {
                const changeDate = new Date(record.changed_at).toLocaleDateString('en-GB', {
                  day: 'numeric',
                  month: 'short',
                  year: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                });
                
                const effectiveDate = new Date(record.effective_from_date).toLocaleDateString('en-GB', {
                  day: 'numeric',
                  month: 'short',
                  year: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                });
                
                const changeTypeLabel = record.change_type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
                
                return `
                  <tr class="history-table-row" data-history-id="${record.id}">
                    <td class="change-type-cell">
                      <span class="change-type-label">${changeTypeLabel}</span>
                    </td>
                    <td class="old-value-cell">${record.old_value}</td>
                    <td class="new-value-cell">${record.new_value}</td>
                    <td class="changed-by-cell">${record.changed_by || 'system'}</td>
                    <td class="reason-cell">${record.reason || 'N/A'}</td>
                    <td class="effective-date-cell">${effectiveDate}</td>
                    <td class="changed-date-cell">${changeDate}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
      `;
      
      historyContainer.innerHTML = tableHTML;
    }
    
    // Function to display combined history (roles, colors, and other changes)
    function displayCombinedHistory(staffId, historyData) {
      console.log('🎯 displayCombinedHistory called with:', staffId, historyData.length, 'records');
      const historyContainer = document.getElementById(`changes-history-content-${staffId}`);
      if (!historyContainer) {
        console.log('❌ History container not found for staffId:', staffId);
        return;
      }
      
      // Check if we're already displaying the same data to prevent duplicates
      const currentContent = historyContainer.innerHTML;
      if (currentContent.includes('history-table') && historyData.length > 0) {
        console.log('⚠️ History already displayed, skipping duplicate call');
        return;
      }
      
      // Clear the container first to ensure clean display
      historyContainer.innerHTML = '';
      
      if (historyData.length === 0) {
        historyContainer.innerHTML = '<div class="no-changes-history">No changes recorded yet.</div>';
        return;
      }
      
      // Remove duplicates based on record ID to prevent display duplicates
      const uniqueHistoryData = historyData.filter((record, index, self) => 
        index === self.findIndex(r => r.id === record.id)
      );
      
      if (uniqueHistoryData.length !== historyData.length) {
        console.log('⚠️ Removed duplicate records:', historyData.length - uniqueHistoryData.length);
      }
      
      console.log('📊 Displaying', uniqueHistoryData.length, 'unique records');
      console.log('🎯 Unique data:', JSON.stringify(uniqueHistoryData, null, 2));
      
      // Create table structure
      const tableHTML = `
        <div class="history-table-container">
          <table class="history-table">
            <thead>
              <tr>
                <th>Change Type</th>
                <th>Old Value</th>
                <th>New Value</th>
                <th>Changed By</th>
                <th>Reason</th>
                <th>Effective Date</th>
                <th>Changed Date</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              ${uniqueHistoryData.map((record, index) => {
                const changeDate = new Date(record.changed_at).toLocaleDateString('en-GB', {
                  day: 'numeric',
                  month: 'short',
                  year: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                });
                
                const effectiveDate = new Date(record.effective_from_date).toLocaleDateString('en-GB', {
                  day: 'numeric',
                  month: 'short',
                  year: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
                });
                
                const changeTypeLabel = record.change_type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
                
                // Special handling for color changes
                let oldValueDisplay = record.old_value;
                let newValueDisplay = record.new_value;
                
                if (record.change_type === 'color_code_change') {
                  oldValueDisplay = `
                    <div style="display: flex; align-items: center; gap: 8px;">
                      <div style="width: 20px; height: 20px; background-color: ${record.old_value}; border-radius: 50%; border: 1px solid #ddd;"></div>
                      <span>${record.old_value}</span>
                    </div>
                  `;
                  newValueDisplay = `
                    <div style="display: flex; align-items: center; gap: 8px;">
                      <div style="width: 20px; height: 20px; background-color: ${record.new_value}; border-radius: 50%; border: 1px solid #ddd;"></div>
                      <span>${record.new_value}</span>
                    </div>
                  `;
                }
                
                return `
                  <tr class="history-table-row" data-history-id="${record.id}">
                    <td class="change-type-cell">
                      <span class="change-type-label">${changeTypeLabel}</span>
                    </td>
                    <td class="old-value-cell">${oldValueDisplay}</td>
                    <td class="new-value-cell">${newValueDisplay}</td>
                    <td class="changed-by-cell">${record.changed_by || 'system'}</td>
                    <td class="reason-cell">${record.reason || 'N/A'}</td>
                    <td class="effective-date-cell">${effectiveDate}</td>
                    <td class="changed-date-cell">${changeDate}</td>
                    <td class="actions-cell">
                      <button class="delete-change-btn" onclick="deleteChangeRequest('${staffId}', '${record.id}')" title="Delete this change request">
                        🗑️
                      </button>
                    </td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
      `;
      
      historyContainer.innerHTML = tableHTML;
    }



    // Function to display changes history error
    function displayChangesHistoryError(staffId, errorMessage) {
      const historyContainer = document.getElementById(`changes-history-content-${staffId}`);
      if (historyContainer) {
        historyContainer.innerHTML = `<div class="changes-history-error">${errorMessage}</div>`;
      }
    }
    
    // Function to display combined history error
    function displayCombinedHistoryError(staffId, errorMessage) {
      const historyContainer = document.getElementById(`changes-history-content-${staffId}`);
      if (historyContainer) {
        historyContainer.innerHTML = `<div class="changes-history-error">${errorMessage}</div>`;
      }
    }
    // Function to update history field
    async function updateHistoryField(historyId, field, value) {
      try {
        console.log('🔄 Updating history field:', { historyId, field, value });
        
        const result = await apiService.updateHistoryField(historyId, field, value);
        
        if (result.success) {
          console.log('✅ History field updated successfully');
          
          // Show success message
          const successMsg = document.createElement('div');
          successMsg.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
          `;
          successMsg.textContent = `✅ History ${field} updated successfully!`;
          document.body.appendChild(successMsg);
          
          setTimeout(() => {
            successMsg.style.animation = 'slideOutRight 0.3s ease-out';
            setTimeout(() => successMsg.remove(), 300);
          }, 3000);
        } else {
          throw new Error(result.message || 'Failed to update history field');
        }
      } catch (error) {
        console.error('❌ Error updating history field:', error);
        
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc3545;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        errorMsg.textContent = `❌ Failed to update history ${field}: ${error.message}`;
        document.body.appendChild(errorMsg);
        
        setTimeout(() => {
          errorMsg.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => errorMsg.remove(), 300);
        }, 5000);
      }
    }

    // Function to save history change
    window.saveHistoryChange = async function(historyId, changeType) {
      try {
        console.log('💾 Saving history change:', { historyId, changeType });
        
        const historyItem = document.querySelector(`[data-history-id="${historyId}"]`);
        if (!historyItem) {
          console.error('❌ History item not found');
          return;
        }
        
        const changedByInput = historyItem.querySelector('.changed-by-input');
        const reasonInput = historyItem.querySelector('.reason-input');
        
        const changedBy = changedByInput.value;
        const reason = reasonInput.value;
        
        // Update both fields
        await updateHistoryField(historyId, 'changed_by', changedBy);
        await updateHistoryField(historyId, 'reason', reason);
        
        console.log('✅ History change saved successfully');
        
      } catch (error) {
        console.error('❌ Error saving history change:', error);
      }
    }
    
    // Function to confirm status change
    window.confirmStatusChange = async function(staffId, newStatus, buttonElement) {
      console.log('🔄 confirmStatusChange called with:', { staffId, newStatus, buttonElement });
      
      const statusDialog = buttonElement.closest('.status-change-dialog');
      const changedByInput = statusDialog.querySelector('#status-changed-by');
      const reasonInput = statusDialog.querySelector('#status-reason');
      const effectiveDateInput = statusDialog.querySelector('#status-effective-date');
      const changedBy = changedByInput ? changedByInput.value : 'system';
      const reason = reasonInput ? reasonInput.value : '';
      const effectiveFromDate = effectiveDateInput ? effectiveDateInput.value : new Date().toISOString().slice(0, 16);
      
      try {
        const result = await apiService.toggleStaffActiveStatus(staffId, changedBy, reason, effectiveFromDate);
        if (result.success) {
          // Refresh data from server to get the latest information
          await forceRefreshStaffList();
          
          // Update tab visibility based on new staff status
          const hasActiveStaff = window.globalStaffMembers.some(staff => staff.is_active !== false);
          updateTabVisibilityBasedOnStaff(hasActiveStaff);
          
          // Refresh change request dialog if it's open
          await refreshChangeRequestDialog(staffId);
          
          // Show success message
          const successMsg = document.createElement('div');
          successMsg.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
          `;
          successMsg.textContent = `✅ Staff member ${newStatus ? 'activated' : 'deactivated'} successfully!`;
          document.body.appendChild(successMsg);
          
          setTimeout(() => {
            successMsg.style.animation = 'slideOutRight 0.3s ease-out';
            setTimeout(() => successMsg.remove(), 300);
          }, 3000);
          
          statusDialog.remove();
        }
      } catch (error) {
        console.error('❌ Error confirming status change:', error);
        
        // Show error message
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc3545;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        errorMsg.textContent = `❌ Failed to update status: ${error.message}`;
        document.body.appendChild(errorMsg);
        
        setTimeout(() => {
          errorMsg.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => errorMsg.remove(), 300);
        }, 5000);
      }
    };

    // Function to save the selected role
    window.saveStaffRole = async function(staffName, staffId, buttonElement) {
      console.log('💾 saveStaffRole called with:', { staffName, staffId, buttonElement });
      
      const roleDialog = buttonElement.closest('.role-edit-dialog');
      console.log('🔍 Found role dialog:', roleDialog);
      
      const newRoleSelect = roleDialog.querySelector('#new-role-select');
      console.log('🔍 Found role select:', newRoleSelect);
      
      const newRole = newRoleSelect.value;
      console.log('🔍 Selected new role:', newRole);
      
      // Get the new text box values
      const changedByInput = roleDialog.querySelector('#role-changed-by');
      const reasonInput = roleDialog.querySelector('#role-reason');
      const effectiveDateInput = roleDialog.querySelector('#role-effective-date');
      const changedBy = changedByInput ? changedByInput.value : 'system';
      const reason = reasonInput ? reasonInput.value : '';
      const effectiveFromDate = effectiveDateInput ? effectiveDateInput.value : new Date().toISOString().slice(0, 16);
      
      // Find the staff member data
              const staffMember = window.globalStaffMembers.find(staff => staff.unique_id === staffId);
      console.log('🔍 Found staff member:', staffMember);
      
      if (!staffMember) {
        alert('Staff member data not found. Please refresh the page and try again.');
        return;
      }
      
      const currentRole = staffMember.role;
      console.log('🔍 Current role:', currentRole);
      
      if (newRole === currentRole) {
        console.log('ℹ️ No change needed - role is already set to:', newRole);
        
        // Show info message instead of alert
        const infoMsg = document.createElement('div');
        infoMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #17a2b8;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        infoMsg.textContent = `ℹ️ ${staffName} already has the role: ${newRole}`;
        document.body.appendChild(infoMsg);
        
        setTimeout(() => {
          infoMsg.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => infoMsg.remove(), 300);
        }, 3000);
        
        roleDialog.remove();
        return;
      }
      
      try {
        console.log('🔄 Updating role for:', staffName, 'from', currentRole, 'to', newRole);
        console.log('🔍 Calling API with staffId:', staffId, 'and newRole:', newRole);
        
        const result = await apiService.updateStaffRole(staffId, newRole, changedBy, reason, effectiveFromDate);
        console.log('🔍 API response:', result);
        
        if (result.success) {
          console.log('✅ Role updated successfully:', result);
          
          // Update the global staff members array
                  const staffIndex = window.globalStaffMembers.findIndex(staff => staff.unique_id === staffId);
          if (staffIndex !== -1) {
          window.globalStaffMembers[staffIndex].role = newRole;
            console.log('📋 Updated global staff members:', globalStaffMembers);
          }
          
          // Refresh data from server to get the latest information
          await forceRefreshStaffList();
          
          // Refresh holiday entitlements for consistency (role changes don't directly affect entitlements)
          console.log('🏖️ Role changed, refreshing holiday entitlements...');
          await loadHolidayEntitlements();
          
          // Refresh employee summaries to show updated roles
          await displayEmployeeSummaries();
          
          // Refresh change request dialog if it's open
          await refreshChangeRequestDialog(staffId);
          
          // Show success message
          const successMsg = document.createElement('div');
          successMsg.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
          `;
          successMsg.textContent = `✅ ${staffName}'s role updated to ${newRole}!`;
          document.body.appendChild(successMsg);
          
          setTimeout(() => {
            successMsg.style.animation = 'slideOutRight 0.3s ease-out';
            setTimeout(() => successMsg.remove(), 300);
          }, 3000);
          
          // Close the dialog
          roleDialog.remove();
          

          
        } else {
          console.error('❌ Role update failed:', result);
          alert(`Failed to update role: ${result.message || 'Unknown error'}`);
        }
        
      } catch (error) {
        console.error('❌ Error updating role:', error);
        console.error('❌ Error details:', {
          message: error.message,
          stack: error.stack,
          staffName,
          staffId,
          newRole
        });
        
        // Show detailed error message
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc3545;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        errorMsg.textContent = `❌ Failed to update role: ${error.message}`;
        document.body.appendChild(errorMsg);
        
        setTimeout(() => {
          errorMsg.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => errorMsg.remove(), 300);
        }, 5000);
      }
    }

    // Function to save the selected pay rate
    window.saveStaffPayRate = async function(staffName, staffId, buttonElement) {
      console.log('💰 saveStaffPayRate called with:', { staffName, staffId, buttonElement });
      
      const payRateDialog = buttonElement.closest('.pay-rate-edit-dialog');
      const newPayRateInput = payRateDialog.querySelector('#new-pay-rate-input');
      const newPayRate = parseFloat(newPayRateInput.value);
      
      // Get the new text box values
      const changedByInput = payRateDialog.querySelector('#pay-rate-changed-by');
      const reasonInput = payRateDialog.querySelector('#pay-rate-reason');
      const effectiveDateInput = payRateDialog.querySelector('#pay-rate-effective-date');
      const changedBy = changedByInput ? changedByInput.value : 'system';
      const reason = reasonInput ? reasonInput.value : '';
      const effectiveFromDate = effectiveDateInput ? effectiveDateInput.value : new Date().toISOString().slice(0, 16);
      
      if (isNaN(newPayRate) || newPayRate < 0) {
        alert('Please enter a valid pay rate (positive number).');
        return;
      }
      
      // Find the staff member data
      const staffMember = window.globalStaffMembers.find(staff => staff.unique_id === staffId);
      
      if (!staffMember) {
        alert('Staff member data not found. Please refresh the page and try again.');
        return;
      }
      
      const currentPayRate = staffMember.pay_rate || 0;
      
      if (newPayRate === currentPayRate) {
        console.log('ℹ️ No change needed - pay rate is already set to:', newPayRate);
        
        const infoMsg = document.createElement('div');
        infoMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #17a2b8;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        infoMsg.textContent = `ℹ️ ${staffName} already has the pay rate: £${newPayRate}/hour`;
        document.body.appendChild(infoMsg);
        
        setTimeout(() => {
          infoMsg.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => infoMsg.remove(), 300);
        }, 3000);
        
        payRateDialog.remove();
        return;
      }
      
      try {
        console.log('🔄 Updating pay rate for:', staffName, 'from', currentPayRate, 'to', newPayRate);
        
        const result = await apiService.updateStaffPayRate(staffId, newPayRate, changedBy, reason, effectiveFromDate);
        console.log('🔍 API response:', result);
        
        if (result.success) {
          console.log('✅ Pay rate updated successfully:', result);
          
          // Refresh data from server to get the latest information
          await forceRefreshStaffList();
          
          // Refresh holiday entitlements for consistency (pay rate changes don't directly affect entitlements)
          console.log('🏖️ Pay rate changed, refreshing holiday entitlements...');
          await loadHolidayEntitlements();
          
          // Refresh change request dialog if it's open
          await refreshChangeRequestDialog(staffId);
          
          // Show success message
          const successMsg = document.createElement('div');
          successMsg.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
          `;
          successMsg.textContent = `✅ ${staffName}'s pay rate updated to £${newPayRate}/hour!`;
          document.body.appendChild(successMsg);
          
          setTimeout(() => {
            successMsg.style.animation = 'slideOutRight 0.3s ease-out';
            setTimeout(() => successMsg.remove(), 300);
          }, 3000);
          
          payRateDialog.remove();
        } else {
          throw new Error(result.message || 'Failed to update pay rate');
        }
      } catch (error) {
        console.error('❌ Error updating pay rate:', error);
        
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc3545;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        errorMsg.textContent = `❌ Failed to update ${staffName}'s pay rate: ${error.message}`;
        document.body.appendChild(errorMsg);
        
        setTimeout(() => {
          errorMsg.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => errorMsg.remove(), 300);
        }, 5000);
      }
    }

    // Function to save the selected contracted hours
    window.saveStaffContractedHours = async function(staffName, staffId, buttonElement) {
      console.log('⏰ saveStaffContractedHours called with:', { staffName, staffId, buttonElement });
      
      const contractedHoursDialog = buttonElement.closest('.contracted-hours-edit-dialog');
      const newContractedHoursInput = contractedHoursDialog.querySelector('#new-contracted-hours-input');
      const newContractedHours = parseFloat(newContractedHoursInput.value);
      
      // Get the new text box values
      const changedByInput = contractedHoursDialog.querySelector('#contracted-hours-changed-by');
      const reasonInput = contractedHoursDialog.querySelector('#contracted-hours-reason');
      const effectiveDateInput = contractedHoursDialog.querySelector('#contracted-hours-effective-date');
      const changedBy = changedByInput ? changedByInput.value : 'system';
      const reason = reasonInput ? reasonInput.value : '';
      const effectiveFromDate = effectiveDateInput ? effectiveDateInput.value : new Date().toISOString().slice(0, 16);
      
      if (isNaN(newContractedHours) || newContractedHours < 0) {
        alert('Please enter a valid contracted hours (positive number).');
        return;
      }
      
      // Find the staff member data
      const staffMember = window.globalStaffMembers.find(staff => staff.unique_id === staffId);
      
      if (!staffMember) {
        alert('Staff member data not found. Please refresh the page and try again.');
        return;
      }
      
      const currentContractedHours = staffMember.contracted_hours || 0;
      
      if (newContractedHours === currentContractedHours) {
        console.log('ℹ️ No change needed - contracted hours is already set to:', newContractedHours);
        
        const infoMsg = document.createElement('div');
        infoMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #17a2b8;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        infoMsg.textContent = `ℹ️ ${staffName} already has the contracted hours: ${newContractedHours}h`;
        document.body.appendChild(infoMsg);
        
        setTimeout(() => {
          infoMsg.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => infoMsg.remove(), 300);
        }, 3000);
        
        contractedHoursDialog.remove();
        return;
      }
      
      try {
        console.log('🔄 Updating contracted hours for:', staffName, 'from', currentContractedHours, 'to', newContractedHours);
        
        const result = await apiService.updateStaffContractedHours(staffId, newContractedHours, changedBy, reason, effectiveFromDate);
        console.log('🔍 API response:', result);
        
        if (result.success) {
          console.log('✅ Contracted hours updated successfully:', result);
          
          // Refresh data from server to get the latest information
          await forceRefreshStaffList();
          
          // Refresh holiday entitlements as contracted hours affect entitlement calculation
          console.log('🏖️ Contracted hours changed, refreshing holiday entitlements...');
          await loadHolidayEntitlements();
          
          // Refresh change request dialog if it's open
          await refreshChangeRequestDialog(staffId);
          
          // Show success message
          const successMsg = document.createElement('div');
          successMsg.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
          `;
          successMsg.textContent = `✅ ${staffName}'s contracted hours updated to ${newContractedHours}h!`;
          document.body.appendChild(successMsg);
          
          setTimeout(() => {
            successMsg.style.animation = 'slideOutRight 0.3s ease-out';
            setTimeout(() => successMsg.remove(), 300);
          }, 3000);
          
          contractedHoursDialog.remove();
        } else {
          throw new Error(result.message || 'Failed to update contracted hours');
        }
      } catch (error) {
        console.error('❌ Error updating contracted hours:', error);
        
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc3545;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        errorMsg.textContent = `❌ Failed to update ${staffName}'s contracted hours: ${error.message}`;
        document.body.appendChild(errorMsg);
        
        setTimeout(() => {
          errorMsg.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => errorMsg.remove(), 300);
        }, 5000);
      }
    }

    // Function to save the selected employment start date
    window.saveStaffEmploymentDate = async function(staffName, staffId, buttonElement) {
      console.log('📅 saveStaffEmploymentDate called with:', { staffName, staffId, buttonElement });
      
      const dateDialog = buttonElement.closest('.date-edit-dialog');
      const newDateInput = dateDialog.querySelector('#new-employment-date-input');
      const newDate = newDateInput.value;
      
      // Get the new text box values
      const changedByInput = dateDialog.querySelector('#date-changed-by');
      const reasonInput = dateDialog.querySelector('#date-reason');
      const effectiveDateInput = dateDialog.querySelector('#date-effective-date');
      const changedBy = changedByInput ? changedByInput.value : 'system';
      const reason = reasonInput ? reasonInput.value : '';
      const effectiveFromDate = effectiveDateInput ? effectiveDateInput.value : new Date().toISOString().slice(0, 16);
      
      if (!newDate) {
        alert('Please enter a valid employment start date.');
        return;
      }
      
      // Find the staff member data
      const staffMember = window.globalStaffMembers.find(staff => staff.unique_id === staffId);
      
      if (!staffMember) {
        alert('Staff member data not found. Please refresh the page and try again.');
        return;
      }
      
      const currentDate = staffMember.employment_start_date || '';
      
      if (newDate === currentDate) {
        console.log('ℹ️ No change needed - employment start date is already set to:', newDate);
        
        const infoMsg = document.createElement('div');
        infoMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #17a2b8;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        infoMsg.textContent = `ℹ️ ${staffName} already has the employment start date: ${new Date(newDate).toLocaleDateString('en-GB')}`;
        document.body.appendChild(infoMsg);
        
        setTimeout(() => {
          infoMsg.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => infoMsg.remove(), 300);
        }, 3000);
        
        dateDialog.remove();
        return;
      }
      
      try {
        console.log('🔄 Updating employment start date for:', staffName, 'from', currentDate, 'to', newDate);
        
        const result = await apiService.updateStaffEmploymentDate(staffId, newDate, changedBy, reason, effectiveFromDate);
        console.log('🔍 API response:', result);
        
        if (result.success) {
          console.log('✅ Employment start date updated successfully:', result);
          
          // Refresh data from server to get the latest information
          await forceRefreshStaffList();
          
          // Refresh holiday entitlements as employment start date affects pro-rata calculation
          console.log('🏖️ Employment start date changed, refreshing holiday entitlements...');
          await loadHolidayEntitlements();
          
          // Refresh change request dialog if it's open
          await refreshChangeRequestDialog(staffId);
          
          // Show success message
          const successMsg = document.createElement('div');
          successMsg.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
          `;
          successMsg.textContent = `✅ ${staffName}'s employment start date updated to ${new Date(newDate).toLocaleDateString('en-GB')}!`;
          document.body.appendChild(successMsg);
          
          setTimeout(() => {
            successMsg.style.animation = 'slideOutRight 0.3s ease-out';
            setTimeout(() => successMsg.remove(), 300);
          }, 3000);
          
          // Close the dialog
          dateDialog.remove();
          
        } else {
          throw new Error(result.message || 'Failed to update employment start date');
        }
        
      } catch (error) {
        console.error('❌ Error updating employment start date:', error);
        
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc3545;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        errorMsg.textContent = `❌ Failed to update ${staffName}'s employment start date: ${error.message}`;
        document.body.appendChild(errorMsg);
        
        setTimeout(() => {
          errorMsg.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => errorMsg.remove(), 300);
        }, 5000);
      }
    }
    // Function to save the selected employment end date
    window.saveStaffEmploymentEndDate = async function(staffName, staffId, buttonElement) {
      console.log('📅 saveStaffEmploymentEndDate called with:', { staffName, staffId, buttonElement });
      
      const endDateDialog = buttonElement.closest('.end-date-edit-dialog');
      const newEndDateInput = endDateDialog.querySelector('#new-employment-end-date-input');
      const newEndDate = newEndDateInput.value;
      
      // Get the new text box values
      const changedByInput = endDateDialog.querySelector('#end-date-changed-by');
      const reasonInput = endDateDialog.querySelector('#end-date-reason');
      const effectiveDateInput = endDateDialog.querySelector('#end-date-effective-date');
      const changedBy = changedByInput ? changedByInput.value : 'system';
      const reason = reasonInput ? reasonInput.value : '';
      const effectiveFromDate = effectiveDateInput ? effectiveDateInput.value : new Date().toISOString().slice(0, 16);
      
      // Find the staff member data
      const staffMember = window.globalStaffMembers.find(staff => staff.unique_id === staffId);
      
      if (!staffMember) {
        alert('Staff member data not found. Please refresh the page and try again.');
        return;
      }
      
      const currentEndDate = staffMember.employment_end_date || '';
      
      if (newEndDate === currentEndDate) {
        console.log('ℹ️ No change needed - employment end date is already set to:', newEndDate);
        
        const infoMsg = document.createElement('div');
        infoMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #17a2b8;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        infoMsg.textContent = `ℹ️ ${staffName} already has the employment end date: ${newEndDate ? new Date(newEndDate).toLocaleDateString('en-GB') : 'Still employed'}`;
        document.body.appendChild(infoMsg);
        
        setTimeout(() => {
          infoMsg.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => infoMsg.remove(), 300);
        }, 3000);
        
        endDateDialog.remove();
        return;
      }
      
      try {
        console.log('🔄 Updating employment end date for:', staffName, 'from', currentEndDate, 'to', newEndDate);
        
        const result = await apiService.updateStaffEmploymentEndDate(staffId, newEndDate, changedBy, reason, effectiveFromDate);
        console.log('🔍 API response:', result);
        
        if (result.success) {
          console.log('✅ Employment end date updated successfully:', result);
          
          // Refresh data from server to get the latest information
          await forceRefreshStaffList();
          
          // Refresh holiday entitlements as employment end date affects pro-rata calculation
          console.log('🏖️ Employment end date changed, refreshing holiday entitlements...');
          await loadHolidayEntitlements();
          
          // Refresh change request dialog if it's open
          await refreshChangeRequestDialog(staffId);
          
          // Show success message
          const successMsg = document.createElement('div');
          successMsg.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
          `;
          successMsg.textContent = `✅ ${staffName}'s employment end date updated to ${newEndDate ? new Date(newEndDate).toLocaleDateString('en-GB') : 'Still employed'}!`;
          document.body.appendChild(successMsg);
          
          setTimeout(() => {
            successMsg.style.animation = 'slideOutRight 0.3s ease-out';
            setTimeout(() => successMsg.remove(), 300);
          }, 3000);
          
          // Close the dialog
          endDateDialog.remove();
          
        } else {
          throw new Error(result.message || 'Failed to update employment end date');
        }
        
      } catch (error) {
        console.error('❌ Error updating employment end date:', error);
        
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc3545;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        errorMsg.textContent = `❌ Failed to update ${staffName}'s employment end date: ${error.message}`;
        document.body.appendChild(errorMsg);
        
        setTimeout(() => {
          errorMsg.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => errorMsg.remove(), 300);
        }, 5000);
      }
    }
    
    // Function to show role history in a dedicated dialog
    async function showRoleHistory(staffName, staffMember) {
      console.log('📚 showRoleHistory called for:', staffName, staffMember);
      
      if (!staffMember) {
        console.error('❌ Staff member data not found for:', staffName);
        alert('Staff member data not found. Please refresh the page and try again.');
        return;
      }
      
      // Create a dedicated role history dialog
      const historyDialog = document.createElement('div');
      historyDialog.className = 'role-history-dialog';
      historyDialog.innerHTML = `
        <div class="role-history-content-dialog">
          <div class="role-history-header">
            <h3>📚 Role History - ${staffName}</h3>
            <button class="close-history-dialog" onclick="this.closest('.role-history-dialog').remove()">×</button>
          </div>
          <div class="role-history-body">
            <div class="current-role-display">
              <label>Current Role:</label>
              <span class="current-role-badge ${staffMember.role.replace(' ', '-')}">${staffMember.role}</span>
            </div>
            <div class="role-history-list">
              <label>Role Change History:</label>
              <div id="role-history-list-${staffMember.unique_id}" class="role-history-items">
                <div class="loading-role-history">Loading role history...</div>
              </div>
            </div>
          </div>
          <div class="role-history-actions">
            <button class="close-history-btn" onclick="this.closest('.role-history-dialog').remove()">Close</button>
            <button class="edit-role-from-history-btn" onclick="editStaffRole('${staffName}', ${JSON.stringify(staffMember).replace(/"/g, '&quot;')})">Edit Role</button>
          </div>
        </div>
      `;
      
      // Add the dialog to the page
      document.body.appendChild(historyDialog);
      
      // Load role history
      loadRoleHistoryForDialog(staffMember.unique_id);
    }
    
    // Function to load role history for the dedicated dialog
    async function loadRoleHistoryForDialog(staffId) {
      try {
        console.log('📚 Loading role history for dialog, staff ID:', staffId);
        
        const result = await apiService.getRoleHistory(staffId);
        
        if (result.success) {
          displayRoleHistoryForDialog(staffId, result.data);
        } else {
          console.error('❌ Failed to load role history for dialog:', result);
          displayRoleHistoryErrorForDialog(staffId, 'Failed to load role history');
        }
      } catch (error) {
        console.error('❌ Error loading role history for dialog:', error);
        displayRoleHistoryErrorForDialog(staffId, 'Error loading role history');
      }
    }
    
    // Function to display role history in the dedicated dialog
    function displayRoleHistoryForDialog(staffId, historyData) {
      const historyContainer = document.getElementById(`role-history-list-${staffId}`);
      if (!historyContainer) return;
      
      if (historyData.length === 0) {
        historyContainer.innerHTML = '<div class="no-role-history">No role changes recorded yet.</div>';
        return;
      }
      
      const historyHTML = historyData.map(record => {
        const changeDate = new Date(record.changed_at).toLocaleDateString('en-GB', {
          day: 'numeric',
          month: 'short',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        return `
          <div class="role-history-item-dialog">
            <div class="role-change-info-dialog">
              <div class="role-change-arrow-dialog">
                <span class="previous-role">${record.previous_role}</span>
                <span class="change-arrow">→</span>
                <span class="new-role">${record.new_role}</span>
              </div>
              <span class="role-change-date-dialog">${changeDate}</span>
            </div>
            ${record.reason ? `<div class="role-change-reason-dialog">${record.reason}</div>` : ''}
          </div>
        `;
      }).join('');
      
      historyContainer.innerHTML = historyHTML;
    }
    
    // Function to display role history error in the dedicated dialog
    function displayRoleHistoryErrorForDialog(staffId, errorMessage) {
      const historyContainer = document.getElementById(`role-history-list-${staffId}`);
      if (historyContainer) {
        historyContainer.innerHTML = `<div class="role-history-error">${errorMessage}</div>`;
      }
    }
    
    /* showRoleHistoryFromSummary function removed - no longer needed */

    // Function to view staff history (for team members table)
    window.viewStaffHistory = async function(staffName, staffMember) {
      console.log('📚 viewStaffHistory called for:', staffName, staffMember);
      
      try {
        // If staffMember is not provided, try to find it from globalStaffMembers
        if (!staffMember && window.globalStaffMembers && window.globalStaffMembers.length > 0) {
          staffMember = window.globalStaffMembers.find(s => s.staff_name === staffName);
          console.log('🔍 Found staff member from globalStaffMembers:', staffMember);
        }
        
        if (!staffMember) {
          console.error('❌ Staff member data not provided:', staffName);
          alert('Staff member data not found. Please refresh the page and try again.');
          return;
        }
        
        // Show the changes history dialog
        showChangesHistory(staffName, staffMember);
      } catch (error) {
        console.error('❌ Error in viewStaffHistory:', error);
        alert('Error loading staff history. Please refresh the page and try again.');
      }
    }



    // Function to show changes history in a dedicated dialog
    async function showChangesHistory(staffName, staffMember) {
      console.log('📚 showChangesHistory called for:', staffName, staffMember);
      
      if (!staffMember) {
        console.error('❌ Staff member data not found for:', staffName);
        alert('Staff member data not found. Please refresh the page and try again.');
        return;
      }
      
      // Create a dedicated changes history dialog
      const historyDialog = document.createElement('div');
      historyDialog.className = 'changes-history-dialog';
      historyDialog.innerHTML = `
        <div class="changes-history-content-dialog">
          <div class="changes-history-header">
            <h3>📋 Change Requests & History - ${staffName}</h3>
            <button class="close-changes-history-dialog" onclick="this.closest('.changes-history-dialog').remove()">×</button>
          </div>
          <div class="changes-history-body">
            <div class="changes-history-section">
              <h4>🕐 Pending Change Requests</h4>
              <div class="changes-history-list">
                <div id="change-requests-content-${staffMember.unique_id}" class="changes-history-items">
                  <div class="loading-changes-history">Loading pending change requests...</div>
                </div>
              </div>
            </div>
            <div class="changes-history-section">
              <h4>📚 All Changes History</h4>
              <div class="changes-history-list">
                <div id="changes-history-content-${staffMember.unique_id}" class="changes-history-items">
                  <div class="loading-changes-history">Loading changes history...</div>
                </div>
              </div>
            </div>
          </div>
          <div class="changes-history-actions">
            <button class="close-changes-history-btn" onclick="this.closest('.changes-history-dialog').remove()">Close</button>
          </div>
        </div>
      `;
      
      // Add the dialog to the page
      document.body.appendChild(historyDialog);
      
      // Load all change request and history data
      loadAllChangeData(staffMember.unique_id);
    }

    // Function to load all change request and history data
    async function loadAllChangeData(staffId) {
      console.log('📋 Loading all change data for staff ID:', staffId);
      
      try {
        // Load pending change requests and all changes history in parallel
        const [changeRequests, changesHistory] = await Promise.all([
          apiService.getChangeRequests(staffId),
          apiService.getChangesHistory(staffId)
        ]);
        
        // Display each type of data
        displayChangeRequests(staffId, changeRequests);
        displayCombinedHistory(staffId, changesHistory.data || changesHistory);
        
      } catch (error) {
        console.error('❌ Error loading change data:', error);
        
        // Display errors for each section
        displayChangeRequestsError(staffId, error.message);
        displayCombinedHistoryError(staffId, error.message);
      }
    }

    // Function to refresh change request dialog for a specific staff member
    window.refreshChangeRequestDialog = async function(staffId) {
      console.log('🔄 Refreshing change request dialog for staff ID:', staffId);
      
      // Check if the dialog is open
      const dialog = document.querySelector('.changes-history-dialog');
      if (dialog) {
        // Reload the change data
        await loadAllChangeData(staffId);
        console.log('✅ Change request dialog refreshed');
      }
    }

    // Function to delete a change request (global scope for onclick handlers)
    window.deleteChangeRequest = async function(staffId, changeId) {
      console.log('🗑️ Deleting change request:', changeId, 'for staff:', staffId);
      console.log('🔍 Debug - Staff ID type:', typeof staffId, 'Value:', staffId);
      console.log('🔍 Debug - Change ID type:', typeof changeId, 'Value:', changeId);
      
      // Get change details first to show in warning
      try {
        // Check both applied changes and pending changes
        const [appliedResponse, pendingResponse] = await Promise.all([
          fetch(`${API_BASE_URL}/staff/${staffId}/changes-history`),
          fetch(`${API_BASE_URL}/staff/${staffId}/change-requests`)
        ]);
        
        const appliedData = await appliedResponse.json();
        const pendingData = await pendingResponse.json();
        
        console.log('🔍 Debug - Applied changes response:', appliedData);
        console.log('🔍 Debug - Pending changes response:', pendingData);
        
        // Combine both applied and pending changes
        const allChanges = [
          ...(appliedData.success ? appliedData.data : []),
          ...(pendingData.success ? pendingData.data : [])
        ];
        
        console.log('🔍 Debug - All changes (applied + pending):', allChanges.map(c => ({ id: c.id, change_type: c.change_type, effective_date: c.effective_from_date })));
        
        const changeToDelete = allChanges.find(change => change.id === changeId);
        console.log('🔍 Debug - Found change to delete:', changeToDelete);
        
        if (!changeToDelete) {
          alert('❌ Change request not found! Available changes: ' + allChanges.map(c => c.id).join(', '));
          return;
        }
        
        // Check if this is an applied change (will affect future changes)
        const now = new Date();
        const effectiveDate = new Date(changeToDelete.effective_from_date);
        const isApplied = effectiveDate <= now;
        
        // Create detailed warning message
        let warningMessage = '⚠️ CRITICAL WARNING: DELETE CHANGE REQUEST\n\n';
        warningMessage += `Change Type: ${changeToDelete.change_type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}\n`;
        warningMessage += `Change: ${changeToDelete.old_value} → ${changeToDelete.new_value}\n`;
        warningMessage += `Changed By: ${changeToDelete.changed_by || 'system'}\n`;
        warningMessage += `Reason: ${changeToDelete.reason || 'N/A'}\n`;
        warningMessage += `Effective Date: ${new Date(changeToDelete.effective_from_date).toLocaleDateString('en-GB', {
          day: 'numeric', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit'
        })}\n\n`;
        
        if (isApplied) {
          warningMessage += '🚨 THIS CHANGE HAS BEEN APPLIED!\n\n';
          warningMessage += `• The staff member will be reverted to: ${changeToDelete.old_value}\n`;
          warningMessage += `• Only this specific change will be deleted\n`;
        } else {
          warningMessage += '📅 This is a pending change (not yet applied)\n\n';
        }
        
        warningMessage += '⚠️ THIS ACTION CANNOT BE UNDONE!\n';
        warningMessage += '⚠️ This change will be lost permanently!\n\n';
        warningMessage += 'Are you absolutely sure you want to proceed?';
        
        // Show confirmation dialog
        const confirmed = confirm(warningMessage);
        if (!confirmed) {
          console.log('❌ Delete cancelled by user');
          return;
        }
        
      } catch (error) {
        console.error('❌ Error getting change details:', error);
        // Fallback to simple confirmation
        const confirmed = confirm('⚠️ WARNING: This will permanently delete the change request and cannot be undone!\n\nAre you sure you want to proceed?');
        if (!confirmed) {
          return;
        }
      }
      
      try {
        const deleteUrl = `${API_BASE_URL}/staff/${staffId}/change-request/${changeId}`;
        console.log('🔍 Debug - DELETE URL:', deleteUrl);
        
        const response = await fetch(deleteUrl, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        console.log('🔍 Debug - DELETE response status:', response.status);
        const result = await response.json();
        console.log('🔍 Debug - DELETE response:', result);
        
        if (result.success) {
          console.log('✅ Change request deleted successfully');
          
          // Show detailed success message
          const successMsg = document.createElement('div');
          successMsg.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
            max-width: 400px;
            word-wrap: break-word;
          `;
          
          let successText = '✅ Change request deleted successfully!';
          if (result.data.reverted) {
            successText = `✅ Change deleted and reverted to: ${result.data.reverted_value}`;
          }
          
          successMsg.textContent = successText;
          document.body.appendChild(successMsg);
          
          setTimeout(() => {
            successMsg.style.animation = 'slideOutRight 0.3s ease-out';
            setTimeout(() => successMsg.remove(), 300);
          }, 3000);
          
          // Refresh the change request dialog
          await refreshChangeRequestDialog(staffId);
          
        } else {
          throw new Error(result.message || 'Failed to delete change request');
        }
        
      } catch (error) {
        console.error('❌ Error deleting change request:', error);
        
        // Show error message
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc3545;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        errorMsg.textContent = `❌ Failed to delete change request: ${error.message}`;
        document.body.appendChild(errorMsg);
        
        setTimeout(() => {
          errorMsg.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => errorMsg.remove(), 300);
        }, 5000);
      }
    }

    // Function to display pending change requests
    function displayChangeRequests(staffId, requests) {
      const container = document.getElementById(`change-requests-content-${staffId}`);
      if (!container) return;
      
      if (requests.length === 0) {
        container.innerHTML = '<div class="no-changes-history">No pending change requests.</div>';
        return;
      }
      
      const tableHTML = `
        <table class="history-table">
          <thead>
            <tr>
              <th>Change Type</th>
              <th>Old Value</th>
              <th>New Value</th>
              <th>Changed By</th>
              <th>Reason</th>
              <th>Effective Date</th>
              <th>Changed Date</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            ${requests.map(request => {
              const effectiveDate = new Date(request.effective_from_date).toLocaleDateString('en-GB', {
                day: 'numeric',
                month: 'short',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
              });
              
              const changeDate = new Date(request.changed_at).toLocaleDateString('en-GB', {
                day: 'numeric',
                month: 'short',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
              });
              
              const changeTypeLabel = request.change_type.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
              
              return `
                <tr class="change-request-row pending">
                  <td class="change-type-cell">
                    <span class="change-type-label">${changeTypeLabel}</span>
                  </td>
                  <td class="old-value-cell">${request.old_value || 'N/A'}</td>
                  <td class="new-value-cell">${request.new_value}</td>
                  <td class="changed-by-cell">${request.changed_by}</td>
                  <td class="reason-cell">${request.reason || 'No reason provided'}</td>
                  <td class="effective-date-cell">${effectiveDate}</td>
                  <td class="changed-date-cell">${changeDate}</td>
                  <td class="actions-cell">
                    <button class="delete-change-btn" onclick="deleteChangeRequest('${staffId}', '${request.id}')" title="Delete this change request">
                      🗑️
                    </button>
                  </td>
                </tr>
              `;
            }).join('')}
          </tbody>
        </table>
      `;
      
      container.innerHTML = tableHTML;
    }


    // Function to format change type for display
    function formatChangeType(changeType) {
      const typeMap = {
        'role_change': 'Role Change',
        'pay_rate_change': 'Pay Rate Change',
        'contracted_hours_change': 'Contracted Hours Change',
        'employment_date_change': 'Employment Start Date Change',
        'employment_end_date_change': 'Employment End Date Change',
        'color_code_change': 'Color Code Change',
        'active_status_change': 'Status Change'
      };
      return typeMap[changeType] || changeType;
    }

    // Error display functions
    function displayChangeRequestsError(staffId, errorMessage) {
      const container = document.getElementById(`change-requests-content-${staffId}`);
      if (container) {
        container.innerHTML = `<div class="changes-history-error">Error loading change requests: ${errorMessage}</div>`;
      }
    }


    // Function to show shift history in a dedicated dialog
    async function showShiftHistory(staffName, staffMember) {
      console.log('📅 showShiftHistory called for:', staffName, staffMember);
      
      if (!staffMember) {
        console.error('❌ Staff member data not found for:', staffName);
        alert('Staff member data not found. Please refresh the page and try again.');
        return;
      }
      
      // Note: We don't calculate a single pay rate here anymore
      // Each shift will use its historical pay rate based on the role at that time
      
      // Create a dedicated shift history dialog
      const historyDialog = document.createElement('div');
      historyDialog.className = 'shift-history-dialog';
      historyDialog.innerHTML = `
        <div class="shift-history-content-dialog">
          <div class="shift-history-header">
            <h3>Shift History - ${staffName}</h3>
            <button class="close-shift-history-dialog" onclick="this.closest('.shift-history-dialog').remove()">×</button>
          </div>
          <div class="shift-history-body">
            <div class="date-range-section">
              <h4>Select Date Range</h4>
              <div class="date-inputs">
                <div class="date-input-group">
                  <label>From:</label>
                    <input type="date" id="shift-history-from-date" class="shift-history-date-input" value="">
                </div>
                <div class="date-input-group">
                  <label>To:</label>
                    <input type="date" id="shift-history-to-date" class="shift-history-date-input" value="">
                </div>
              </div>
            </div>
            
            <div class="shift-summary-section">
              <h4>Shift Summary</h4>
              <div class="shift-summary-cards">
                <div class="summary-card">
                  <div class="summary-label">Total Shifts</div>
                  <div class="summary-value" id="total-shifts-count">0</div>
                </div>
                <div class="summary-card">
                  <div class="summary-label">Day Shifts</div>
                  <div class="summary-value" id="day-shifts-count">0</div>
                </div>
                <div class="summary-card">
                  <div class="summary-label">Night Shifts</div>
                  <div class="summary-value" id="night-shifts-count">0</div>
                </div>
                <div class="summary-card">
                  <div class="summary-label">Holiday Shifts</div>
                  <div class="summary-value" id="holiday-shifts-count">0</div>
                </div>
                <div class="summary-card">
                  <div class="summary-label">Total Hours</div>
                  <div class="summary-value" id="total-hours-count">0 hrs</div>
                </div>
              </div>
            </div>
            
            <div class="detailed-shifts-section">
              <div class="shifts-section-header">
              <h4>Detailed Shift List</h4>
                <button id="export-shift-history-btn" class="export-btn" title="Export shift history to CSV">
                  <span class="btn-icon">📊</span>
                  Export
                </button>
              </div>
              <div class="shifts-table-container">
                <table class="shifts-table" id="shifts-table">
                  <thead>
                    <tr>
                      <th>Week</th>
                      <th>Date</th>
                      <th>Day</th>
                      <th>Type</th>
                      <th>Hours</th>
                      <th>Rate</th>
                      <th>Pay</th>
                      <th>Flags</th>
                    </tr>
                  </thead>
                  <tbody id="shifts-table-body">
                    <tr>
                      <td colspan="8" class="loading-shifts">Loading shifts...</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      `;
      
      // Add the dialog to the page
      document.body.appendChild(historyDialog);
      
      // Set the date inputs to the same range as the overall shift summary
      const fromDateInput = document.getElementById('shift-history-from-date');
      const toDateInput = document.getElementById('shift-history-to-date');
      
              if (fromDateInput && toDateInput) {
          try {
            // Get the previous pay period date ranges (same as overall shift summary)
            const startDate = getPreviousPayPeriodStartDate();
            const endDate = getPreviousPayPeriodEndDate();
            
            console.log('📅 Setting individual shift history date range (previous pay period):');
            console.log('   From (day after previous period pay date):', startDate);
            console.log('   To (current period pay date):', endDate);
            
            // Set the input values
            fromDateInput.value = startDate;
            toDateInput.value = endDate;
          
        } catch (error) {
          console.error('❌ Error setting shift history date range:', error);
          // Fallback to default dates
          const today = new Date();
          const fromDate = new Date(today);
          fromDate.setMonth(today.getMonth() - 1);
          const toDate = new Date(today);
          toDate.setMonth(today.getMonth() + 1);
          
          fromDateInput.value = fromDate.toISOString().split('T')[0];
          toDateInput.value = toDate.toISOString().split('T')[0];
        }
      }
      
      // Load shift data
      loadShiftHistoryData(staffName, staffMember);
      
      // Add event listeners for date changes
      setupShiftHistoryDateListeners(staffName, staffMember);
    }

    // Function to get financial year dates
    window.getFinancialYearDates = function() {
      const currentDate = new Date();
      const currentYear = currentDate.getFullYear();
      
      console.log('📅 Current date:', currentDate);
      console.log('📅 Current year:', currentYear);
      
      // Financial year runs from April 6th to April 5th next year
      // So for 2025, it's April 6, 2025 to April 5, 2026
      const financialYearStart = new Date(currentYear, 3, 6); // April 6th (month is 0-indexed)
      const financialYearEnd = new Date(currentYear + 1, 3, 5); // April 5th next year
      
      console.log('📅 Financial year start (April 6):', financialYearStart);
      console.log('📅 Financial year end (April 5 next year):', financialYearEnd);
      
      // If we're before April 6th, we're in the previous financial year
      if (currentDate < financialYearStart) {
        console.log('📅 We are before April 6th, using previous financial year');
        const prevFinancialYearStart = new Date(currentYear - 1, 3, 6);
        const prevFinancialYearEnd = new Date(currentYear, 3, 5);
        const result = {
          start: prevFinancialYearStart,
          end: prevFinancialYearEnd,
          nextStart: financialYearStart,
          nextEnd: financialYearEnd
        };
        console.log('📅 Previous FY result:', result);
        return result;
      } else {
        console.log('📅 We are after April 6th, using current financial year');
        const nextFinancialYearStart = new Date(currentYear + 1, 3, 6);
        const nextFinancialYearEnd = new Date(currentYear + 2, 3, 5);
        const result = {
          start: financialYearStart,
          end: financialYearEnd,
          nextStart: nextFinancialYearStart,
          nextEnd: nextFinancialYearEnd
        };
        console.log('📅 Current FY result:', result);
        return result;
      }
    }

    // Quick test function that can be called immediately
    window.quickTestCumulativeHours = async function() {
      console.log('⚡ Quick cumulative hours test...');
      
      try {
        // Check if staff members are loaded
        const staffMembers = window.globalStaffMembers || [];
        if (staffMembers.length === 0) {
          console.error('❌ No staff members loaded. Please load the application first.');
          return;
        }
        
        // Test first staff member
        const testStaff = staffMembers[0];
        const staffName = testStaff.staff_name;
        
        console.log(`👤 Testing: ${staffName}`);
        
        // Test both functions
        const globalResult = await window.calculateCumulativeHours(staffName);
        const moduleResult = await ShiftSummaryModule.calculateCumulativeHours(staffName);
        
        console.log(`📊 Global function: ${globalResult} hours`);
        console.log(`📊 Module function: ${moduleResult} hours`);
        
        const match = Math.abs(globalResult - moduleResult) < 0.01;
        console.log(`🎯 Results match: ${match ? '✅ YES' : '❌ NO'}`);
        
        if (!match) {
          console.log(`⚠️ Difference: ${Math.abs(globalResult - moduleResult)} hours`);
          console.log('🔍 Run debugCumulativeHours("' + staffName + '") for detailed analysis');
        }
        
        return { staffName, globalResult, moduleResult, match };
        
      } catch (error) {
        console.error('❌ Quick test failed:', error);
        return { error: error.message };
      }
    };

    // Master function to run all cumulative hours tests
    window.runAllCumulativeHoursTests = async function() {
      console.log('🚀 Running comprehensive cumulative hours tests...');
      console.log('================================================');
      
      try {
        // Test 1: API Endpoints
        console.log('\n📡 TEST 1: API Endpoints');
        console.log('------------------------');
        await window.testCumulativeHoursAPI();
        
        // Test 2: Auto Test
        console.log('\n🤖 TEST 2: Auto Test');
        console.log('-------------------');
        const autoResults = await window.autoTestCumulativeHours();
        
        // Test 3: Date Range Test
        console.log('\n📅 TEST 3: Date Range Logic');
        console.log('---------------------------');
        const dateResults = window.testDateRangeLogic();
        
        // Summary
        console.log('\n📋 COMPREHENSIVE TEST SUMMARY');
        console.log('=============================');
        
        if (autoResults && autoResults.length > 0) {
          const allMatch = autoResults.every(r => r.match);
          console.log(`✅ Cumulative Hours: ${allMatch ? 'All calculations match' : 'Some calculations differ'}`);
          
          if (!allMatch) {
            console.log('❌ Issues found:');
            autoResults.forEach(result => {
              if (!result.match) {
                console.log(`   - ${result.name}: Global=${result.global}h vs Module=${result.module}h (diff: ${result.difference}h)`);
              }
            });
          }
        }
        
        console.log('\n🎯 RECOMMENDATIONS:');
        console.log('1. Check API endpoints are working correctly');
        console.log('2. Verify financial year date calculation');
        console.log('3. Ensure both global and module functions use same logic');
        console.log('4. Check for timezone issues in date calculations');
        console.log('5. Verify shift data exists for the calculated date range');
        
        return {
          autoResults,
          dateResults,
          timestamp: new Date().toISOString()
        };
        
      } catch (error) {
        console.error('❌ Error running comprehensive tests:', error);
        return { error: error.message };
      }
    };

    // Function to test the API endpoint directly
    window.testCumulativeHoursAPI = async function() {
      console.log('🌐 Testing cumulative hours API endpoint...');
      
      try {
        // Get staff members
        const staffMembers = window.globalStaffMembers || [];
        if (staffMembers.length === 0) {
          console.error('❌ No staff members found');
          return;
        }
        
        const testStaff = staffMembers[0]; // Test first staff member
        const staffName = testStaff.staff_name;
        
        console.log(`👤 Testing API for: ${staffName}`);
        
        // Calculate financial year dates
        const currentDate = new Date();
        const currentYear = currentDate.getFullYear();
        
        let currentFYStart, currentFYEnd;
        
        if (currentDate.getMonth() >= 3 && currentDate.getDate() >= 6) {
          currentFYStart = new Date(currentYear, 3, 6);
          currentFYEnd = new Date(currentYear + 1, 3, 5);
        } else {
          currentFYStart = new Date(currentYear - 1, 3, 6);
          currentFYEnd = new Date(currentYear, 3, 5);
        }
        
        const formatDate = (date) => {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        };
        
        const fromDateStr = formatDate(currentFYStart);
        const toDateStr = formatDate(currentFYEnd);
        
        console.log(`📅 Financial Year: ${fromDateStr} to ${toDateStr}`);
        
        // Test different API endpoints
        const endpoints = [
          `/api/shifts/employee/${encodeURIComponent(staffName)}?from=${fromDateStr}&to=${toDateStr}`,
          `/api/shifts?from=${fromDateStr}&to=${toDateStr}`,
          `/api/shifts/employee/${encodeURIComponent(staffName)}`,
          `/api/shifts`
        ];
        
        for (const endpoint of endpoints) {
          console.log(`\n🔗 Testing endpoint: ${endpoint}`);
          
          try {
            const response = await fetch(endpoint);
            console.log(`   Status: ${response.status} ${response.statusText}`);
            
            if (response.ok) {
              const data = await response.json();
              console.log(`   Response:`, data);
              
              if (data.success && data.data) {
                console.log(`   ✅ Found ${data.data.length} shifts`);
                
                if (data.data.length > 0) {
                  // Calculate total hours
                  let totalHours = 0;
                  data.data.forEach((shift, index) => {
                    const startTime = new Date(shift.shift_start_datetime);
                    const endTime = new Date(shift.shift_end_datetime);
                    const duration = (endTime - startTime) / (1000 * 60 * 60);
                    totalHours += duration;
                    
                    if (index < 3) {
                      console.log(`     Shift ${index + 1}: ${duration.toFixed(2)}h`);
                    }
                  });
                  
                  console.log(`   📊 Total hours: ${totalHours.toFixed(2)}`);
                }
              } else {
                console.log(`   ⚠️ No data or error: ${data.error || 'Unknown'}`);
              }
            } else {
              console.log(`   ❌ Request failed`);
            }
          } catch (error) {
            console.log(`   ❌ Error: ${error.message}`);
          }
        }
        
      } catch (error) {
        console.error('❌ Error testing API:', error);
      }
    };

    // Function to automatically test cumulative hours and identify issues
    window.autoTestCumulativeHours = async function() {
      console.log('🤖 Auto-testing cumulative hours calculation...');
      
      try {
        // Get staff members
        const staffMembers = window.globalStaffMembers || [];
        if (staffMembers.length === 0) {
          console.error('❌ No staff members found. Please load staff data first.');
          return;
        }
        
        console.log(`👥 Found ${staffMembers.length} staff members`);
        
        // Test first few staff members
        const testStaff = staffMembers.slice(0, 3); // Test first 3 staff members
        const results = [];
        
        for (const staff of testStaff) {
          const staffName = staff.staff_name;
          console.log(`\n🔍 Testing: ${staffName}`);
          
          // Test global function
          const globalResult = await window.calculateCumulativeHours(staffName);
          console.log(`   Global: ${globalResult} hours`);
          
          // Test module function
          const moduleResult = await ShiftSummaryModule.calculateCumulativeHours(staffName);
          console.log(`   Module: ${moduleResult} hours`);
          
          // Check if they match
          const match = Math.abs(globalResult - moduleResult) < 0.01;
          console.log(`   Match: ${match ? '✅' : '❌'}`);
          
          if (!match) {
            console.log(`   Difference: ${Math.abs(globalResult - moduleResult)} hours`);
          }
          
          results.push({
            name: staffName,
            global: globalResult,
            module: moduleResult,
            match,
            difference: Math.abs(globalResult - moduleResult)
          });
        }
        
        // Summary
        console.log('\n📋 AUTO-TEST RESULTS:');
        console.log('=====================');
        results.forEach(result => {
          const status = result.match ? '✅' : '❌';
          console.log(`${status} ${result.name}: Global=${result.global}h, Module=${result.module}h`);
          if (!result.match) {
            console.log(`   Difference: ${result.difference}h`);
          }
        });
        
        const allMatch = results.every(r => r.match);
        console.log(`\n🎯 Overall: ${allMatch ? 'All calculations match' : 'Some calculations differ'}`);
        
        // If there are issues, run detailed debug on first staff member
        if (!allMatch && results.length > 0) {
          console.log('\n🔍 Running detailed debug on first staff member...');
          await window.debugCumulativeHours(results[0].name);
        }
        
        return results;
        
      } catch (error) {
        console.error('❌ Error in auto-test:', error);
        return { error: error.message };
      }
    };
    // Function to debug cumulative hours calculation step by step
    window.debugCumulativeHours = async function(employeeName) {
      console.log(`🔍 Debugging cumulative hours calculation for: ${employeeName}`);
      
      try {
        // Step 1: Check current date and financial year calculation
        const currentDate = new Date();
        const currentYear = currentDate.getFullYear();
        console.log(`📅 Current date: ${currentDate.toISOString().split('T')[0]}`);
        console.log(`📅 Current year: ${currentYear}`);
        
        // Step 2: Calculate financial year dates
        let currentFYStart, currentFYEnd;
        
        if (currentDate.getMonth() >= 3 && currentDate.getDate() >= 6) {
          // After April 6th - we're in the current financial year
          currentFYStart = new Date(currentYear, 3, 6); // April 6th current year
          currentFYEnd = new Date(currentYear + 1, 3, 5); // April 5th next year
          console.log(`📅 After April 6th - using current financial year`);
        } else {
          // Before April 6th - we're in the previous financial year
          currentFYStart = new Date(currentYear - 1, 3, 6); // April 6th previous year
          currentFYEnd = new Date(currentYear, 3, 5); // April 5th current year
          console.log(`📅 Before April 6th - using previous financial year`);
        }
        
        // Step 3: Format dates
        const formatDate = (date) => {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        };
        
        const fromDateStr = formatDate(currentFYStart);
        const toDateStr = formatDate(currentFYEnd);
        
        console.log(`📅 Financial Year: ${fromDateStr} to ${toDateStr}`);
        console.log(`📅 FY Start: ${currentFYStart.toDateString()}`);
        console.log(`📅 FY End: ${currentFYEnd.toDateString()}`);
        
        // Step 4: Make API call
        const apiUrl = `/api/shifts/employee/${encodeURIComponent(employeeName)}?from=${fromDateStr}&to=${toDateStr}`;
        console.log(`🌐 API URL: ${apiUrl}`);
        
        const response = await fetch(apiUrl);
        console.log(`📡 Response status: ${response.status} ${response.statusText}`);
        
        if (!response.ok) {
          console.error(`❌ API call failed: ${response.statusText}`);
          return;
        }
        
        const shiftsData = await response.json();
        console.log(`📊 API Response:`, shiftsData);
        
        if (!shiftsData.success) {
          console.error(`❌ API Error: ${shiftsData.error}`);
          return;
        }
        
        const shifts = shiftsData.data || [];
        console.log(`📊 Found ${shifts.length} shifts`);
        
        if (shifts.length === 0) {
          console.log(`⚠️ No shifts found for ${employeeName} in financial year ${fromDateStr} to ${toDateStr}`);
          return;
        }
        
        // Step 5: Calculate hours manually
        let totalHours = 0;
        console.log(`📊 Calculating hours for ${shifts.length} shifts:`);
        
        shifts.forEach((shift, index) => {
          const startTime = new Date(shift.shift_start_datetime);
          const endTime = new Date(shift.shift_end_datetime);
          const duration = (endTime - startTime) / (1000 * 60 * 60); // Convert to hours
          totalHours += duration;
          
          console.log(`   Shift ${index + 1}: ${shift.shift_start_datetime} to ${shift.shift_end_datetime} = ${duration.toFixed(2)} hours`);
        });
        
        const finalTotal = Math.round(totalHours * 100) / 100;
        console.log(`📊 Total hours: ${totalHours.toFixed(2)}`);
        console.log(`📊 Rounded total: ${finalTotal}`);
        
        return {
          employeeName,
          financialYear: `${fromDateStr} to ${toDateStr}`,
          shiftsCount: shifts.length,
          totalHours: finalTotal,
          shifts: shifts.map(shift => ({
            start: shift.shift_start_datetime,
            end: shift.shift_end_datetime,
            duration: ((new Date(shift.shift_end_datetime) - new Date(shift.shift_start_datetime)) / (1000 * 60 * 60)).toFixed(2)
          }))
        };
        
      } catch (error) {
        console.error('❌ Error debugging cumulative hours:', error);
        return { error: error.message };
      }
    };

    // Simple function to test cumulative hours for a specific employee
    window.testCumulativeHoursSimple = async function(employeeName) {
      console.log(`🧪 Testing cumulative hours for: ${employeeName}`);
      
      try {
        // Test the global function
        console.log('📊 Testing global calculateCumulativeHours function...');
        const globalResult = await window.calculateCumulativeHours(employeeName);
        console.log(`   Global function result: ${globalResult} hours`);
        
        // Test the ShiftSummaryModule function
        console.log('📊 Testing ShiftSummaryModule.calculateCumulativeHours function...');
        const moduleResult = await ShiftSummaryModule.calculateCumulativeHours(employeeName);
        console.log(`   Module function result: ${moduleResult} hours`);
        
        // Check if they match
        const match = Math.abs(globalResult - moduleResult) < 0.01;
        console.log(`   Results match: ${match ? '✅' : '❌'}`);
        
        if (!match) {
          console.log(`   Difference: ${Math.abs(globalResult - moduleResult)} hours`);
        }
        
        return {
          employeeName,
          globalResult,
          moduleResult,
          match,
          difference: Math.abs(globalResult - moduleResult)
        };
        
      } catch (error) {
        console.error('❌ Error testing cumulative hours:', error);
        return { error: error.message };
      }
    };

    // Function to test cumulative hours calculation
    window.testCumulativeHours = async function(employeeName = null) {
      console.log('🧪 Testing cumulative hours calculation...');
      
      try {
        // Get staff members
        const staffMembers = window.globalStaffMembers || [];
        if (staffMembers.length === 0) {
          console.error('❌ No staff members found');
          return;
        }
        
        // Test specific employee or all employees
        const testStaff = employeeName ? 
          staffMembers.filter(s => s.staff_name === employeeName) : 
          staffMembers;
        
        if (testStaff.length === 0) {
          console.error(`❌ Employee "${employeeName}" not found`);
          return;
        }
        
        console.log(`👥 Testing ${testStaff.length} staff member(s)`);
        
        const results = [];
        
        for (const staff of testStaff) {
          const staffName = staff.staff_name;
          console.log(`\n👤 Testing cumulative hours for: ${staffName}`);
          
          // Test the global function
          console.log('📊 Testing global calculateCumulativeHours function...');
          const globalResult = await window.calculateCumulativeHours(staffName);
          console.log(`   Global function result: ${globalResult} hours`);
          
          // Test the ShiftSummaryModule function
          console.log('📊 Testing ShiftSummaryModule.calculateCumulativeHours function...');
          const moduleResult = await ShiftSummaryModule.calculateCumulativeHours(staffName);
          console.log(`   Module function result: ${moduleResult} hours`);
          
          // Test direct API call to verify data
          console.log('📊 Testing direct API call...');
          const currentDate = new Date();
          const currentYear = currentDate.getFullYear();
          
          // Determine the current financial year
          let currentFYStart, currentFYEnd;
          
          if (currentDate.getMonth() >= 3 && currentDate.getDate() >= 6) {
            // After April 6th - we're in the current financial year
            currentFYStart = new Date(currentYear, 3, 6); // April 6th current year
            currentFYEnd = new Date(currentYear + 1, 3, 5); // April 5th next year
          } else {
            // Before April 6th - we're in the previous financial year
            currentFYStart = new Date(currentYear - 1, 3, 6); // April 6th previous year
            currentFYEnd = new Date(currentYear, 3, 5); // April 5th current year
          }
          
          // Format dates for API call
          const formatDate = (date) => {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
          };
          
          const fromDateStr = formatDate(currentFYStart);
          const toDateStr = formatDate(currentFYEnd);
          
          console.log(`   Financial Year: ${fromDateStr} to ${toDateStr}`);
          
          try {
            const response = await fetch(`/api/shifts/employee/${encodeURIComponent(staffName)}?from=${fromDateStr}&to=${toDateStr}`);
            
            if (response.ok) {
              const shiftsData = await response.json();
              
              if (shiftsData.success && shiftsData.data) {
                const shifts = shiftsData.data;
                console.log(`   Found ${shifts.length} shifts in financial year`);
                
                let manualTotal = 0;
                shifts.forEach((shift, index) => {
                  const startTime = new Date(shift.shift_start_datetime);
                  const endTime = new Date(shift.shift_end_datetime);
                  const duration = (endTime - startTime) / (1000 * 60 * 60);
                  manualTotal += duration;
                  
                  if (index < 3) { // Show first 3 shifts for debugging
                    console.log(`   Shift ${index + 1}: ${shift.shift_start_datetime} to ${shift.shift_end_datetime} = ${duration.toFixed(2)} hours`);
                  }
                });
                
                if (shifts.length > 3) {
                  console.log(`   ... and ${shifts.length - 3} more shifts`);
                }
                
                manualTotal = Math.round(manualTotal * 100) / 100;
                console.log(`   Manual calculation result: ${manualTotal} hours`);
                
                // Compare results
                const resultsMatch = Math.abs(globalResult - moduleResult) < 0.01 && 
                                   Math.abs(globalResult - manualTotal) < 0.01;
                
                const result = {
                  name: staffName,
                  globalResult,
                  moduleResult,
                  manualResult: manualTotal,
                  shiftsCount: shifts.length,
                  financialYear: `${fromDateStr} to ${toDateStr}`,
                  resultsMatch,
                  differences: {
                    globalVsModule: Math.abs(globalResult - moduleResult),
                    globalVsManual: Math.abs(globalResult - manualTotal),
                    moduleVsManual: Math.abs(moduleResult - manualTotal)
                  }
                };
                
                results.push(result);
                
                if (resultsMatch) {
                  console.log(`✅ All calculations match for ${staffName}`);
                } else {
                  console.log(`❌ Calculation mismatch for ${staffName}:`);
                  console.log(`   Global: ${globalResult}, Module: ${moduleResult}, Manual: ${manualTotal}`);
                }
                
              } else {
                console.log(`   No shifts found or API error: ${shiftsData.error || 'Unknown error'}`);
              }
            } else {
              console.log(`   API call failed: ${response.statusText}`);
            }
          } catch (error) {
            console.error(`   Error in direct API call:`, error);
          }
        }
        
        // Summary
        console.log('\n📋 CUMULATIVE HOURS TEST RESULTS:');
        console.log('=====================================');
        results.forEach(result => {
          const status = result.resultsMatch ? '✅' : '❌';
          console.log(`${status} ${result.name}:`);
          console.log(`   Global: ${result.globalResult}h, Module: ${result.moduleResult}h, Manual: ${result.manualResult}h`);
          console.log(`   Shifts: ${result.shiftsCount}, FY: ${result.financialYear}`);
          if (!result.resultsMatch) {
            console.log(`   Differences: Global-Module: ${result.differences.globalVsModule}h, Global-Manual: ${result.differences.globalVsManual}h`);
          }
        });
        
        const allMatch = results.every(r => r.resultsMatch);
        console.log('\n🎯 OVERALL RESULT:');
        if (allMatch) {
          console.log('✅ ALL CUMULATIVE HOURS CALCULATIONS MATCH!');
        } else {
          console.log('❌ SOME CUMULATIVE HOURS CALCULATIONS MISMATCH');
        }
        
        return {
          allMatch,
          results,
          totalStaff: results.length
        };
        
      } catch (error) {
        console.error('❌ Error during cumulative hours test:', error);
        return { allMatch: false, error: error.message };
      }
    };

    // Function to test the new date range logic
    window.testDateRangeLogic = function() {
      console.log('🧪 Testing new date range logic...');
      
      try {
        // Test the date range functions
        const startDate = getPreviousPayPeriodStartDate();
        const endDate = getPreviousPayPeriodEndDate();
        
        console.log('📅 Date Range Test Results:');
        console.log('================================');
        console.log(`Start Date (day after previous period pay date): ${startDate}`);
        console.log(`End Date (current period pay date): ${endDate}`);
        
        // Parse dates for validation
        const start = new Date(startDate);
        const end = new Date(endDate);
        
        console.log('\n📊 Date Analysis:');
        console.log(`Start Date: ${start.toDateString()} (${start.getDay() === 6 ? 'Saturday' : 'Other'})`);
        console.log(`End Date: ${end.toDateString()} (${end.getDay() === 5 ? 'Friday' : 'Other'})`);
        
        // Calculate duration
        const durationMs = end - start;
        const durationDays = Math.round(durationMs / (1000 * 60 * 60 * 24));
        console.log(`Duration: ${durationDays} days`);
        
        // Expected: Should be approximately 28 days (4 weeks)
        if (durationDays >= 27 && durationDays <= 29) {
          console.log('✅ Duration looks correct (approximately 4 weeks)');
        } else {
          console.log('⚠️ Duration seems unusual (expected ~28 days)');
        }
        
        // Check if start date is Saturday (day after Friday pay date)
        if (start.getDay() === 6) {
          console.log('✅ Start date is Saturday (correct - day after Friday pay date)');
        } else {
          console.log('⚠️ Start date is not Saturday (expected day after Friday pay date)');
        }
        
        // Check if end date is Friday (pay date)
        if (end.getDay() === 5) {
          console.log('✅ End date is Friday (correct - pay date)');
        } else {
          console.log('⚠️ End date is not Friday (expected pay date)');
        }
        
        return {
          startDate,
          endDate,
          durationDays,
          startIsSaturday: start.getDay() === 6,
          endIsFriday: end.getDay() === 5,
          durationCorrect: durationDays >= 27 && durationDays <= 29
        };
        
      } catch (error) {
        console.error('❌ Error testing date range logic:', error);
        return { error: error.message };
      }
    };

    // Function to test hours consistency between shift history and summary breakdown
    window.testHoursConsistency = async function() {
      console.log('🧪 Testing hours consistency between shift history and summary breakdown...');
      
      try {
        // Get the current date range from summary breakdown
        const fromDateInput = document.getElementById('summary-from-date');
        const toDateInput = document.getElementById('summary-to-date');
        
        if (!fromDateInput || !toDateInput) {
          console.error('❌ Summary date inputs not found');
          return;
        }
        
        const fromDate = fromDateInput.value;
        const toDate = toDateInput.value;
        
        console.log(`📅 Testing date range: ${fromDate} to ${toDate}`);
        
        // Get staff members
        const staffMembers = window.globalStaffMembers || [];
        if (staffMembers.length === 0) {
          console.error('❌ No staff members found');
          return;
        }
        
        console.log(`👥 Testing ${staffMembers.length} staff members`);
        
        const results = [];
        let allMatch = true;
        
        // Test each staff member
        for (const staff of staffMembers) {
          const staffName = staff.staff_name;
          console.log(`\n👤 Testing ${staffName}...`);
          
          // Get hours from summary breakdown (ShiftSummaryModule)
          let summaryHours = 0;
          try {
            const summaryStats = await ShiftSummaryModule.calculateSummaryStatsForDateRange(fromDate, toDate);
            const employeeStat = summaryStats.employeeStats.find(emp => emp.name === staffName);
            summaryHours = employeeStat ? employeeStat.totalHours : 0;
            console.log(`📊 Summary breakdown hours: ${summaryHours}`);
          } catch (error) {
            console.error(`❌ Error getting summary hours for ${staffName}:`, error);
          }
          
          // Get hours from shift history (direct API call)
          let historyHours = 0;
          try {
            const response = await fetch(`/api/shifts/employee/${encodeURIComponent(staffName)}?from=${fromDate}&to=${toDate}`);
            if (response.ok) {
              const shiftsData = await response.json();
              if (shiftsData.success && shiftsData.data) {
                const shifts = shiftsData.data;
                shifts.forEach(shift => {
                  const startTime = new Date(shift.shift_start_datetime);
                  const endTime = new Date(shift.shift_end_datetime);
                  const duration = (endTime - startTime) / (1000 * 60 * 60);
                  historyHours += duration;
                });
                historyHours = Math.round(historyHours * 100) / 100;
              }
            }
            console.log(`📊 Shift history hours: ${historyHours}`);
          } catch (error) {
            console.error(`❌ Error getting history hours for ${staffName}:`, error);
          }
          
          // Compare hours
          const hoursMatch = Math.abs(summaryHours - historyHours) < 0.01; // Allow for small rounding differences
          const result = {
            name: staffName,
            summaryHours,
            historyHours,
            match: hoursMatch,
            difference: Math.abs(summaryHours - historyHours)
          };
          
          results.push(result);
          
          if (hoursMatch) {
            console.log(`✅ Hours match for ${staffName}`);
          } else {
            console.log(`❌ Hours mismatch for ${staffName}: Summary=${summaryHours}, History=${historyHours}, Diff=${result.difference}`);
            allMatch = false;
          }
        }
        
        // Summary
        console.log('\n📋 CONSISTENCY TEST RESULTS:');
        console.log('================================');
        results.forEach(result => {
          const status = result.match ? '✅' : '❌';
          console.log(`${status} ${result.name}: Summary=${result.summaryHours}h, History=${result.historyHours}h, Diff=${result.difference}h`);
        });
        
        console.log('\n🎯 OVERALL RESULT:');
        if (allMatch) {
          console.log('✅ ALL HOURS MATCH - Both components show consistent data!');
        } else {
          console.log('❌ SOME HOURS MISMATCH - Components show different data');
        }
        
        return {
          allMatch,
          results,
          dateRange: { fromDate, toDate },
          totalStaff: staffMembers.length
        };
        
      } catch (error) {
        console.error('❌ Error during consistency test:', error);
        return { allMatch: false, error: error.message };
      }
    };

    // Test function to verify cumulative hours calculation
    window.testCumulativeHours = async function(employeeName = 'Helen') {
      console.log(`🧪 Testing cumulative hours calculation for ${employeeName}...`);
      const result = await calculateCumulativeHours(employeeName);
      console.log(`🧪 Result: ${result} hours`);
      return result;
    };

    // Function to calculate cumulative hours for an employee (corrected implementation)
    window.calculateCumulativeHours = async function(employeeName) {
      try {
        // Calculate cumulative hours from the beginning of the current financial year to TODAY
        // Financial year runs from April 6th to April 5th next year
        const currentDate = new Date();
        const currentYear = currentDate.getFullYear();
        
        // Determine the current financial year
        let currentFYStart, currentFYEnd;
        
        // Financial year runs from April 6th to April 5th next year
        if (currentDate.getMonth() > 3 || (currentDate.getMonth() === 3 && currentDate.getDate() >= 6)) {
          // After April 6th - we're in the current financial year
          currentFYStart = new Date(currentYear, 3, 6); // April 6th current year
          currentFYEnd = new Date(currentYear + 1, 3, 5); // April 5th next year
        } else {
          // Before April 6th - we're in the previous financial year
          currentFYStart = new Date(currentYear - 1, 3, 6); // April 6th previous year
          currentFYEnd = new Date(currentYear, 3, 5); // April 5th current year
        }
        
        // Format dates for API call
        const formatDate = (date) => {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        };
        
        const fromDateStr = formatDate(currentFYStart);
        const toDateStr = formatDate(currentDate); // FIXED: Use current date instead of FY end
        
        console.log(`📊 Calculating cumulative hours for ${employeeName} from beginning of current FY:`);
        console.log(`   Current Date: ${currentDate.toDateString()}`);
        console.log(`   Financial Year: ${currentFYStart.getFullYear()}-${currentFYEnd.getFullYear()}`);
        console.log(`   From: ${fromDateStr} (FY start) To: ${toDateStr} (today - cumulative)`);
        console.log(`   Financial Year Start: ${currentFYStart.toDateString()}`);
        console.log(`   Financial Year End: ${currentFYEnd.toDateString()}`);
        
        // Fetch shifts for the employee from the beginning of the current financial year to today
        const response = await fetch(`/api/shifts/employee/${encodeURIComponent(employeeName)}?from=${fromDateStr}&to=${toDateStr}`);
        
        if (!response.ok) {
          console.error(`❌ Failed to fetch shifts for ${employeeName}:`, response.statusText);
          return 0;
        }
        
        const shiftsData = await response.json();
        
        if (!shiftsData.success) {
          console.error(`❌ API Error for ${employeeName}:`, shiftsData.error);
          return 0;
        }
        
        const shifts = shiftsData.data || [];
        console.log(`📊 Found ${shifts.length} shifts for ${employeeName} from beginning of current FY`);
        
        if (shifts.length === 0) {
          console.log(`⚠️ No shifts found for ${employeeName} from beginning of current FY`);
          return 0;
        }
        
        // Calculate total hours
        let totalHours = 0;
        shifts.forEach((shift, index) => {
          const startTime = new Date(shift.shift_start_datetime);
          const endTime = new Date(shift.shift_end_datetime);
          const duration = (endTime - startTime) / (1000 * 60 * 60); // Convert to hours
          totalHours += duration;
          
          if (index < 5) { // Log first 5 shifts for debugging
            console.log(`📊 Shift ${index + 1}: ${shift.shift_start_datetime} to ${shift.shift_end_datetime} = ${duration.toFixed(2)} hours`);
          }
        });
        
        if (shifts.length > 5) {
          console.log(`📊 ... and ${shifts.length - 5} more shifts`);
        }
        
        console.log(`📊 Total cumulative hours for ${employeeName} from FY start: ${totalHours.toFixed(2)}`);
        return Math.round(totalHours * 100) / 100; // Round to 2 decimal places
        
      } catch (error) {
        console.error(`❌ Error calculating cumulative hours for ${employeeName}:`, error);
        return 0;
      }
    }

    // Function to update Shift Summary date range based on current period
    window.updateShiftSummaryDateRange = function() {
      try {
        const fromDateInput = document.getElementById('summary-from-date');
        const toDateInput = document.getElementById('summary-to-date');
        
        if (fromDateInput && toDateInput) {
          // Get the calculated pay date ranges for the PREVIOUS PAY PERIOD
          const startDate = getPreviousPayPeriodStartDate();
          const endDate = getPreviousPayPeriodEndDate();
          
          console.log('📅 Updating Shift Summary date range with PREVIOUS PAY PERIOD:');
          console.log('   From (day after previous period pay date):', startDate);
          console.log('   To (current period pay date):', endDate);
          
          // Set the input values
          fromDateInput.value = startDate;
          toDateInput.value = endDate;
          
          // Trigger change event to update the summary data
          fromDateInput.dispatchEvent(new Event('change'));
        }
      } catch (error) {
        console.error('❌ Error updating Shift Summary date range:', error);
      }
    }


    // Helper function to get previous pay period start date (next day after previous period's pay date) - Updated 2025-01-27
    window.getPreviousPayPeriodStartDate = function() {
      console.log('🔍 DEBUG: getPreviousPayPeriodStartDate called');
      console.log('🔍 DEBUG: currentPeriodIndex:', window.currentPeriodIndex);
      console.log('🔍 DEBUG: allPeriods length:', window.allPeriods ? window.allPeriods.length : 'undefined');
      
      // Debug: Log all periods
      if (window.allPeriods) {
        window.allPeriods.forEach((period, index) => {
          console.log(`🔍 DEBUG: Period ${index}:`, {
            period_id: period.period_id,
            title: period.title,
            firstWeekStart: period.weeks ? period.weeks[0] : 'no weeks'
          });
        });
      }
      
      // Get the previous period (1 period back)
      const previousPeriodIndex = window.currentPeriodIndex - 1;
      console.log('🔍 DEBUG: previousPeriodIndex:', previousPeriodIndex);
      
      if (previousPeriodIndex >= 0 && window.allPeriods && window.allPeriods[previousPeriodIndex]) {
        const previousPeriod = window.allPeriods[previousPeriodIndex];
        console.log('🔍 DEBUG: previousPeriod:', previousPeriod);
        
        if (previousPeriod && previousPeriod.weeks && previousPeriod.weeks.length > 0) {
          const firstWeekStart = new Date(previousPeriod.weeks[0]);
          console.log('🔍 DEBUG: previousPeriod firstWeekStart:', firstWeekStart);
          console.log('🔍 DEBUG: firstWeekStart day of week:', firstWeekStart.getDay()); // 0=Sunday, 1=Monday, etc.
          
          // Calculate the pay date (Friday of first week)
          const payDate = new Date(firstWeekStart);
          payDate.setDate(firstWeekStart.getDate() + 4); // Friday (day 4)
          console.log('🔍 DEBUG: previousPeriod payDate:', payDate);
          console.log('🔍 DEBUG: payDate day of week:', payDate.getDay()); // Should be 5 (Friday)
          
          // Return the next day after the pay date
          const nextDayAfterPayDate = new Date(payDate);
          nextDayAfterPayDate.setDate(payDate.getDate() + 1); // Next day after pay date
          console.log('🔍 DEBUG: nextDayAfterPayDate:', nextDayAfterPayDate);
          console.log('🔍 DEBUG: nextDayAfterPayDate day of week:', nextDayAfterPayDate.getDay()); // Should be 6 (Saturday)
          
          // Format date properly to avoid timezone issues
          const year = nextDayAfterPayDate.getFullYear();
          const month = String(nextDayAfterPayDate.getMonth() + 1).padStart(2, '0');
          const day = String(nextDayAfterPayDate.getDate()).padStart(2, '0');
          const formattedDate = `${year}-${month}-${day}`;
          
          console.log('🔍 DEBUG: returning previous pay period start date (day after previous pay date):', formattedDate);
          return formattedDate;
        }
      }
      
      console.log('🔍 DEBUG: Using fallback date for previous pay period start');
      // Fallback to current date minus 2 months
      const date = new Date();
      date.setMonth(date.getMonth() - 2);
      return date.toISOString().split('T')[0];
    }

    // Helper function to get previous pay period end date (current period's pay date) - Updated 2025-01-27
    window.getPreviousPayPeriodEndDate = function() {
      console.log('🔍 DEBUG: getPreviousPayPeriodEndDate called');
      console.log('🔍 DEBUG: currentPeriodIndex:', window.currentPeriodIndex);
      
      // Get the current period's pay date
      const currentPeriod = window.allPeriods && window.allPeriods[window.currentPeriodIndex];
      console.log('🔍 DEBUG: currentPeriod:', currentPeriod);
      
      if (currentPeriod && currentPeriod.weeks && currentPeriod.weeks.length > 0) {
        const firstWeekStart = new Date(currentPeriod.weeks[0]);
        console.log('🔍 DEBUG: currentPeriod firstWeekStart:', firstWeekStart);
        console.log('🔍 DEBUG: firstWeekStart day of week:', firstWeekStart.getDay()); // 0=Sunday, 1=Monday, etc.
        
        // Calculate the pay date (Friday of first week)
        const payDate = new Date(firstWeekStart);
        payDate.setDate(firstWeekStart.getDate() + 4); // Friday (day 4)
        console.log('🔍 DEBUG: currentPeriod payDate:', payDate);
        console.log('🔍 DEBUG: payDate day of week:', payDate.getDay()); // Should be 5 (Friday)
        
        // Format date properly to avoid timezone issues
        const year = payDate.getFullYear();
        const month = String(payDate.getMonth() + 1).padStart(2, '0');
        const day = String(payDate.getDate()).padStart(2, '0');
        const formattedDate = `${year}-${month}-${day}`;
        
        console.log('🔍 DEBUG: returning previous pay period end date (current period pay date):', formattedDate);
        return formattedDate;
      }
      
      console.log('🔍 DEBUG: Using fallback date for previous pay period end');
      // Fallback to current date plus 1 month
      const date = new Date();
      date.setMonth(date.getMonth() + 1);
      return date.toISOString().split('T')[0];
    }

    // Helper function to get current period start date (next day after pay date) - Updated 2025-01-27
    window.getCurrentPeriodStartDate = function() {
      console.log('🔍 DEBUG: getCurrentPeriodStartDate called');
      console.log('🔍 DEBUG: currentPeriodIndex:', window.currentPeriodIndex);
      console.log('🔍 DEBUG: allPeriods:', window.allPeriods);
      
      // Get the current period's first week Friday (pay date)
      const currentPeriod = window.allPeriods && window.allPeriods[window.currentPeriodIndex];
      console.log('🔍 DEBUG: currentPeriod:', currentPeriod);
      
      if (currentPeriod && currentPeriod.weeks && currentPeriod.weeks.length > 0) {
        const firstWeekStart = new Date(currentPeriod.weeks[0]);
        console.log('🔍 DEBUG: firstWeekStart:', firstWeekStart);
        
        const payDate = new Date(firstWeekStart);
        payDate.setDate(firstWeekStart.getDate() + 4); // Friday (day 4)
        console.log('🔍 DEBUG: payDate:', payDate);
        
        // Return the next day after the pay date
        const nextDayAfterPayDate = new Date(payDate);
        nextDayAfterPayDate.setDate(payDate.getDate() + 1); // Next day after pay date
        console.log('🔍 DEBUG: nextDayAfterPayDate:', nextDayAfterPayDate);
        
        // Format date properly to avoid timezone issues
        const year = nextDayAfterPayDate.getFullYear();
        const month = String(nextDayAfterPayDate.getMonth() + 1).padStart(2, '0');
        const day = String(nextDayAfterPayDate.getDate()).padStart(2, '0');
        const formattedDate = `${year}-${month}-${day}`;
        
        console.log('🔍 DEBUG: returning start date:', formattedDate);
        return formattedDate;
      }
      
      console.log('🔍 DEBUG: Using fallback date');
      // Fallback to current date minus 2 months
      const date = new Date();
      date.setMonth(date.getMonth() - 2);
      return date.toISOString().split('T')[0];
    }
    // Helper function to get current period end date (next pay date) - Updated 2025-01-27
    window.getCurrentPeriodEndDate = function() {
      console.log('🔍 DEBUG: getCurrentPeriodEndDate called');
      console.log('🔍 DEBUG: currentPeriodIndex:', window.currentPeriodIndex);
      
      // Get the next period's first week Friday (next pay date)
      const nextPeriodIndex = window.currentPeriodIndex + 1;
      console.log('🔍 DEBUG: nextPeriodIndex:', nextPeriodIndex);
      console.log('🔍 DEBUG: allPeriods.length:', window.allPeriods ? window.allPeriods.length : 'undefined');
      
      if (nextPeriodIndex < window.allPeriods.length) {
        const nextPeriod = window.allPeriods[nextPeriodIndex];
        console.log('🔍 DEBUG: nextPeriod:', nextPeriod);
        
        if (nextPeriod && nextPeriod.weeks && nextPeriod.weeks.length > 0) {
          const firstWeekStart = new Date(nextPeriod.weeks[0]);
          console.log('🔍 DEBUG: nextPeriod firstWeekStart:', firstWeekStart);
          
          const nextPayDate = new Date(firstWeekStart);
          nextPayDate.setDate(firstWeekStart.getDate() + 4); // Friday (day 4)
          console.log('🔍 DEBUG: nextPayDate:', nextPayDate);
          
          // Format date properly to avoid timezone issues
          const year = nextPayDate.getFullYear();
          const month = String(nextPayDate.getMonth() + 1).padStart(2, '0');
          const day = String(nextPayDate.getDate()).padStart(2, '0');
          const formattedDate = `${year}-${month}-${day}`;
          
          console.log('🔍 DEBUG: returning end date from next period:', formattedDate);
          return formattedDate;
        }
      }
      
      console.log('🔍 DEBUG: No next period, calculating 4 weeks from current pay date');
      // If no next period exists, calculate 4 weeks from current pay date
      const currentPeriod = window.allPeriods && window.allPeriods[window.currentPeriodIndex];
      if (currentPeriod && currentPeriod.weeks && currentPeriod.weeks.length > 0) {
        const firstWeekStart = new Date(currentPeriod.weeks[0]);
        const payDate = new Date(firstWeekStart);
        payDate.setDate(firstWeekStart.getDate() + 4); // Friday (day 4)
        
        // Return next pay date (4 weeks later)
        const nextPayDate = new Date(payDate);
        nextPayDate.setDate(payDate.getDate() + 28); // 4 weeks = 28 days
        
        // Format date properly to avoid timezone issues
        const year = nextPayDate.getFullYear();
        const month = String(nextPayDate.getMonth() + 1).padStart(2, '0');
        const day = String(nextPayDate.getDate()).padStart(2, '0');
        const formattedDate = `${year}-${month}-${day}`;
        
        console.log('🔍 DEBUG: returning end date from 4-week calculation:', formattedDate);
        return formattedDate;
      }
      
      console.log('🔍 DEBUG: Using fallback end date');
      // Fallback to current date plus 1 month
      const date = new Date();
      date.setMonth(date.getMonth() + 1);
      return date.toISOString().split('T')[0];
    }

    // Function to load shift history data
    async function loadShiftHistoryData(staffName, staffMember) {
      try {
        console.log('📅 Loading shift history data for:', staffName);
        
        // Get date range from inputs
        const fromDate = document.getElementById('shift-history-from-date').value;
        const toDate = document.getElementById('shift-history-to-date').value;
        
        // Try to get real shift data first
        let shiftData = [];
        
        // Check if we have access to the current shift data
        if (window.currentShiftData && Array.isArray(window.currentShiftData)) {
          console.log('📅 Found current shift data, filtering for staff member');
          shiftData = await filterCurrentShiftData(staffName, fromDate, toDate);
        }
        
        // If no real data, generate sample data
        if (shiftData.length === 0) {
          console.log('📅 No real shift data found, generating sample data');
          shiftData = generateSampleShiftData(staffName, fromDate, toDate);
        }
        
        // Update summary cards
        updateShiftSummaryCards(shiftData);
        
        // Update detailed shifts table
        updateShiftsTable(shiftData);
        
      } catch (error) {
        console.error('❌ Error loading shift history data:', error);
        document.getElementById('shifts-table-body').innerHTML = '<tr><td colspan="8" class="error-message">Error loading shift data</td></tr>';
      }
    }

    // Global cache for historical pay rates to avoid duplicate API calls
    window.historicalPayRateCache = window.historicalPayRateCache || new Map();

    // Utility function to calculate pay with multipliers based on shift flags
    function calculatePayWithMultipliers(basePayRate, hours, flags = {}) {
      let multiplier = 1.0;
      
      // Apply multipliers based on flags
      if (flags.solo_shift || flags.soloShift) {
        multiplier = Math.max(multiplier, 1.75);
      }
      
      if (flags.training || flags.short_notice || flags.shortNotice) {
        multiplier = Math.max(multiplier, 1.75);
      }
      
      if (flags.overtime) {
        multiplier = Math.max(multiplier, 2.0);
      }
      
      if (flags.call_out || flags.callout) {
        multiplier = Math.max(multiplier, 2.0);
      }
      
      const totalPay = Math.round((basePayRate * hours * multiplier) * 100) / 100;
      return {
        basePay: Math.round((basePayRate * hours) * 100) / 100,
        multiplier: multiplier,
        totalPay: totalPay,
        formattedPay: totalPay.toFixed(2)
      };
    }
    
    // Utility function to clear the historical pay rate cache
    window.clearHistoricalPayRateCache = function() {
      window.historicalPayRateCache.clear();
      console.log('🧹 Historical pay rate cache cleared');
    };

    // Test function to verify pay calculations
    window.testPayCalculations = function() {
      console.log('🧪 Testing Pay Calculations:');
      
      const baseRate = 14.24;
      const hours = 12;
      
      // Test 1: Normal shift (no flags)
      const normalPay = calculatePayWithMultipliers(baseRate, hours, {});
      console.log('Normal shift:', normalPay);
      
      // Test 2: Solo shift (1.75x multiplier)
      const soloPay = calculatePayWithMultipliers(baseRate, hours, { solo_shift: true });
      console.log('Solo shift (1.75x):', soloPay);
      
      // Test 3: Training shift (1.75x multiplier)
      const trainingPay = calculatePayWithMultipliers(baseRate, hours, { training: true });
      console.log('Training shift (1.75x):', trainingPay);
      
      // Test 4: Short notice shift (1.75x multiplier)
      const shortNoticePay = calculatePayWithMultipliers(baseRate, hours, { short_notice: true });
      console.log('Short notice shift (1.75x):', shortNoticePay);
      
      // Test 5: Overtime shift (2x multiplier)
      const overtimePay = calculatePayWithMultipliers(baseRate, hours, { overtime: true });
      console.log('Overtime shift (2x):', overtimePay);
      
      // Test 6: Multiple flags (should use highest multiplier)
      const multipleFlagsPay = calculatePayWithMultipliers(baseRate, hours, { 
        solo_shift: true, 
        training: true, 
        overtime: true 
      });
      console.log('Multiple flags (2x - highest):', multipleFlagsPay);
      
      return {
        normal: normalPay,
        solo: soloPay,
        training: trainingPay,
        shortNotice: shortNoticePay,
        overtime: overtimePay,
        multiple: multipleFlagsPay
      };
    };
    
    // Batch processor for historical pay rate requests (optimized)
    async function batchHistoricalPayRates(requests) {
      const results = new Map();
      const uncachedRequests = [];
      
      // Check cache first
      for (const request of requests) {
        const cacheKey = `${request.staffName}-${request.date}`;
        if (window.historicalPayRateCache.has(cacheKey)) {
          results.set(cacheKey, window.historicalPayRateCache.get(cacheKey));
        } else {
          uncachedRequests.push(request);
        }
      }
      
      // Process uncached requests in batches
      if (uncachedRequests.length > 0) {
        const batchSize = 10; // Process 10 requests at a time
        for (let i = 0; i < uncachedRequests.length; i += batchSize) {
          const batch = uncachedRequests.slice(i, i + batchSize);
          const batchPromises = batch.map(async (request) => {
            const cacheKey = `${request.staffName}-${request.date}`;
            
            try {
              // Always fetch historical pay rate to get the correct rate for the specific date
              const response = await fetch(`${API_BASE_URL}/staff/historical-pay`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  staff_name: request.staffName,
                  calculation_date: request.date
                })
              });
              
              if (response.ok) {
                const data = await response.json();
                const payRate = data.data?.pay_rate;
                const numericPayRate = typeof payRate === 'string' ? parseFloat(payRate) : payRate;
                
                if (typeof numericPayRate === 'number' && !isNaN(numericPayRate)) {
                  window.historicalPayRateCache.set(cacheKey, numericPayRate);
                  return { cacheKey, payRate: numericPayRate, success: true, fromCache: false };
                }
              }
              
              // Fallback to current pay rate
              let fallbackRate = 14.24; // Default to team leader rate
              if (window.globalStaffMembers && Array.isArray(window.globalStaffMembers)) {
                const staffMember = window.globalStaffMembers.find(staff => staff.staff_name === request.staffName);
                if (staffMember?.pay_rate && typeof staffMember.pay_rate === 'number' && !isNaN(staffMember.pay_rate)) {
                  fallbackRate = staffMember.pay_rate;
                } else if (staffMember?.pay_rate && typeof staffMember.pay_rate === 'string') {
                  // Handle string pay rates from database
                  fallbackRate = parseFloat(staffMember.pay_rate);
                } else if (staffMember?.role === 'team leader') {
                  fallbackRate = 14.24;
                } else {
                  fallbackRate = 13.13; // Staff member rate
                }
              }
              
              window.historicalPayRateCache.set(cacheKey, fallbackRate);
              return { cacheKey, payRate: fallbackRate, success: false, fromCache: false };
              
            } catch (error) {
              console.error(`❌ Error getting historical pay rate for ${request.staffName} on ${request.date}:`, error);
              let fallbackRate = 14.24; // Default to team leader rate
              
              if (window.globalStaffMembers && Array.isArray(window.globalStaffMembers)) {
                const staffMember = window.globalStaffMembers.find(staff => staff.staff_name === request.staffName);
                if (staffMember?.pay_rate && typeof staffMember.pay_rate === 'number' && !isNaN(staffMember.pay_rate)) {
                  fallbackRate = staffMember.pay_rate;
                } else if (staffMember?.pay_rate && typeof staffMember.pay_rate === 'string') {
                  // Handle string pay rates from database
                  fallbackRate = parseFloat(staffMember.pay_rate);
                } else if (staffMember?.role === 'team leader') {
                  fallbackRate = 14.24;
                } else {
                  fallbackRate = 13.13; // Staff member rate
                }
              }
              
              window.historicalPayRateCache.set(cacheKey, fallbackRate);
              return { cacheKey, payRate: fallbackRate, success: false, fromCache: false };
            }
          });
          
          const batchResults = await Promise.all(batchPromises);
          batchResults.forEach(result => {
            results.set(result.cacheKey, result.payRate);
          });
        }
      }
      
      return results;
    }

    // Helper function to check if there are any changes for a staff member before a specific date
    async function hasStaffChangesBeforeDate(staffName, beforeDate) {
      try {
        const response = await fetch(`${API_BASE_URL}/staff/has-changes-before-date`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            staff_name: staffName,
            before_date: beforeDate
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          return data.has_changes || false;
        }
        
        return false; // Default to no changes if API fails
      } catch (error) {
        console.warn(`⚠️ Error checking changes for ${staffName}:`, error);
        return false; // Default to no changes if API fails
      }
    }

    // Helper function to get historical pay rate for a specific date (optimized to only fetch when needed)
    async function getHistoricalPayRate(staffName, shiftDate) {
      const dateStr = shiftDate.toISOString().split('T')[0];
      const cacheKey = `${staffName}-${dateStr}`;
      
      // Check cache first
      if (window.historicalPayRateCache.has(cacheKey)) {
        return window.historicalPayRateCache.get(cacheKey);
      }
      
      // Always use historical pay calculation to get the correct rate for the specific date
      try {
        const response = await fetch(`${API_BASE_URL}/staff/historical-pay`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            staff_name: staffName,
            calculation_date: dateStr
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          const payRate = data.data?.pay_rate;
          
          // Convert to number if it's a string, or use as-is if it's already a number
          const numericPayRate = typeof payRate === 'string' ? parseFloat(payRate) : payRate;
          
          if (typeof numericPayRate === 'number' && !isNaN(numericPayRate)) {
            window.historicalPayRateCache.set(cacheKey, numericPayRate);
            console.log(`✅ Historical pay rate for ${staffName} on ${dateStr}: ${numericPayRate}`);
            return numericPayRate;
          } else {
            console.warn('⚠️ Invalid pay rate from API:', payRate);
            // Fall through to fallback logic
          }
        } else {
          console.warn(`⚠️ Failed to get historical pay rate for ${staffName} on ${dateStr}, using current pay rate as fallback`);
        }
        
        // Fallback to current pay rate if historical calculation fails
        let fallbackRate = 14.24; // Default to team leader rate
        if (window.globalStaffMembers && Array.isArray(window.globalStaffMembers)) {
          const staffMember = window.globalStaffMembers.find(staff => staff.staff_name === staffName);
          if (staffMember?.pay_rate && typeof staffMember.pay_rate === 'number' && !isNaN(staffMember.pay_rate)) {
            fallbackRate = staffMember.pay_rate;
            console.log(`✅ Using current pay rate for ${staffName}: ${fallbackRate}`);
          } else if (staffMember?.pay_rate && typeof staffMember.pay_rate === 'string') {
            // Handle string pay rates from database
            fallbackRate = parseFloat(staffMember.pay_rate);
            console.log(`✅ Using current pay rate for ${staffName} (parsed from string): ${fallbackRate}`);
          } else if (staffMember?.role === 'team leader') {
            fallbackRate = 14.24;
            console.log(`✅ Using team leader rate for ${staffName}: ${fallbackRate}`);
          } else {
            fallbackRate = 13.13; // Staff member rate
            console.log(`✅ Using staff member rate for ${staffName}: ${fallbackRate}`);
          }
        }
        
        window.historicalPayRateCache.set(cacheKey, fallbackRate);
        return fallbackRate;
      } catch (error) {
        console.error('❌ Error getting historical pay rate:', error);
        // Fallback to current pay rate
        let fallbackRate = 14.24; // Default to team leader rate
        if (window.globalStaffMembers && Array.isArray(window.globalStaffMembers)) {
          const staffMember = window.globalStaffMembers.find(staff => staff.staff_name === staffName);
          if (staffMember?.pay_rate && typeof staffMember.pay_rate === 'number' && !isNaN(staffMember.pay_rate)) {
            fallbackRate = staffMember.pay_rate;
            console.log(`✅ Using current pay rate for ${staffName} (error fallback): ${fallbackRate}`);
          } else if (staffMember?.pay_rate && typeof staffMember.pay_rate === 'string') {
            // Handle string pay rates from database
            fallbackRate = parseFloat(staffMember.pay_rate);
            console.log(`✅ Using current pay rate for ${staffName} (error fallback, parsed from string): ${fallbackRate}`);
          } else if (staffMember?.role === 'team leader') {
            fallbackRate = 14.24;
            console.log(`✅ Using team leader rate for ${staffName} (error fallback): ${fallbackRate}`);
          } else {
            fallbackRate = 13.13; // Staff member rate
            console.log(`✅ Using staff member rate for ${staffName} (error fallback): ${fallbackRate}`);
          }
        }
        
        window.historicalPayRateCache.set(cacheKey, fallbackRate);
        return fallbackRate;
      }
    }

    // Function to filter current shift data for a specific staff member
    async function filterCurrentShiftData(staffName, fromDate, toDate) {
      try {
        const startDate = new Date(fromDate);
        const endDate = new Date(toDate);
        
        const filteredShifts = window.currentShiftData.filter(shift => {
          const shiftDate = new Date(shift.date);
          return shift.staff_name === staffName && 
                 shiftDate >= startDate && 
                 shiftDate <= endDate;
        });
        
        if (filteredShifts.length === 0) return [];
        
        let weekNumber = 1;
        let currentWeek = null;
        
        // Prepare batch requests for historical pay rates
        const payRateRequests = filteredShifts.map(shift => ({
          staffName: staffName,
          date: new Date(shift.date).toISOString().split('T')[0]
        }));
        
        // Batch process all historical pay rate requests
        console.log(`📊 Batch processing ${payRateRequests.length} historical pay rate requests for current shift data`);
        const payRateResults = await batchHistoricalPayRates(payRateRequests);
        
        // Process shifts with historical pay rates
        const processedShifts = [];
        for (const shift of filteredShifts) {
          const shiftDate = new Date(shift.date);
          const weekStart = new Date(shiftDate);
          weekStart.setDate(shiftDate.getDate() - shiftDate.getDay() + 1); // Monday
          
          if (currentWeek === null || weekStart.getTime() !== currentWeek.getTime()) {
            currentWeek = weekStart;
            weekNumber++;
          }
          
          // Determine shift type from role
          let shiftType = 'Day';
          if (shift.role && shift.role.toLowerCase().includes('night')) {
            shiftType = 'Night';
          } else if (shift.role && shift.role.toLowerCase().includes('holiday')) {
            shiftType = 'Holiday';
          }
          
          // Also check if shift already has a proper shift_type from database
          if (shift.shift_type) {
            if (shift.shift_type === 'Tom Day' || shift.shift_type === 'Charlotte Day' || shift.shift_type === 'Double Up') {
              shiftType = 'Day';
            } else if (shift.shift_type === 'Tom Night' || shift.shift_type === 'Charlotte Night') {
              shiftType = 'Night';
            } else if (shift.shift_type === 'HOLIDAY') {
              shiftType = 'Holiday';
            }
          }
          
          // Get historical pay rate from batch results
          const dateStr = shiftDate.toISOString().split('T')[0];
          const cacheKey = `${staffName}-${dateStr}`;
          const historicalPayRate = payRateResults.get(cacheKey);
          
          // If no cached result, skip this shift to avoid incorrect calculations
          if (!historicalPayRate) {
            console.warn(`⚠️ No historical pay rate found for ${staffName} on ${dateStr}, skipping shift`);
            continue;
          }
          
          const hours = 12; // Default hours
          const payCalculation = calculatePayWithMultipliers(historicalPayRate, hours, {
            solo_shift: shift.solo_shift,
            training: shift.training,
            short_notice: shift.short_notice,
            overtime: shift.overtime
          });
          const pay = payCalculation.totalPay;
          
          processedShifts.push({
            week: `Week ${weekNumber}`,
            date: shiftDate.toLocaleDateString('en-GB'),
            day: shiftDate.toLocaleDateString('en-GB', { weekday: 'long' }),
            role: shift.role || staffName,
            type: shiftType,
            hours: hours,
            rate: `£${historicalPayRate.toFixed(2)}/hr`,
            pay: pay
          });
        }
        
        return processedShifts;
        
      } catch (error) {
        console.error('❌ Error filtering current shift data:', error);
        return [];
      }
    }

    // Function to generate sample shift data (replace with real data fetching)
    window.generateSampleShiftData = function(staffName, fromDate, toDate, payRate) {
      const shifts = [];
      const startDate = new Date(fromDate);
      const endDate = new Date(toDate);
      
      // Try to get real shift data first
      if (window.shiftData && window.shiftData.length > 0) {
        const staffShifts = window.shiftData.filter(shift => 
          shift.staff_name === staffName &&
          new Date(shift.date) >= startDate &&
          new Date(shift.date) <= endDate
        );
        
        if (staffShifts.length > 0) {
          let weekNumber = 1;
          let currentWeek = null;
          
          staffShifts.forEach((shift, index) => {
            const shiftDate = new Date(shift.date);
            const weekStart = new Date(shiftDate);
            weekStart.setDate(shiftDate.getDate() - shiftDate.getDay() + 1); // Monday
            
            if (currentWeek === null || weekStart.getTime() !== currentWeek.getTime()) {
              currentWeek = weekStart;
              weekNumber++;
            }
            
            // Determine shift type from role and database shift_type
            let shiftType = 'Day';
            if (shift.shift_type) {
              // Use database shift_type if available
              if (shift.shift_type === 'Tom Day' || shift.shift_type === 'Charlotte Day' || shift.shift_type === 'Double Up') {
                shiftType = 'Day';
              } else if (shift.shift_type === 'Tom Night' || shift.shift_type === 'Charlotte Night') {
                shiftType = 'Night';
              } else if (shift.shift_type === 'HOLIDAY') {
                shiftType = 'Holiday';
              }
            } else if (shift.role) {
              // Fallback to role-based detection
              if (shift.role.toLowerCase().includes('night')) {
                shiftType = 'Night';
              } else if (shift.role.toLowerCase().includes('holiday')) {
                shiftType = 'Holiday';
              }
            }
            
            const hours = 12; // Default hours
            const payCalculation = calculatePayWithMultipliers(payRate, hours, {
              solo_shift: shift.solo_shift,
              training: shift.training,
              short_notice: shift.short_notice,
              call_out: shift.call_out,
              overtime: shift.overtime
            });
            const pay = payCalculation.totalPay;
            
            shifts.push({
              week: `Week ${weekNumber}`,
              date: shiftDate.toLocaleDateString('en-GB'),
              day: shiftDate.toLocaleDateString('en-GB', { weekday: 'long' }),
              role: shift.role || staffName,
              type: shiftType,
              hours: hours,
              rate: `£${payRate.toFixed(2)}/hr`,
              pay: pay
            });
          });
          
          return shifts;
        }
      }
      
      // Fallback to generated sample data if no real data available
      let currentDate = new Date(startDate);
      let weekNumber = 1;
      
      while (currentDate <= endDate) {
        // Skip weekends for this sample
        const dayOfWeek = currentDate.getDay();
        if (dayOfWeek !== 0 && dayOfWeek !== 6) { // Not Sunday or Saturday
          const shiftType = Math.random() > 0.5 ? 'Day' : 'Night';
          const hours = 12;
          const payCalculation = calculatePayWithMultipliers(payRate, hours, {});
          const pay = payCalculation.totalPay;
          
          shifts.push({
            week: `Week ${weekNumber}`,
            date: currentDate.toLocaleDateString('en-GB'),
            day: currentDate.toLocaleDateString('en-GB', { weekday: 'long' }),
            role: staffName,
            type: shiftType,
            hours: hours,
            rate: `£${payRate.toFixed(2)}/hr`,
            pay: pay
          });
        }
        
        // Move to next day
        currentDate.setDate(currentDate.getDate() + 1);
        
        // Update week number every 7 days
        if (currentDate.getDay() === 1) { // Monday
          weekNumber++;
        }
      }
      
      return shifts;
    }

    // Function to update shift summary cards
    window.updateShiftSummaryCards = function(shiftData) {
      try {
        if (!Array.isArray(shiftData)) {
          console.error('❌ shiftData is not an array:', shiftData);
          return;
        }
        
        const totalShifts = shiftData.length;
        const dayShifts = shiftData.filter(shift => 
          shift.type === 'Day' || 
          shift.type === 'Tom Day' || 
          shift.type === 'Charlotte Day' || 
          shift.type === 'Double Up'
        ).length;
        const nightShifts = shiftData.filter(shift => 
          shift.type === 'Night' || 
          shift.type === 'Tom Night' || 
          shift.type === 'Charlotte Night'
        ).length;
        const holidayShifts = shiftData.filter(shift => 
          shift.type === 'Holiday' || 
          shift.type === 'HOLIDAY'
        ).length;
        const totalHours = shiftData.reduce((sum, shift) => sum + (shift.hours || 0), 0);
        const totalPay = Math.round(shiftData.reduce((sum, shift) => {
          try {
            let payValue = shift.pay || 0;
            
            // Handle different pay value formats
            if (typeof payValue === 'string') {
              // Remove £ symbol and parse as float
              payValue = parseFloat(payValue.replace('£', ''));
            } else if (typeof payValue === 'number') {
              // Already a number, use as is
              payValue = payValue;
            } else {
              // Fallback to 0 for unexpected types
              payValue = 0;
            }
            
            return sum + (isNaN(payValue) ? 0 : payValue);
          } catch (e) {
            console.warn('⚠️ Could not parse pay value:', shift.pay);
            return sum;
          }
        }, 0) * 100) / 100;
        
        // Update summary cards with error checking
        const elements = {
          'total-shifts-count': totalShifts,
          'day-shifts-count': dayShifts,
          'night-shifts-count': nightShifts,
          'holiday-shifts-count': holidayShifts,
          'total-hours-count': `${totalHours} hrs`,
          'total-pay-count': `£${totalPay.toFixed(2)}`
        };
        
        Object.entries(elements).forEach(([id, value]) => {
          const element = document.getElementById(id);
          if (element) {
            element.textContent = value;
          } else {
            console.warn(`⚠️ Summary card element not found: ${id}`);
          }
        });
        
      } catch (error) {
        console.error('❌ Error updating shift summary cards:', error);
      }
    }

    // Function to update shifts table
    window.updateShiftsTable = function(shiftData) {
      try {
        const tableBody = document.getElementById('shifts-table-body');
        
        if (!tableBody) {
          console.error('❌ Shifts table body not found');
          return;
        }
        
        if (!Array.isArray(shiftData)) {
          console.error('❌ shiftData is not an array:', shiftData);
          tableBody.innerHTML = '<tr><td colspan="8" class="error-message">Invalid data format</td></tr>';
          return;
        }
        
        if (shiftData.length === 0) {
          tableBody.innerHTML = '<tr><td colspan="8" class="no-shifts">No shifts found for the selected date range</td></tr>';
          return;
        }
        
        const tableHTML = shiftData.map(shift => {
          try {
            // DEBUG: Log the shift data being processed
            if (shiftData.indexOf(shift) === 0) { // Log only the first shift
              console.log('🔍 DEBUG: First shift in updateShiftsTable:', shift);
              console.log('🔍 DEBUG: Flags in processed shift:', {
                solo_shift: shift.solo_shift,
                training: shift.training,
                short_notice: shift.short_notice,
                call_out: shift.call_out,
                overtime: shift.overtime,
                payment_period_end: shift.payment_period_end,
                financial_year_end: shift.financial_year_end
              });
            }
            
            // Format flags display
            const flags = [];
            if (shift.solo_shift) flags.push('Solo');
            if (shift.training) flags.push('Training');
            if (shift.short_notice) flags.push('<12h Notice');
            if (shift.overtime) flags.push('Overtime');
            if (shift.call_out) flags.push('Call-out');
            if (shift.payment_period_end) flags.push('Period End');
            if (shift.financial_year_end) flags.push('FY End');
            
            const flagsDisplay = flags.length > 0 ? flags.join(', ') : 'None';
            
            // Calculate multiplier for display
            let multiplier = 1.0;
            if (shift.solo_shift) multiplier = Math.max(multiplier, 1.75);
            if (shift.training || shift.short_notice) multiplier = Math.max(multiplier, 1.75);
            if (shift.call_out) multiplier = Math.max(multiplier, 2.0);
            if (shift.overtime) multiplier = Math.max(multiplier, 2.0);
            
            // Ensure pay amount is properly rounded to 2 decimal places
            const payAmount = typeof shift.pay === 'number' ? shift.pay.toFixed(2) : (shift.pay || '0.00');
            const payDisplay = multiplier > 1.0 ? 
              `£${payAmount} (${multiplier}x)` : 
              `£${payAmount}`;
            
            return `
              <tr>
                <td>${shift.week || 'N/A'}</td>
                <td>${shift.date || 'N/A'}</td>
                <td>${shift.day || 'N/A'}</td>
                <td>${shift.role || 'N/A'}</td>
                <td>${shift.hours || 0} hrs</td>
                <td>${shift.rate || 'N/A'}</td>
                <td class="pay-amount">${payDisplay}</td>
                <td class="flags-cell">${flagsDisplay}</td>
              </tr>
            `;
          } catch (error) {
            console.warn('⚠️ Error processing shift row:', error, shift);
            return `
              <tr>
                <td colspan="8" class="error-message">Error processing shift data</td>
              </tr>
            `;
          }
        }).join('');
        
        tableBody.innerHTML = tableHTML;
        
      } catch (error) {
        console.error('❌ Error updating shifts table:', error);
        const tableBody = document.getElementById('shifts-table-body');
        if (tableBody) {
          tableBody.innerHTML = '<tr><td colspan="8" class="error-message">Error updating table</td></tr>';
        }
      }
    }
    // Function to export shift history data to CSV
    window.exportShiftHistory = function() {
      // Prevent multiple exports in quick succession
      if (window.isExportingShiftHistory) {
        return;
      }
      window.isExportingShiftHistory = true;

      try {
        // Get the shifts table
        const table = document.getElementById('shifts-table');
        if (!table) {
          console.warn('⚠️ Shifts table not found');
          window.isExportingShiftHistory = false;
          return;
        }

        // Get date range
        const fromDate = document.getElementById('shift-history-from-date')?.value || 'unknown';
        const toDate = document.getElementById('shift-history-to-date')?.value || 'unknown';
        
        // Get staff name from dialog header
        const headerElement = document.querySelector('.shift-history-header h3');
        const staffName = headerElement ? headerElement.textContent.replace('Shift History - ', '') : 'Unknown Staff';

        // Check if table has data
        const rows = table.querySelectorAll('tbody tr');
        if (rows.length === 0) {
          console.warn('⚠️ No shift data to export');
          window.isExportingShiftHistory = false;
          return;
        }

        // Check if it's just the loading or no data message
        const firstRow = rows[0];
        if (firstRow.querySelector('.loading-shifts') || firstRow.querySelector('.no-shifts') || firstRow.querySelector('.error-message')) {
          console.warn('⚠️ No valid shift data to export');
          window.isExportingShiftHistory = false;
          return;
        }

        let csvContent = 'data:text/csv;charset=utf-8,';
        
        // Add summary information at the top
        csvContent += 'SHIFT HISTORY SUMMARY\n';
        csvContent += `Staff Name,${staffName}\n`;
        csvContent += `Date Range,${fromDate} to ${toDate}\n`;
        csvContent += '\n';
        
        // Get summary data from the cards
        const totalShifts = document.getElementById('total-shifts-count')?.textContent || '0';
        const dayShifts = document.getElementById('day-shifts-count')?.textContent || '0';
        const nightShifts = document.getElementById('night-shifts-count')?.textContent || '0';
        const holidayShifts = document.getElementById('holiday-shifts-count')?.textContent || '0';
        const totalHours = document.getElementById('total-hours-count')?.textContent || '0 hrs';
        const totalPay = document.getElementById('total-pay-count')?.textContent || '£0.00';
        
        csvContent += 'SUMMARY METRICS\n';
        csvContent += 'Metric,Value\n';
        csvContent += `Total Shifts,${totalShifts}\n`;
        csvContent += `Day Shifts,${dayShifts}\n`;
        csvContent += `Night Shifts,${nightShifts}\n`;
        csvContent += `Holiday Shifts,${holidayShifts}\n`;
        csvContent += `Total Hours,${totalHours}\n`;
        csvContent += `Total Pay,${totalPay}\n`;
        csvContent += '\n';
        
        // Add detailed shift list header
        csvContent += 'DETAILED SHIFT LIST\n';
        csvContent += 'Week,Date,Day,Type,Hours,Rate,Pay,Flags\n';

        // Add data rows
        rows.forEach(row => {
          const cells = row.querySelectorAll('td');
          if (cells.length >= 8) {
            // Clean and format each cell
            const week = cells[0].textContent.trim();
            const date = cells[1].textContent.trim();
            const day = cells[2].textContent.trim();
            const type = cells[3].textContent.trim();
            const hours = cells[4].textContent.trim();
            const rate = cells[5].textContent.trim();
            const pay = cells[6].textContent.trim();
            const flags = cells[7].textContent.trim();
            
            const rowData = [
              `"${week}"`,
              `"${date}"`,
              `"${day}"`,
              `"${type}"`,
              `"${hours}"`,
              `"${rate}"`,
              `"${pay}"`,
              `"${flags}"`
            ];
            csvContent += rowData.join(',') + '\n';
          }
        });

        // Create and trigger download
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement('a');
        link.setAttribute('href', encodedUri);
        link.setAttribute('download', `shift_history_${staffName.replace(/\s+/g, '_')}_${fromDate}_to_${toDate}.csv`);
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        console.log('📊 Shift history data exported successfully');
        
        // Reset flag after a short delay
        setTimeout(() => {
          window.isExportingShiftHistory = false;
        }, 1000);
        
      } catch (error) {
        console.error('❌ Error exporting shift history:', error);
        window.isExportingShiftHistory = false;
      }
    };

    // Function to setup date change listeners
    window.setupShiftHistoryDateListeners = function(staffName, staffMember, payRate) {
      const fromDateInput = document.getElementById('shift-history-from-date');
      const toDateInput = document.getElementById('shift-history-to-date');
      const exportBtn = document.getElementById('export-shift-history-btn');
      
      if (fromDateInput && toDateInput) {
        fromDateInput.addEventListener('change', () => {
          loadShiftHistoryFromRotaData(staffName, staffMember);
        });
        
        toDateInput.addEventListener('change', () => {
          loadShiftHistoryFromRotaData(staffName, staffMember);
        });
      }

      if (exportBtn) {
        exportBtn.addEventListener('click', () => {
          window.exportShiftHistory();
        });
      }
    }

    // Function to show shift history from rota data (synced with rota tab)
    window.showShiftHistoryFromRota = async function(staffName, staffMember) {
      console.log('📅 showShiftHistoryFromRota called for:', staffName, staffMember);
      
      try {
        if (!staffMember) {
          console.error('❌ Staff member data not found for:', staffName);
          alert('Staff member data not found. Please refresh the page and try again.');
          return;
        }
        
        // Note: We don't calculate a single pay rate here anymore
        // Each shift will use its historical pay rate based on the role at that time
        
        // Create a dedicated shift history dialog
        const historyDialog = document.createElement('div');
        historyDialog.className = 'shift-history-dialog';
        historyDialog.innerHTML = `
          <div class="shift-history-content-dialog">
            <div class="shift-history-header">
              <h3>Shift History - ${staffName}</h3>
              <button class="close-shift-history-dialog" onclick="this.closest('.shift-history-dialog').remove()">×</button>
            </div>
            <div class="shift-history-body">
              <div class="date-range-section">
                <h4>Select Date Range</h4>
                <div class="date-inputs">
                  <div class="date-input-group">
                    <label>From:</label>
                    <input type="date" id="shift-history-from-date" class="shift-history-date-input" value="">
                  </div>
                  <div class="date-input-group">
                    <label>To:</label>
                    <input type="date" id="shift-history-to-date" class="shift-history-date-input" value="">
                  </div>
                </div>
              </div>
              
              <div class="shift-summary-section">
                <h4>Shift Summary</h4>
                <div class="shift-summary-cards">
                  <div class="summary-card">
                    <div class="summary-label">Total Shifts</div>
                    <div class="summary-value" id="total-shifts-count">0</div>
                  </div>
                  <div class="summary-card">
                    <div class="summary-label">Day Shifts</div>
                    <div class="summary-value" id="day-shifts-count">0</div>
                  </div>
                  <div class="summary-card">
                    <div class="summary-label">Night Shifts</div>
                    <div class="summary-value" id="night-shifts-count">0</div>
                  </div>
                  <div class="summary-card">
                    <div class="summary-label">Holiday Shifts</div>
                    <div class="summary-value" id="holiday-shifts-count">0</div>
                  </div>
                  <div class="summary-card">
                    <div class="summary-label">Total Hours</div>
                    <div class="summary-value" id="total-hours-count">0 hrs</div>
                  </div>
                  <div class="summary-card">
                    <div class="summary-label">Total Pay</div>
                    <div class="summary-value" id="total-pay-count">£0.00</div>
                  </div>
                </div>
              </div>
              
              <div class="detailed-shifts-section">
                <div class="shifts-section-header">
                <h4>Detailed Shift List</h4>
                  <button id="export-shift-history-btn" class="export-btn" title="Export shift history to CSV">
                    <span class="btn-icon">📊</span>
                    Export
                  </button>
                </div>
                <div class="shifts-table-container">
                  <table class="shifts-table" id="shifts-table">
                    <thead>
                      <tr>
                        <th>Week</th>
                        <th>Date</th>
                        <th>Day</th>
                        <th>Type</th>
                        <th>Hours</th>
                        <th>Rate</th>
                        <th>Pay</th>
                        <th>Flags</th>
                      </tr>
                    </thead>
                    <tbody id="shifts-table-body">
                      <tr>
                        <td colspan="8" class="loading-shifts">Loading shifts...</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        `;
        
        // Add the dialog to the page
        document.body.appendChild(historyDialog);
        
        // Set the date inputs to the same range as the overall shift summary
        const fromDateInput = document.getElementById('shift-history-from-date');
        const toDateInput = document.getElementById('shift-history-to-date');
        
        if (fromDateInput && toDateInput) {
          try {
            // Get the previous pay period date ranges (same as overall shift summary)
            const startDate = getPreviousPayPeriodStartDate();
            const endDate = getPreviousPayPeriodEndDate();
            
            console.log('📅 Setting individual shift history date range (previous pay period):');
            console.log('   From (day after previous period pay date):', startDate);
            console.log('   To (current period pay date):', endDate);
            
            // Set the input values
            fromDateInput.value = startDate;
            toDateInput.value = endDate;
            
          } catch (error) {
            console.error('❌ Error setting shift history date range:', error);
            // Fallback to default dates
            const today = new Date();
            const fromDate = new Date(today);
            fromDate.setMonth(today.getMonth() - 1);
            const toDate = new Date(today);
            toDate.setMonth(today.getMonth() + 1);
            
            fromDateInput.value = fromDate.toISOString().split('T')[0];
            toDateInput.value = toDate.toISOString().split('T')[0];
          }
        }
        
        // Load shift data from rota
        loadShiftHistoryFromRotaData(staffName, staffMember);
        
        // Add event listeners for date changes
        setupShiftHistoryDateListeners(staffName, staffMember);
      } catch (error) {
        console.error('❌ Error in showShiftHistoryFromRota:', error);
        alert('Error creating shift history dialog. Please refresh the page and try again.');
      }
    }

    // Function to update shifts table
    window.loadShiftHistoryFromRotaData = async function(staffName, staffMember) {
      try {
        console.log('📅 Loading shift history from database for:', staffName);
        
        // Get date range from inputs
        const fromDateInput = document.getElementById('shift-history-from-date');
        const toDateInput = document.getElementById('shift-history-to-date');
        
        if (!fromDateInput || !toDateInput) {
          console.error('❌ Date input elements not found');
          return;
        }
        
        const fromDate = fromDateInput.value;
        const toDate = toDateInput.value;
        
        if (!fromDate || !toDate) {
          console.error('❌ Date values not set');
          return;
        }
        
        // Get real shift data from database instead of rota data
        let shiftDataResult = await getRealShiftDataFromDatabase(staffName, fromDate, toDate);
        let shiftData = shiftDataResult.shifts || [];
        
        // Update summary cards
        updateShiftSummaryCards(shiftData);
        
        // Update detailed shifts table
        updateShiftsTable(shiftData);
        
      } catch (error) {
        console.error('❌ Error loading shift history from database:', error);
        const tableBody = document.getElementById('shifts-table-body');
        if (tableBody) {
          tableBody.innerHTML = '<tr><td colspan="8" class="error-message">Error loading shift data</td></tr>';
        }
      }
    }

    // Function to get real shift data from database
    async function getRealShiftDataFromDatabase(staffName, fromDate, toDate) {
      try {
        console.log(`📊 Fetching real shift data for ${staffName} from ${fromDate} to ${toDate}`);
        
        const response = await fetch(`/api/shifts/employee/${encodeURIComponent(staffName)}?from=${fromDate}&to=${toDate}`);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        if (!data.success) {
          throw new Error(data.error || 'Failed to fetch shift data');
        }
        
        const shifts = data.data || [];
        console.log(`📊 Found ${shifts.length} real shifts for ${staffName}`);
        
        // DEBUG: Log the first shift to see what flags are in the API response
        if (shifts.length > 0) {
          console.log('🔍 DEBUG: First shift from API:', shifts[0]);
          console.log('🔍 DEBUG: Flags in API response:', {
            solo_shift: shifts[0].solo_shift,
            training: shifts[0].training,
            short_notice: shifts[0].short_notice,
            call_out: shifts[0].call_out,
            overtime: shifts[0].overtime,
            payment_period_end: shifts[0].payment_period_end,
            financial_year_end: shifts[0].financial_year_end
          });
        }
        
        // Prepare batch requests for historical pay rates
        const payRateRequests = shifts.map(shift => ({
          staffName: staffName,
          date: new Date(shift.shift_start_datetime).toISOString().split('T')[0]
        }));
        
        // Batch process all historical pay rate requests
        console.log(`📊 Batch processing ${payRateRequests.length} historical pay rate requests for ${staffName}`);
        const payRateResults = await batchHistoricalPayRates(payRateRequests);
        
        // Process the shifts into the expected format
        const processedShifts = shifts.map((shift) => {
          const startTime = new Date(shift.shift_start_datetime);
          const endTime = new Date(shift.shift_end_datetime);
          const hours = (endTime - startTime) / (1000 * 60 * 60);
          
          // Determine shift type based on database shift_type field
          let shiftType = 'Day'; // Default fallback
          if (shift.shift_type) {
            if (shift.shift_type === 'Tom Day' || shift.shift_type === 'Charlotte Day' || shift.shift_type === 'Double Up') {
              shiftType = 'Day';
            } else if (shift.shift_type === 'Tom Night' || shift.shift_type === 'Charlotte Night') {
              shiftType = 'Night';
            } else if (shift.shift_type === 'HOLIDAY') {
              shiftType = 'Holiday';
            } else {
              // Fallback to time-based detection for unknown types
              const hour = startTime.getHours();
              shiftType = (hour >= 6 && hour < 18) ? 'Day' : 'Night';
            }
          } else {
            // Fallback to time-based detection if no shift_type
            const hour = startTime.getHours();
            shiftType = (hour >= 6 && hour < 18) ? 'Day' : 'Night';
          }
          
          // Get historical pay rate from batch results
          const dateStr = startTime.toISOString().split('T')[0];
          const cacheKey = `${staffName}-${dateStr}`;
          const historicalPayRate = payRateResults.get(cacheKey);
          
          // If no cached result, skip this shift to avoid incorrect calculations
          if (!historicalPayRate) {
            console.warn(`⚠️ No historical pay rate found for ${staffName} on ${dateStr}, skipping shift`);
            return null;
          }
          
          // Ensure historicalPayRate is a valid number
          const payRate = typeof historicalPayRate === 'number' && !isNaN(historicalPayRate) 
            ? historicalPayRate 
            : null;
            
          if (!payRate) {
            console.warn(`⚠️ Invalid historical pay rate for ${staffName} on ${dateStr}, skipping shift`);
            return null;
          }
          
          return {
            week: `Week ${shift.week_number || 'N/A'}`, // Use week_number from database
            date: startTime.toISOString().split('T')[0],
            day: startTime.toLocaleDateString('en-GB', { weekday: 'long' }),
            role: shift.shift_type || 'N/A', // Use shift_type as role information
            type: shiftType, // Use 'type' to match updateShiftSummaryCards expectations
            hours: hours,
            rate: `£${payRate.toFixed(2)}/hr`,
            pay: calculatePayWithMultipliers(payRate, hours, {
              solo_shift: shift.solo_shift,
              training: shift.training,
              short_notice: shift.short_notice,
              call_out: shift.call_out,
              overtime: shift.overtime
            }).totalPay, // Keep as number for calculations
            notes: shift.notes || '',
            // Add flags data
            solo_shift: shift.solo_shift || false,
            training: shift.training || false,
            short_notice: shift.short_notice || false,
            call_out: shift.call_out || false,
            overtime: shift.overtime || false,
            payment_period_end: shift.payment_period_end || false,
            financial_year_end: shift.financial_year_end || false
          };
        }).filter(shift => shift !== null);
        
        // Calculate totals
        const totalShifts = processedShifts.length;
        const dayShifts = processedShifts.filter(s => 
          s.type === 'Day' || 
          s.type === 'Tom Day' || 
          s.type === 'Charlotte Day' || 
          s.type === 'Double Up'
        ).length;
        const nightShifts = processedShifts.filter(s => 
          s.type === 'Night' || 
          s.type === 'Tom Night' || 
          s.type === 'Charlotte Night'
        ).length;
        const holidayShifts = processedShifts.filter(s => 
          s.type === 'Holiday' || 
          s.type === 'HOLIDAY'
        ).length;
        const totalHours = processedShifts.reduce((sum, shift) => sum + shift.hours, 0);
        const totalPay = Math.round(processedShifts.reduce((sum, shift) => sum + shift.pay, 0) * 100) / 100;
        
        return {
          shifts: processedShifts,
          totalShifts: totalShifts,
          dayShifts: dayShifts,
          nightShifts: nightShifts,
          holidayShifts: holidayShifts,
          totalHours: totalHours,
          totalPay: totalPay
        };
        
      } catch (error) {
        console.error('❌ Error fetching real shift data:', error);
        // Return empty data structure on error
        return {
          shifts: [],
          totalShifts: 0,
          dayShifts: 0,
          nightShifts: 0,
          holidayShifts: 0,
          totalHours: 0,
          totalPay: 0
        };
      }
    }

    // Function to extract shifts from rota data
    window.extractShiftsFromRota = function(staffName, fromDate, toDate, payRate) {
      const shifts = [];
      const startDate = new Date(fromDate);
      const endDate = new Date(toDate);
      
      try {
        // Check if we have rota data
        if (!window.rotaData || Object.keys(window.rotaData).length === 0) {
          console.log('📅 No rota data available, generating sample data');
          return generateSampleShiftData(staffName, fromDate, toDate, payRate);
        }
        
        console.log('📅 Extracting shifts from rota data for:', staffName);
        console.log('📅 Available rota data:', Object.keys(window.rotaData));
        
        // Get current period for week mapping
        const currentPeriod = window.allPeriods && window.allPeriods[window.currentPeriodIndex];
        if (!currentPeriod || !currentPeriod.weeks) {
          console.log('📅 No current period data, using sample data');
          return generateSampleShiftData(staffName, fromDate, toDate, payRate);
        }
        
        let weekNumber = 1;
        let currentWeek = null;
        
        // Process each week in rota data
        Object.keys(window.rotaData).forEach(weekKey => {
          const weekIndex = parseInt(weekKey.replace('week', '')) - 1;
          const weekStartDate = currentPeriod.weeks[weekIndex];
          
          if (!weekStartDate) {
            console.log(`📅 No start date for week ${weekKey}, skipping`);
            return;
          }
          
          window.rotaData[weekKey].forEach(row => {
            row.days.forEach((dayData, dayIndex) => {
              // Handle new data structure with assignments
              let staffNameInCell = '';
              if (typeof dayData === 'object' && dayData !== null && dayData.assignments) {
                // New format with detailed assignments
                staffNameInCell = dayData.displayText || '';
              } else {
                // Legacy format (just string)
                staffNameInCell = dayData || '';
              }
              
              if (staffNameInCell && staffNameInCell.trim() !== '') {
                // Check if this staff member is assigned to this shift
                const staffNames = staffNameInCell.split(',').map(name => name.trim());
                if (staffNames.includes(staffName)) {
                  // Calculate the date for this shift
                  const shiftDate = new Date(weekStartDate);
                  shiftDate.setDate(shiftDate.getDate() + dayIndex);
                  
                  // Only include shifts within the selected date range
                  if (shiftDate >= startDate && shiftDate <= endDate) {
                    // Determine shift type and hours
                    let shiftType = 'Day';
                    let hours = 12;
                    let role = row.role || 'General';
                    
                    // Check if this is a proper shift type from database
                    if (row.role) {
                      if (row.role === 'Tom Day' || row.role === 'Charlotte Day' || row.role === 'Double Up') {
                        shiftType = 'Day';
                      } else if (row.role === 'Tom Night' || row.role === 'Charlotte Night') {
                        shiftType = 'Night';
                      } else if (row.role === 'HOLIDAY') {
                        shiftType = 'Holiday';
                        hours = 0; // Holiday shifts don't count towards hours
                      } else if (row.role.toLowerCase().includes('night')) {
                        shiftType = 'Night';
                      } else if (row.role.toLowerCase().includes('holiday')) {
                        shiftType = 'Holiday';
                        hours = 0; // Holiday shifts don't count towards hours
                      }
                    }
                    
                    // Calculate pay with multipliers
                    const payCalculation = calculatePayWithMultipliers(payRate, hours, {
                      soloShift: false, // Rota data doesn't have flag information
                      training: false,
                      shortNotice: false,
                      callout: false,
                      overtime: false
                    });
                    const pay = payCalculation.totalPay;
                    
                    // Update week number
                    const weekStart = new Date(shiftDate);
                    weekStart.setDate(shiftDate.getDate() - shiftDate.getDay() + 1); // Monday
                    
                    if (currentWeek === null || weekStart.getTime() !== currentWeek.getTime()) {
                      currentWeek = weekStart;
                      weekNumber++;
                    }
                    
                    shifts.push({
                      week: `Week ${weekNumber}`,
                      date: shiftDate.toLocaleDateString('en-GB'),
                      day: shiftDate.toLocaleDateString('en-GB', { weekday: 'long' }),
                      role: role,
                      type: shiftType,
                      hours: hours,
                      rate: `£${payRate.toFixed(2)}/hr`,
                      pay: `£${pay}`
                    });
                  }
                }
              }
            });
          });
        });
        
        console.log(`📅 Extracted ${shifts.length} shifts from rota data for ${staffName}`);
        return shifts;
        
      } catch (error) {
        console.error('❌ Error extracting shifts from rota:', error);
        return generateSampleShiftData(staffName, fromDate, toDate, payRate);
      }
    }
    

    

    

    
    // Make functions globally accessible
    window.saveStaffRole = saveStaffRole;
    

    
    // Function to add a new staff member
    async function addStaffMember(staffData) {
      console.log('👤 addStaffMember called with:', staffData);
      
      if (!staffData.name || !staffData.employment_start_date) {
        console.log('❌ Missing required fields');
        alert('Please fill in all required fields');
        return;
      }
      
      const trimmedName = staffData.name.trim();
      console.log('✅ Trimmed name:', trimmedName);
      
      if (availableNames.includes(trimmedName)) {
        console.log('❌ Staff member already exists:', trimmedName);
        alert('This staff member already exists');
        return;
      }
      
      // Assign a color to the new staff member
      const defaultColors = ['#EE0000', '#FFFF00', '#00B050', '#CC99FF', '#FF66FF', '#0070C0', '#00B0F0', '#7030A0', '#C4BC96', '#FFC000'];
      const usedColors = Object.values(staffColors);
      let assignedColor = defaultColors.find(color => !usedColors.includes(color)) || '#EE0000';
      
      try {
        console.log('💾 Adding staff member to database:', staffData);
        // Add staff member to database
        const newStaff = await apiService.addStaffMember(staffData);
        
        console.log('✅ Database response:', newStaff);
        
        // Refresh data from server to get the latest information
        await forceRefreshStaffList();
        
        // Refresh holiday entitlements as new staff member needs entitlement calculation
        console.log('🏖️ New staff member added, refreshing holiday entitlements...');
        await loadHolidayEntitlements();
        
        // Update tab visibility based on new staff status
        const hasActiveStaff = window.globalStaffMembers.some(staff => staff.is_active !== false);
        updateTabVisibilityBasedOnStaff(hasActiveStaff);
        
        console.log('✅ Staff member added successfully:', newStaff);
        
        // UI updated successfully
        
      } catch (error) {
        console.error('❌ Error adding staff member:', error);
        console.error('❌ Error details:', error.message);
        alert('Failed to add staff member. Please try again.');
      }
    }
    
    // Function to delete a staff member
    async function deleteStaffMember(name) {
      console.log('🗑️ deleteStaffMember called for:', name);
      
      try {
        // Create a custom confirmation dialog
        const confirmDialog = document.createElement('div');
        confirmDialog.className = 'delete-confirmation-dialog';
        confirmDialog.innerHTML = `
          <div class="delete-confirmation-content">
            <div class="delete-confirmation-header">
              <span class="delete-confirmation-icon">⚠️</span>
              <h3>Delete Staff Member</h3>
            </div>
            <div class="delete-confirmation-message">
              Are you sure you want to delete <strong>"${name}"</strong>?
            </div>
            <div class="delete-confirmation-warning">
              This will permanently remove them from all assignments and cannot be undone.
            </div>
            <div class="delete-confirmation-buttons">
              <button class="delete-confirm-btn" onclick="confirmDeleteStaff('${name}')">Delete Permanently</button>
              <button class="delete-cancel-btn" onclick="closeDeleteDialog()">Cancel</button>
            </div>
          </div>
        `;
        
        document.body.appendChild(confirmDialog);
        console.log('✅ Delete confirmation dialog created and added to DOM');
        
        // Add fade-in effect
        setTimeout(() => {
          confirmDialog.style.opacity = '1';
          confirmDialog.style.transform = 'scale(1)';
          console.log('✅ Delete confirmation dialog fade-in effect applied');
        }, 10);
        
      } catch (error) {
        console.error('❌ Error creating delete confirmation dialog:', error);
        alert('Error creating delete confirmation dialog. Please try again.');
      }
    }
    // Function to confirm staff deletion
    async function confirmDeleteStaff(name) {
      try {
        console.log('🗑️ Starting deletion process for:', name);
        
          // Find staff member in database
          const staffMembers = await apiService.getStaffMembers();
          const staffMember = staffMembers.find(s => s.staff_name === name);
          
          if (staffMember) {
          console.log('✅ Found staff member in database:', staffMember);
          
            // Delete from database
            await apiService.deleteStaffMember(staffMember.unique_id);
            console.log('✅ Staff member deleted from database');
        } else {
          console.log('⚠️ Staff member not found in database, proceeding with UI cleanup');
          }
          
          // Remove from available names
          const index = availableNames.indexOf(name);
          if (index > -1) {
            availableNames.splice(index, 1);
          console.log('✅ Removed from availableNames');
          }
          
          // Remove from color mapping
        if (staffColors[name]) {
          delete staffColors[name];
          console.log('✅ Removed from staffColors');
        }
          
          // Remove from all rota assignments
        let assignmentsCleaned = 0;
          Object.keys(rotaData).forEach(weekKey => {
          if (rotaData[weekKey] && Array.isArray(rotaData[weekKey])) {
            rotaData[weekKey].forEach(row => {
              if (row && row.days && Array.isArray(row.days)) {
                row.days = row.days.map(day => {
                  if (day === name) {
                    assignmentsCleaned++;
                    return '';
                  }
                  return day;
                });
              }
            });
          }
        });
        console.log(`✅ Cleaned ${assignmentsCleaned} rota assignments`);
          
          // Remove custom colors for cells that had this staff member
        let colorsCleaned = 0;
          Object.keys(customCellColors).forEach(cellKey => {
            // This is a simplified cleanup - in a more complex system you might want to track which cells had which staff members
          colorsCleaned++;
          });
        console.log(`✅ Cleaned ${colorsCleaned} custom cell colors`);
          
        // Refresh data from server to get the latest information
        console.log('🔄 Refreshing staff list from server...');
        await forceRefreshStaffList();
        
        // Update tab visibility based on remaining staff status
        const hasActiveStaff = window.globalStaffMembers.some(staff => staff.is_active !== false);
        updateTabVisibilityBasedOnStaff(hasActiveStaff);
        
        console.log('🔄 Regenerating tables...');
          regenerateTables();
          
          // UI updated successfully
        console.log('✅ UI updated successfully');
          

        
        // Close the dialog
        closeDeleteDialog();
        
        // Show success message
        showDeleteSuccessMessage(name);
        
        console.log('🎉 Staff deletion completed successfully!');
        
        } catch (error) {
          console.error('❌ Error deleting staff member:', error);
        console.error('Error details:', {
          name,
          error: error.message,
          stack: error.stack
        });
        alert(`Failed to delete staff member "${name}". Error: ${error.message}`);
        closeDeleteDialog();
      }
    }
    
    // Function to close delete confirmation dialog
    function closeDeleteDialog() {
      console.log('🔄 closeDeleteDialog called');
      
      try {
        const dialog = document.querySelector('.delete-confirmation-dialog');
        if (dialog) {
          console.log('✅ Found delete confirmation dialog, closing...');
          dialog.style.opacity = '0';
          dialog.style.transform = 'scale(0.9)';
          setTimeout(() => {
            dialog.remove();
            console.log('✅ Delete confirmation dialog removed from DOM');
          }, 200);
        } else {
          console.log('⚠️ No delete confirmation dialog found to close');
        }
      } catch (error) {
        console.error('❌ Error closing delete confirmation dialog:', error);
        // Try to force remove any remaining dialogs
        const remainingDialogs = document.querySelectorAll('.delete-confirmation-dialog');
        remainingDialogs.forEach(dialog => dialog.remove());
        console.log('🔄 Force removed remaining dialogs');
      }
    }
    
    // Function to show delete success message
    function showDeleteSuccessMessage(name) {
      const successMsg = document.createElement('div');
      successMsg.className = 'delete-success-message';
      successMsg.innerHTML = `
        <span class="success-icon">✅</span>
        <span class="success-text">Staff member "${name}" has been deleted successfully!</span>
      `;
      document.body.appendChild(successMsg);
      
      // Add fade-in effect
      setTimeout(() => {
        successMsg.style.opacity = '1';
        successMsg.style.transform = 'translateY(0)';
      }, 10);
      
      // Remove after 3 seconds
      setTimeout(() => {
        successMsg.style.opacity = '0';
        successMsg.style.transform = 'translateY(-20px)';
        setTimeout(() => {
          successMsg.remove();
        }, 200);
      }, 3000);
    }
    

    
    // Make functions globally accessible for HTML onclick handlers
    window.confirmDeleteStaff = confirmDeleteStaff;
    window.closeDeleteDialog = closeDeleteDialog;
    window.enableMultiSelectMode = enableMultiSelectMode;
    window.disableMultiSelectMode = disableMultiSelectMode;
    window.bulkDeleteSelectedCells = bulkDeleteSelectedCells;
    

    
    // Function to regenerate all tables
    async function regenerateTables() {
      const container = document.getElementById('tables-container');
      container.innerHTML = '';
      generateTables();
      await displayEmployeeSummaries();
    }
    
    // Get current period's start dates
    function getCurrentStartDates() {
      console.log('🔍 getCurrentStartDates called');
      console.log('🔍 currentPeriodIndex:', currentPeriodIndex);
      console.log('🔍 allPeriods length:', allPeriods.length);
      console.log('🔍 allPeriods:', allPeriods);
      
      if (!allPeriods || allPeriods.length === 0) {
        console.error('❌ No periods available');
        return [];
      }
      
      if (currentPeriodIndex < 0 || currentPeriodIndex >= allPeriods.length) {
        console.error(`❌ Invalid currentPeriodIndex: ${currentPeriodIndex}, valid range: 0-${allPeriods.length - 1}`);
        return [];
      }
      
      const currentPeriod = allPeriods[currentPeriodIndex];
      console.log('🔍 Current period:', currentPeriod);
      console.log('🔍 Current period weeks:', currentPeriod.weeks);
      
      // Log each week date in detail
      currentPeriod.weeks.forEach((weekDate, index) => {
        console.log(`🔍 Week ${index + 1}: ${weekDate.toISOString()} (${weekDate.toLocaleDateString('en-GB')})`);
      });
      
      // Return the weeks array directly since they're already calculated as Mondays
      return currentPeriod.weeks;
    }

    // Function to sync rotaData with current period
    function syncRotaDataWithCurrentPeriod() {
      console.log('🔄 Syncing rotaData with current period...');
      
      if (!allPeriods || allPeriods.length === 0) {
        console.error('❌ No periods available for syncing');
        return;
      }
      
      if (currentPeriodIndex < 0 || currentPeriodIndex >= allPeriods.length) {
        console.error(`❌ Invalid currentPeriodIndex: ${currentPeriodIndex} for syncing`);
        return;
      }
      
      const currentPeriod = allPeriods[currentPeriodIndex];
      console.log('🔍 Syncing with period:', currentPeriod.title);
      
      // Clear existing rotaData
      window.rotaData = {};
      
      // Create new week entries based on current period
      currentPeriod.weeks.forEach((weekStart, weekIndex) => {
        const weekKey = `week${weekIndex + 1}`;
        window.rotaData[weekKey] = JSON.parse(JSON.stringify(emptyWeekData));
        console.log(`✅ Created ${weekKey} for week starting ${weekStart.toLocaleDateString()} (${weekStart.toISOString()})`);
      });
      
      console.log('🔍 Final rotaData structure:');
      Object.keys(window.rotaData).forEach(weekKey => {
        console.log(`   ${weekKey}: ${window.rotaData[weekKey].length} rows`);
      });
      
      console.log('✅ RotaData synced with current period');
      console.log('📊 Available weeks:', Object.keys(window.rotaData));
    }

    let currentDropdown = null;


    async function createDropdown(cell, weekIndex, rowIndex, dayIndex) {
      console.log('🔧 createDropdown called with:', { cell, weekIndex, rowIndex, dayIndex });
      // Remove existing dropdown
      if (currentDropdown) {
        currentDropdown.remove();
      }

      // Get role information
      const weekKey = `week${weekIndex + 1}`;
      const roleData = window.rotaData[weekKey][rowIndex];
      const roleName = roleData.role;
      
      // Store current role name globally for use in createAssignmentRow
      window.currentRoleName = roleName;

      // Determine default times based on role
      let defaultStartTime = '08:00';
      let defaultEndTime = '20:00';
      
      if (roleName.toLowerCase().includes('night')) {
        defaultStartTime = '20:00';
        defaultEndTime = '08:00';
      } else if (roleName.toLowerCase().includes('holiday')) {
        defaultStartTime = '08:00';
        defaultEndTime = '20:00';
      }

      // Get current cell content and parse staff assignments
      const currentContent = cell.textContent.trim();
      // Use global assignments variable or create new one
      if (!window.currentAssignments) {
        window.currentAssignments = [];
      }
      // Always work with the global assignments array
      window.currentAssignments = window.currentAssignments || [];
      
      if (currentContent) {
        // Try to get actual assignments from cell dataset first
        if (cell.dataset.assignments) {
          try {
            window.currentAssignments = JSON.parse(cell.dataset.assignments);
            console.log('✅ Found assignments in cell dataset:', window.currentAssignments);
            
              
              // Ensure all assignments have flag properties and preserve shiftId
              window.currentAssignments = window.currentAssignments.map(assignment => ({
                ...assignment,
                shiftId: assignment.shiftId, // Explicitly preserve shiftId
                soloShift: assignment.soloShift !== undefined ? assignment.soloShift : false,
                training: assignment.training !== undefined ? assignment.training : false,
                shortNotice: assignment.shortNotice !== undefined ? assignment.shortNotice : false,
                callout: assignment.callout !== undefined ? assignment.callout : false,
                overtime: assignment.overtime !== undefined ? assignment.overtime : false,
                notes: assignment.notes || ''
              }));
              console.log('✅ Ensured flag properties for assignments:', window.currentAssignments);
              console.log('✅ Each assignment flag details:', window.currentAssignments.map(a => ({
                staffName: a.staffName,
                shiftId: a.shiftId,
                soloShift: a.soloShift,
                training: a.training,
                shortNotice: a.shortNotice,
                callout: a.callout,
                overtime: a.overtime
              })));
          } catch (error) {
            console.warn('⚠️ Failed to parse assignments from cell dataset:', error);
            // Fall back to parsing from text content
            const staffNames = currentContent.split(',').map(name => name.trim());
            
            // Try to get actual times from database for these staff members
            const currentPeriod = allPeriods[currentPeriodIndex];
            if (currentPeriod) {
              // Calculate the shift date
              const shiftDate = new Date(currentPeriod.weeks[weekIndex]);
              shiftDate.setDate(shiftDate.getDate() + dayIndex);
              const shiftDateString = shiftDate.toISOString().split('T')[0];
              
              // Try to fetch actual shift data for this date and staff
              try {
                const shifts = await apiService.getShiftsForPeriod(currentPeriod.period_id);
                const relevantShifts = shifts.filter(shift => {
                  const shiftDate = new Date(shift.shift_start_datetime);
                  const shiftDateStr = shiftDate.toISOString().split('T')[0];
                  return shiftDateStr === shiftDateString && staffNames.includes(shift.staff_name);
                });
                
                window.currentAssignments = staffNames.map(name => {
                  const actualShift = relevantShifts.find(shift => shift.staff_name === name);
                  if (actualShift) {
                    // Use actual times from database
                    const shiftStart = new Date(actualShift.shift_start_datetime);
                    const shiftEnd = new Date(actualShift.shift_end_datetime);
                    const startTime = shiftStart.toTimeString().substring(0, 5);
                    const endTime = shiftEnd.toTimeString().substring(0, 5);
                    
                    console.log(`🕐 Found actual times for ${name}: ${startTime} to ${endTime}`);
                    
                    return {
                      staffName: name,
                      startTime: startTime,
                      endTime: endTime,
                      shiftId: actualShift.shift_id,
                      periodId: actualShift.period_id,
                      soloShift: actualShift.solo_shift || false,
                      training: actualShift.training || false,
                      shortNotice: actualShift.short_notice || false,
                      callout: actualShift.call_out || false,
                      overtime: actualShift.overtime || false,
                      notes: actualShift.notes || ''
                    };
                  } else {
                    // Fall back to default times
                    console.log(`⚠️ No database record found for ${name}, using default times`);
                    return {
                      staffName: name,
                      startTime: defaultStartTime,
                      endTime: defaultEndTime,
                      shiftId: null,
                      periodId: null,
                      soloShift: false,
                      training: false,
                      shortNotice: false,
                      callout: false,
                      overtime: false,
                      paymentPeriodEnd: false,
                      financialYearEnd: false,
                      notes: ''
                    };
                  }
                });
              } catch (fetchError) {
                console.warn('⚠️ Failed to fetch actual times from database:', fetchError);
                // Fall back to default times
                window.currentAssignments = staffNames.map(name => ({
                  staffName: name,
                  startTime: defaultStartTime,
                  endTime: defaultEndTime,
                  shiftId: null,
                  periodId: null,
                  soloShift: false,
                  training: false,
                  shortNotice: false,
                  callout: false,
                  overtime: false,
                  paymentPeriodEnd: false,
                  financialYearEnd: false,
                  notes: ''
                }));
              }
            } else {
              // No current period, use default times
              window.currentAssignments = staffNames.map(name => ({
                staffName: name,
                startTime: defaultStartTime,
                endTime: defaultEndTime,
                shiftId: null,
                periodId: null,
                soloShift: false,
                training: false,
                shortNotice: false,
                callout: false,
                overtime: false,
                paymentPeriodEnd: false,
                financialYearEnd: false,
                notes: ''
              }));
            }
          }
        } else {
          // Fall back to parsing from text content (legacy support)
            const staffNames = currentContent.split(',').map(name => name.trim());
            window.currentAssignments = staffNames.map(name => ({
              staffName: name,
              startTime: defaultStartTime,
              endTime: defaultEndTime,
              shiftId: null,
              periodId: null,
              soloShift: false,
              training: false,
              shortNotice: false,
              callout: false,
              overtime: false,
              paymentPeriodEnd: false,
              financialYearEnd: false,
              notes: ''
            }));
          }
        } else {
          // Start with one empty assignment
          window.currentAssignments = [{
            staffName: '',
            startTime: defaultStartTime,
            endTime: defaultEndTime,
            shiftId: null,
            periodId: null,
            soloShift: false,
            training: false,
            shortNotice: false,
            callout: false,
            overtime: false,
            paymentPeriodEnd: false,
            financialYearEnd: false,
            notes: ''
          }];
            console.log('📋 Created initial empty assignment with flags:', window.currentAssignments[0]);
        }
      
      // Store the original assignments for comparison when saving
      const originalAssignments = JSON.parse(JSON.stringify(window.currentAssignments));
        console.log('📋 Final assignments array before popup creation:', window.currentAssignments);
        console.log('📋 Original assignments for comparison:', originalAssignments);
        
        // Debug: Log each assignment's flag properties
        window.currentAssignments.forEach((assignment, index) => {
          console.log(`📋 Assignment ${index}:`, {
            staffName: assignment.staffName,
            soloShift: assignment.soloShift,
            training: assignment.training,
            shortNotice: assignment.shortNotice,
            overtime: assignment.overtime
          });
        });

      // Create popup
      const popup = document.createElement('div');
      popup.id = 'assign-staff-popup';
      popup.className = 'cell-popup';
      
      console.log('🔴 Popup created with ID:', popup.id);
      popup.style.cssText = `
        position: fixed;
        background: white;
        border: 3px solid #007bff;
        border-radius: 12px;
        padding: 0;
        box-shadow: 0 12px 40px rgba(0,123,255,0.3), 0 8px 32px rgba(0,0,0,0.25);
        z-index: 10001;
        min-width: 380px;
        max-width: 420px;
        max-height: 80vh;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        overflow: hidden;
        animation: popupSlideIn 0.3s ease-out;
        outline: 2px solid rgba(0,123,255,0.2);
        outline-offset: 2px;
      `;

      // Position popup with improved visibility
      const rect = cell.getBoundingClientRect();
      const popupWidth = 380;
      const popupHeight = 400;
      
      console.log('📍 Cell positioning debug:', {
        cellRect: rect,
        windowWidth: window.innerWidth,
        windowHeight: window.innerHeight,
        popupWidth: popupWidth,
        popupHeight: popupHeight
      });
      
      // Center the popup on screen initially for better visibility
      let left = (window.innerWidth - popupWidth) / 2;
      let top = (window.innerHeight - popupHeight) / 2;
      
      // Ensure popup is within viewport bounds
      if (left < 10) left = 10;
      if (top < 10) top = 10;
      if (left + popupWidth > window.innerWidth - 10) left = window.innerWidth - popupWidth - 10;
      if (top + popupHeight > window.innerHeight - 10) top = window.innerHeight - popupHeight - 10;
      
      // Additional positioning logic for better visibility
      // If popup is still too tall for the available space, reduce its height
      const availableHeight = window.innerHeight - top;
      if (availableHeight < popupHeight) {
        popup.style.maxHeight = (availableHeight - 20) + 'px';
        console.log('📍 Adjusted popup height to fit screen:', availableHeight - 20);
      }
      
      // If popup is too wide for the available space, reduce its width
      const availableWidth = window.innerWidth - left;
      if (availableWidth < popupWidth) {
        popup.style.minWidth = (availableWidth - 20) + 'px';
        popup.style.maxWidth = (availableWidth - 20) + 'px';
        console.log('📍 Adjusted popup width to fit screen:', availableWidth - 20);
      }
      
      console.log('📍 Final popup position:', { left, top, isVisible: true, availableHeight, availableWidth });
      
      popup.style.left = left + 'px';
      popup.style.top = top + 'px';

      // Check if this is a holiday cell
      const isHolidayCell = roleName && roleName.toLowerCase().includes('holiday');
      
      // Popup content
      popup.innerHTML = `
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px;">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
            <h3 style="margin: 0; font-size: 18px; font-weight: 600;">Assign Staff</h3>
            <button id="close-popup" style="background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; color: white; font-size: 24px; cursor: pointer; padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; transition: all 0.2s; font-weight: bold;">×</button>
          </div>
          <p style="margin: 0; opacity: 0.9; font-size: 14px;">${roleName}</p>
        </div>
        
        <div style="padding: 20px; max-height: 60vh; overflow-y: auto;">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
            <div>
              <span style="font-size: 13px; color: #666;">Total Hours</span>
              <div style="font-size: 20px; font-weight: 600; color: #333;" id="total-hours-display">0</div>
            </div>
            <div style="text-align: center;">
              <span style="font-size: 13px; color: #666;">Staff Count</span>
              <div style="font-size: 20px; font-weight: 600; color: #333;" id="staff-count-display">0</div>
            </div>
            <div style="text-align: center;">
              <span style="font-size: 13px; color: #666;">Avg Hours</span>
              <div style="font-size: 20px; font-weight: 600; color: #333;" id="avg-hours-display">0</div>
            </div>
          </div>
          
          <!-- Active Flags Summary -->
          <div id="active-flags-summary" style="margin-bottom: 15px; padding: 12px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #28a745; display: none;">
            <div style="font-size: 12px; color: #666; margin-bottom: 6px; font-weight: 600;">Active Flags:</div>
            <div id="active-flags-content" style="display: flex; gap: 8px; flex-wrap: wrap;"></div>
          </div>
          

          
          <div id="staff-assignments-container" style="margin-bottom: 15px;">
            <!-- Assignment items will be added here dynamically -->
          </div>

          <div style="display: flex; gap: 8px; margin-bottom: 15px;">
            <button id="popup-add-staff-btn" style="flex: 1; padding: 10px; background: #f8f9fa; border: 2px dashed #ddd; border-radius: 6px; cursor: pointer; font-size: 13px; color: #666; transition: all 0.2s;">
              <span style="font-size: 18px; margin-right: 8px;">+</span> Add Staff Member
            </button>
          </div>

          <div style="display: flex; gap: 10px; justify-content: flex-end;">
            <button id="cancel-btn" style="padding: 8px 14px; background: #6c757d; color: white; border: none; border-radius: 5px; font-size: 13px; cursor: pointer; transition: background 0.2s;">Cancel</button>
            <button id="save-btn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 5px; font-size: 14px; font-weight: 600; cursor: pointer; transition: background 0.2s;">Save Assignment</button>
          </div>
          

        </div>
      `;

      document.body.appendChild(popup);
      currentDropdown = popup;
      
      // Add click event listener to popup to prevent event bubbling (allow default so inputs work)
      popup.addEventListener('click', function(e) {
        console.log('🔍 Popup clicked, preventing event bubbling');
        e.stopPropagation();
        // Do NOT call preventDefault here; it blocks checkbox toggling and other native input behavior
      });
      
      // Also add mousedown and mouseup event listeners to ensure all interactions are captured
      popup.addEventListener('mousedown', function(e) {
        console.log('🔍 Popup mousedown, preventing event bubbling');
        e.stopPropagation();
      });
      
      popup.addEventListener('mouseup', function(e) {
        console.log('🔍 Popup mouseup, preventing event bubbling');
        e.stopPropagation();
      });
      
      // Add window resize listener to reposition popup if needed
      const resizeHandler = () => {
        const newRect = cell.getBoundingClientRect();
        let newLeft = left;
        let newTop = top;
        
        // Recalculate position if window size changed significantly
        if (left + popupWidth > window.innerWidth) {
          newLeft = newRect.left - popupWidth - 10;
          if (newLeft < 0) newLeft = 10;
        }
        if (top + popupHeight > window.innerHeight) {
          newTop = newRect.top - popupHeight - 10;
          if (newTop < 0) newTop = 10;
        }
        
        if (newLeft !== left || newTop !== top) {
          popup.style.left = newLeft + 'px';
          popup.style.top = newTop + 'px';
          console.log('📍 Repositioned popup due to window resize:', { newLeft, newTop });
        }
      };
      
      // Add scroll listener to keep popup visible during scrolling
      const scrollHandler = () => {
        const newRect = cell.getBoundingClientRect();
        let newLeft = left;
        let newTop = top;
        
        // Adjust position based on new cell position
        if (left === rect.right + 10) { // If popup was positioned to the right
          newLeft = newRect.right + 10;
        } else if (left === rect.left - popupWidth - 10) { // If popup was positioned to the left
          newLeft = newRect.left - popupWidth - 10;
        }
        
        if (top === rect.top) { // If popup was positioned at cell top
          newTop = newRect.top;
        }
        
        // Ensure popup stays within viewport
        if (newLeft < 0) newLeft = 10;
        if (newTop < 0) newTop = 10;
        if (newLeft + popupWidth > window.innerWidth) {
          newLeft = window.innerWidth - popupWidth - 10;
        }
        if (newTop + popupHeight > window.innerHeight) {
          newTop = window.innerHeight - popupHeight - 10;
        }
        
        if (newLeft !== left || newTop !== top) {
          popup.style.left = newLeft + 'px';
          popup.style.top = newTop + 'px';
          console.log('📍 Repositioned popup due to scroll:', { newLeft, newTop });
        }
      };
      
      window.addEventListener('resize', resizeHandler);
      window.addEventListener('scroll', scrollHandler);
      
      // Store the handlers for cleanup
      popup.dataset.resizeHandler = resizeHandler;
      popup.dataset.scrollHandler = scrollHandler;
      
      // Add keyboard event listener for Escape key
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          console.log('🔴 Escape key pressed, closing popup...');
          closePopupCompletely();
          document.removeEventListener('keydown', escapeHandler);
        }
      };
      document.addEventListener('keydown', escapeHandler);
      popup.dataset.escapeHandler = escapeHandler;
      
      // Also add a global escape handler as backup
      const globalEscapeHandler = (e) => {
        if (e.key === 'Escape') {
          console.log('🔴 Global escape key pressed, closing any popup...');
          window.closePopupCompletely();
        }
      };
      document.addEventListener('keydown', globalEscapeHandler);
      popup.dataset.globalEscapeHandler = globalEscapeHandler;
      

      
      console.log('🔴 Event handlers attached to popup:', {
        resizeHandler: !!popup.dataset.resizeHandler,
        scrollHandler: !!popup.dataset.scrollHandler,
        escapeHandler: !!popup.dataset.escapeHandler,
        visibilityInterval: !!popup.dataset.visibilityInterval
      });
      
      // Function to ensure popup is always visible
      function ensurePopupVisibility() {
        const popupRect = popup.getBoundingClientRect();
        let needsReposition = false;
        let newLeft = left;
        let newTop = top;
        
        // Check if popup is off-screen
        if (popupRect.left < 0) {
          newLeft = 10;
          needsReposition = true;
        }
        if (popupRect.top < 0) {
          newTop = 10;
          needsReposition = true;
        }
        if (popupRect.right > window.innerWidth) {
          newLeft = window.innerWidth - popupWidth - 10;
          needsReposition = true;
        }
        if (popupRect.bottom > window.innerHeight) {
          newTop = window.innerHeight - popupHeight - 10;
          needsReposition = true;
        }
        
        if (needsReposition) {
          popup.style.left = newLeft + 'px';
          popup.style.top = newTop + 'px';
          console.log('📍 Repositioned popup for visibility:', { newLeft, newTop });
        }
      }
      
      // Call visibility check after a short delay to ensure DOM is ready
      setTimeout(ensurePopupVisibility, 100);
      
      // Set up periodic visibility check to ensure popup stays visible
      const visibilityCheckInterval = setInterval(() => {
        if (popup && popup.parentNode) {
          ensurePopupVisibility();
        } else {
          clearInterval(visibilityCheckInterval);
        }
      }, 1000);
      
      // Store the interval for cleanup
      popup.dataset.visibilityInterval = visibilityCheckInterval;
      
      // Add a visual indicator that the popup is active
      popup.style.animation = 'popupSlideIn 0.3s ease-out, popupPulse 2s ease-in-out infinite';
      
      // Function to find the best position for the popup
      function findBestPosition() {
        const positions = [
          { left: rect.right + 10, top: rect.top }, // Right of cell
          { left: rect.left - popupWidth - 10, top: rect.top }, // Left of cell
          { left: rect.left, top: rect.bottom + 10 }, // Below cell
          { left: rect.left, top: rect.top - popupHeight - 10 }, // Above cell
          { left: 10, top: 10 }, // Top-left corner
          { left: window.innerWidth - popupWidth - 10, top: 10 }, // Top-right corner
          { left: 10, top: window.innerHeight - popupHeight - 10 }, // Bottom-left corner
          { left: window.innerWidth - popupWidth - 10, top: window.innerHeight - popupHeight - 10 } // Bottom-right corner
        ];
        
        // Find the first position that keeps the popup fully visible
        for (const pos of positions) {
          if (pos.left >= 0 && pos.left + popupWidth <= window.innerWidth &&
              pos.top >= 0 && pos.top + popupHeight <= window.innerHeight) {
            return pos;
          }
        }
        
        // If no perfect position found, return the most visible one
        return positions[0];
      }
      
      // Apply the best position
      const bestPosition = findBestPosition();
      if (bestPosition.left !== left || bestPosition.top !== top) {
        left = bestPosition.left;
        top = bestPosition.top;
        popup.style.left = left + 'px';
        popup.style.top = top + 'px';
        console.log('📍 Applied best position:', bestPosition);
      }
      // Function to update displays
      function updateDisplays() {
        const totalHoursElement = document.getElementById('total-hours-display');
        const staffCountElement = document.getElementById('staff-count-display');
        const avgHoursElement = document.getElementById('avg-hours-display');
        
        if (totalHoursElement && staffCountElement && avgHoursElement) {
          const validAssignments = window.currentAssignments.filter(a => a.staffName);
          const totalHours = validAssignments.reduce((sum, assignment) => {
            const startTime = new Date(`2000-01-01T${assignment.startTime}`);
            const endTime = new Date(`2000-01-01T${assignment.endTime}`);
            if (endTime < startTime) {
              endTime.setDate(endTime.getDate() + 1);
            }
            const hours = Math.round((endTime - startTime) / (1000 * 60 * 60));
            return sum + hours;
          }, 0);
          
          const avgHours = validAssignments.length > 0 ? Math.round(totalHours / validAssignments.length) : 0;
          
          totalHoursElement.textContent = totalHours;
          staffCountElement.textContent = validAssignments.length;
          avgHoursElement.textContent = avgHours;
        }
        
        // Update active flags summary
        updateActiveFlagsSummary();
      }

      // Function to update active flags summary
      function updateActiveFlagsSummary() {
        const activeFlagsSummary = document.getElementById('active-flags-summary');
        const activeFlagsContent = document.getElementById('active-flags-content');
        
        if (!activeFlagsSummary || !activeFlagsContent) return;
        
        // Skip flag processing for holiday cells
        const isHolidayCell = window.currentRoleName && window.currentRoleName.toLowerCase().includes('holiday');
        if (isHolidayCell) {
          activeFlagsSummary.style.display = 'none';
          return;
        }
        
        const validAssignments = window.currentAssignments.filter(a => a.staffName);
        const activeFlags = [];
        
        // Collect all active flags from assignments
        validAssignments.forEach(assignment => {
                  if (assignment.soloShift) activeFlags.push({ type: 'solo-shift', label: 'Solo Shift', color: '#ff6b35' });
        if (assignment.training) activeFlags.push({ type: 'training', label: 'Training', color: '#4ecdc4' });
        if (assignment.shortNotice) activeFlags.push({ type: 'short-notice', label: '<12h Notice', color: '#ff6b6b' });
        if (assignment.overtime) activeFlags.push({ type: 'overtime', label: 'Overtime', color: '#9b59b6' });
        if (assignment.callout) activeFlags.push({ type: 'callout', label: 'Call-out', color: '#e74c3c' });
        });
        
        // Remove duplicates
        const uniqueFlags = activeFlags.filter((flag, index, self) => 
          index === self.findIndex(f => f.type === flag.type)
        );
        
        if (uniqueFlags.length > 0) {
          activeFlagsSummary.style.display = 'block';
          activeFlagsContent.innerHTML = uniqueFlags.map(flag => 
            `<span style="padding: 4px 8px; background: ${flag.color}; color: white; border-radius: 6px; font-size: 11px; font-weight: 600;">${flag.label}</span>`
          ).join('');
        } else {
          activeFlagsSummary.style.display = 'none';
        }
      }



        // Function to refresh flag display from database
        window.refreshFlagDisplay = async function() {
          console.log('🔄 Refreshing flag display from database...');
          
          try {
            // Reload shifts from database
            const currentPeriod = allPeriods[currentPeriodIndex];
            if (currentPeriod) {
              const shifts = await apiService.getShiftsForPeriod(currentPeriod.period_id);
              console.log('📊 Reloaded shifts from database:', shifts.length);
              
              // Clear existing rota data
              Object.keys(rotaData).forEach(weekKey => {
                rotaData[weekKey].forEach(row => {
                  row.days.fill('');
                });
              });
              
              // Process shifts and update rota data
              // (This is the same logic as in loadShiftsFromDatabase)
              const shiftGroups = {};
              shifts.forEach(shift => {
                const shiftDate = new Date(shift.shift_start_datetime);
                const dateString = shiftDate.toISOString().split('T')[0];
                const timeSlot = shift.shift_start_datetime.split('T')[1].substring(0, 5);
                const groupKey = `${shift.period_id}_${shift.week_number}_${dateString}_${shift.shift_type}_${timeSlot}`;
                if (!shiftGroups[groupKey]) {
                  shiftGroups[groupKey] = [];
                }
                shiftGroups[groupKey].push(shift);
              });
              
              // Process each shift group
              Object.keys(shiftGroups).forEach(groupKey => {
                const shiftAssignments = shiftGroups[groupKey];
                const firstShift = shiftAssignments[0];
                
                const weekKey = `week${firstShift.week_number}`;
                const weekIndex = firstShift.week_number - 1;
                
                const shiftStartDate = new Date(firstShift.shift_start_datetime);
                const weekStartDate = new Date(currentPeriod.weeks[weekIndex]);
                const dayIndex = Math.floor((shiftStartDate - weekStartDate) / (24 * 60 * 60 * 1000));
                
                if (dayIndex >= 0 && dayIndex <= 6) {
                  let rowIndex = 0;
                  if (firstShift.shift_type === 'Tom Night') {
                    rowIndex = 3;
                  } else if (firstShift.shift_type === 'Charlotte Day') {
                    rowIndex = 1;
                  } else if (firstShift.shift_type === 'Double Up') {
                    rowIndex = 2;
                  } else if (firstShift.shift_type === 'Charlotte Night') {
                    rowIndex = 4;
                  } else if (firstShift.shift_type === 'HOLIDAY') {
                    rowIndex = 5;
                  }
                  
                  if (rotaData[weekKey] && rotaData[weekKey][rowIndex]) {
                    const assignments = shiftAssignments.map(shift => {
                      const shiftStart = new Date(shift.shift_start_datetime);
                      const shiftEnd = new Date(shift.shift_end_datetime);
                      const startTime = shiftStart.toTimeString().substring(0, 5);
                      const endTime = shiftEnd.toTimeString().substring(0, 5);
                      
                      return {
                        staffName: shift.staff_name,
                        startTime: startTime,
                        endTime: endTime,
                        shiftId: shift.shift_id,
                        periodId: shift.period_id,
                        soloShift: shift.solo_shift || false,
                        training: shift.training || false,
                        shortNotice: shift.short_notice || false,
                        paymentPeriodEnd: shift.payment_period_end || false,
                        financialYearEnd: shift.financial_year_end || false,
                        notes: shift.notes || ''
                      };
                    });
                    
                    const staffNames = shiftAssignments.map(s => s.staff_name).join(', ');
                    rotaData[weekKey][rowIndex].days[dayIndex] = {
                      displayText: staffNames,
                      assignments: assignments
                    };
                  }
                }
              });
              
              // Regenerate tables to show updated data
              generateTables();
              console.log('✅ Flag display refreshed from database');
            }
          } catch (error) {
            console.error('❌ Error refreshing flag display:', error);
          }
        };





      // Function to check holiday entitlement and show warning if fully utilized
      async function checkHolidayEntitlementWarning(staffName, assignmentDiv) {
        try {
          console.log('🏖️ Checking holiday entitlement for:', staffName);
          
          // Find the staff member in globalStaffMembers to get their ID
          const staffMember = window.globalStaffMembers.find(staff => staff.staff_name === staffName);
          if (!staffMember) {
            console.log('⚠️ Staff member not found in globalStaffMembers:', staffName);
            return;
          }
          
          // Check holiday entitlement status
          const entitlementResponse = await apiService.checkHolidayEntitlementStatus(staffMember.unique_id);
          
          if (entitlementResponse.success && entitlementResponse.data.is_fully_utilized) {
            console.log('⚠️ Holiday entitlement fully utilized for:', staffName);
            
            // Remove any existing warning
            const existingWarning = assignmentDiv.querySelector('.holiday-warning');
            if (existingWarning) {
              existingWarning.remove();
            }
            
            // Create warning element
            const warningDiv = document.createElement('div');
            warningDiv.className = 'holiday-warning';
            warningDiv.style.cssText = `
              background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
              color: white;
              padding: 12px 16px;
              border-radius: 8px;
              margin: 8px 0;
              border-left: 4px solid #dc3545;
              box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
              animation: slideIn 0.3s ease-out;
            `;
            
            warningDiv.innerHTML = `
              <div style="display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 18px;">⚠️</span>
                <div style="font-weight: 600; font-size: 14px;">Holiday Entitlement Fully Utilized</div>
              </div>
            `;
            
            // Insert warning inside the assignment card
            assignmentDiv.appendChild(warningDiv);
            
            // Add a subtle animation to draw attention
            setTimeout(() => {
              warningDiv.style.transform = 'scale(1.02)';
              setTimeout(() => {
                warningDiv.style.transform = 'scale(1)';
              }, 200);
            }, 100);
            
          } else {
            // Remove any existing warning if entitlement is not fully utilized
            const existingWarning = assignmentDiv.querySelector('.holiday-warning');
            if (existingWarning) {
              existingWarning.remove();
            }
            console.log('✅ Holiday entitlement available for:', staffName);
          }
          
        } catch (error) {
          console.error('❌ Error checking holiday entitlement:', error);
          // Don't show error to user, just log it
        }
      }

      // Function to create assignment row
      function createAssignmentRow(assignment, index) {
        const assignmentDiv = document.createElement('div');
        assignmentDiv.className = 'staff-assignment';
        assignmentDiv.setAttribute('data-index', index);
        assignmentDiv.style.cssText = `
          background: #f8f9fa; 
          border-radius: 8px; 
          padding: 16px; 
          margin-bottom: 12px; 
          border: 1px solid #e9ecef;
          animation: slideIn 0.3s ease-out;
          position: relative;
        `;

        // Calculate hours for display
        const startTime = new Date(`2000-01-01T${assignment.startTime}`);
        const endTime = new Date(`2000-01-01T${assignment.endTime}`);
        if (endTime < startTime) {
          endTime.setDate(endTime.getDate() + 1);
        }
        const hoursWorked = Math.round((endTime - startTime) / (1000 * 60 * 60));
        
        // Check if this is a holiday cell (no flags for holiday cells)
        const isHolidayCell = window.currentRoleName && window.currentRoleName.toLowerCase().includes('holiday');
        
        console.log('📝 Creating assignment row for:', assignment);
        console.log('🚩 Flag values in assignment:', {
          soloShift: assignment.soloShift,
          training: assignment.training,
          shortNotice: assignment.shortNotice,
          callout: assignment.callout,
          overtime: assignment.overtime
        });
        console.log('🏖️ Is holiday cell:', isHolidayCell);

        assignmentDiv.innerHTML = `
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; position: relative;">
            <div style="flex: 1; position: relative; margin-right: 8px; display: flex;">
              <input type="text" class="staff-input" placeholder="Type staff name..." value="${assignment.staffName || ''}" style="flex: 1; padding: 10px; border: 1px solid #ddd; border-right: none; border-radius: 6px 0 0 6px; font-size: 14px; background: white; box-sizing: border-box;">
              <button class="dropdown-toggle" style="padding: 10px 12px; background: #f8f9fa; border: 1px solid #ddd; border-left: none; border-radius: 0 6px 6px 0; cursor: pointer; font-size: 14px; color: #666; transition: all 0.2s;">▼</button>
              <div class="staff-dropdown" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ddd; border-top: none; border-radius: 0 0 6px 6px; max-height: 200px; overflow-y: auto; z-index: 1000; display: none; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
                ${availableNames.slice(1).map(name => `<div class="dropdown-item" data-value="${name}" style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.2s;">${name}</div>`).join('')}
              </div>
            </div>
            <button class="remove-staff" style="padding: 8px 12px; background: #dc3545; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer; min-width: 40px;">×</button>
          </div>
          <div style="display: flex; align-items: center; gap: 8px; font-size: 14px; margin-bottom: 8px;">
            <input type="time" class="start-time" value="${assignment.startTime}" style="padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; background: white;">
            <span style="color: #666;">to</span>
            <input type="time" class="end-time" value="${assignment.endTime}" style="padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; background: white;">
            <span style="color: #28a745; font-weight: 600; font-size: 12px;">(${hoursWorked}h)</span>
          </div>
          
          ${isHolidayCell ? '' : `<!-- Flags Section -->
          <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px; flex-wrap: wrap;">
            <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; color: #666; cursor: pointer;">
              <input type="checkbox" class="flag-checkbox solo-shift-flag" ${assignment.soloShift ? 'checked' : ''} style="width: 16px; height: 16px; accent-color: #ff6b35;">
              <span style="color: #ff6b35; font-weight: 600;">Solo Shift</span>
            </label>
            <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; color: #666; cursor: pointer;">
              <input type="checkbox" class="flag-checkbox training-flag" ${assignment.training ? 'checked' : ''} style="width: 16px; height: 16px; accent-color: #4ecdc4;">
              <span style="color: #4ecdc4; font-weight: 600;">Training</span>
            </label>
            <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; color: #666; cursor: pointer;">
              <input type="checkbox" class="flag-checkbox short-notice-flag" ${assignment.shortNotice ? 'checked' : ''} style="width: 16px; height: 16px; accent-color: #ff6b6b;">
              <span style="color: #ff6b6b; font-weight: 600;"><12h Notice</span>
            </label>
            <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; color: #666; cursor: pointer;">
              <input type="checkbox" class="flag-checkbox overtime-flag" ${assignment.overtime ? 'checked' : ''} style="width: 16px; height: 16px; accent-color: #9b59b6;">
              <span style="color: #9b59b6; font-weight: 600;">Overtime</span>
            </label>
            <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; color: #666; cursor: pointer;">
              <input type="checkbox" class="flag-checkbox callout-flag" ${assignment.callout ? 'checked' : ''} style="width: 16px; height: 16px; accent-color: #e74c3c;">
              <span style="color: #e74c3c; font-weight: 600;">Call-out</span>
            </label>
          </div>`}
          
          <!-- Notes Section -->
          <div style="margin-bottom: 8px;">
            <label style="display: block; font-size: 13px; color: #666; margin-bottom: 4px; font-weight: 600;">Notes:</label>
            <textarea class="notes-textarea" placeholder="Add notes for this assignment..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 13px; background: white; resize: vertical; min-height: 60px; font-family: inherit;">${assignment.notes || ''}</textarea>
          </div>
          
          <div style="font-size: 12px; color: #666; font-style: italic;">
            ${assignment.staffName ? `${assignment.staffName} assigned` : 'Select staff member and set times'}
          </div>
          

        `;

        // Add event listeners
        const staffInput = assignmentDiv.querySelector('.staff-input');
        const staffDropdown = assignmentDiv.querySelector('.staff-dropdown');
        const dropdownToggle = assignmentDiv.querySelector('.dropdown-toggle');
        const dropdownItems = assignmentDiv.querySelectorAll('.dropdown-item');
        const startTimeInput = assignmentDiv.querySelector('.start-time');
        const endTimeInput = assignmentDiv.querySelector('.end-time');
        const removeBtn = assignmentDiv.querySelector('.remove-staff');
        const soloShiftFlag = assignmentDiv.querySelector('.solo-shift-flag');
        const trainingFlag = assignmentDiv.querySelector('.training-flag');
        const shortNoticeFlag = assignmentDiv.querySelector('.short-notice-flag');
        const overtimeFlag = assignmentDiv.querySelector('.overtime-flag');
        const calloutFlag = assignmentDiv.querySelector('.callout-flag');
        
        console.log('🎯 Setting up event listeners for staff input:', !!staffInput);
        
        console.log('🔍 Found form elements:', {
          staffInput: !!staffInput,
          staffDropdown: !!staffDropdown,
          dropdownToggle: !!dropdownToggle,
          dropdownItems: dropdownItems.length,
          startTimeInput: !!startTimeInput,
          endTimeInput: !!endTimeInput,
          removeBtn: !!removeBtn,
          soloShiftFlag: !!soloShiftFlag,
          trainingFlag: !!trainingFlag,
          shortNoticeFlag: !!shortNoticeFlag,
          overtimeFlag: !!overtimeFlag
        });

        // Staff input autocomplete functionality
        staffInput.addEventListener('input', (e) => {
          e.stopPropagation();
          const searchTerm = e.target.value.toLowerCase();
          
          // Filter dropdown items based on input
          dropdownItems.forEach(item => {
            const itemText = item.textContent.toLowerCase();
            if (itemText.includes(searchTerm)) {
              item.style.display = 'block';
            } else {
              item.style.display = 'none';
            }
          });
          
          // Show dropdown if there's input
          if (searchTerm.length > 0) {
            staffDropdown.style.display = 'block';
          } else {
            staffDropdown.style.display = 'none';
          }
        });

        // Dropdown toggle button functionality
        dropdownToggle.addEventListener('click', (e) => {
          e.stopPropagation();
          const isVisible = staffDropdown.style.display === 'block';
          
          if (isVisible) {
            staffDropdown.style.display = 'none';
            dropdownToggle.textContent = '▼';
          } else {
            // Show all items when dropdown is opened
            dropdownItems.forEach(item => {
              item.style.display = 'block';
            });
            staffDropdown.style.display = 'block';
            dropdownToggle.textContent = '▲';
          }
        });

        // Handle dropdown item selection
        dropdownItems.forEach(item => {
          item.addEventListener('click', async (e) => {
            e.stopPropagation();
            const selectedName = item.getAttribute('data-value');
            staffInput.value = selectedName;
            assignment.staffName = selectedName;
            staffDropdown.style.display = 'none';
            dropdownToggle.textContent = '▼';
            console.log('👤 Staff selected:', assignment.staffName);
            
            // Check if this is a holiday cell and if the staff member has fully utilized their holiday entitlement
            const isHolidayCell = window.currentRoleName && window.currentRoleName.toLowerCase().includes('holiday');
            if (isHolidayCell && selectedName) {
              await checkHolidayEntitlementWarning(selectedName, assignmentDiv);
            }
            
            updateDisplays();
            updateAssignmentDisplay(assignmentDiv, assignment);
          });
          
          // Hover effects
          item.addEventListener('mouseenter', () => {
            item.style.backgroundColor = '#f8f9fa';
          });
          
          item.addEventListener('mouseleave', () => {
            item.style.backgroundColor = 'white';
          });
        });

        // Hide dropdown when clicking outside
        document.addEventListener('click', (e) => {
          if (!staffInput.contains(e.target) && !staffDropdown.contains(e.target) && !dropdownToggle.contains(e.target)) {
            staffDropdown.style.display = 'none';
            dropdownToggle.textContent = '▼';
          }
        });

        // Test basic keydown functionality
        staffInput.addEventListener('keydown', (e) => {
          console.log('🔍 Basic keydown test - Key:', e.key);
        });
        
        // Handle Enter key to select first visible item and optionally save
        staffInput.addEventListener('keydown', async (e) => {
          console.log('🔍 Key pressed:', e.key, 'on staff input');
          
          if (e.key === 'Enter') {
            console.log('🎯 ENTER KEY DETECTED!');
            e.preventDefault();
            e.stopPropagation();
            
            const inputValue = staffInput.value.trim();
            console.log('🎯 Enter pressed with input value:', inputValue);
            console.log('🎯 Available dropdown items:', dropdownItems.length);
            
            // Log all available staff names for debugging
            const allStaffNames = Array.from(dropdownItems).map(item => item.getAttribute('data-value'));
            console.log('🎯 All staff names:', allStaffNames);
            
            let selectedName = '';
            
            // Check if input value exactly matches a staff name
            const exactMatch = Array.from(dropdownItems).find(item => 
              item.getAttribute('data-value').toLowerCase() === inputValue.toLowerCase()
            );
            
            if (exactMatch) {
              selectedName = exactMatch.getAttribute('data-value');
              console.log('✅ Found exact match:', selectedName);
            } else {
              console.log('❌ No exact match found');
              
              // Look for first visible item in dropdown
              const visibleItems = Array.from(dropdownItems).filter(item => item.style.display !== 'none');
              console.log('🎯 Visible items count:', visibleItems.length);
              
              if (visibleItems.length > 0) {
                selectedName = visibleItems[0].getAttribute('data-value');
                console.log('✅ Found visible item:', selectedName);
              } else if (inputValue) {
                console.log('🔍 Looking for partial match...');
                // If no visible items but there's input, try to find a partial match
                const partialMatch = Array.from(dropdownItems).find(item => 
                  item.getAttribute('data-value').toLowerCase().includes(inputValue.toLowerCase())
                );
                if (partialMatch) {
                  selectedName = partialMatch.getAttribute('data-value');
                  console.log('✅ Found partial match:', selectedName);
                } else {
                  console.log('❌ No partial match found');
                }
              }
            }
            
            if (selectedName) {
              console.log('🎯 Setting staff name to:', selectedName);
              staffInput.value = selectedName;
              assignment.staffName = selectedName;
              staffDropdown.style.display = 'none';
              dropdownToggle.textContent = '▼';
              console.log('👤 Staff selected (Enter):', assignment.staffName);
              
              // Check if this is a holiday cell and if the staff member has fully utilized their holiday entitlement
              const isHolidayCell = window.currentRoleName && window.currentRoleName.toLowerCase().includes('holiday');
              if (isHolidayCell && selectedName) {
                await checkHolidayEntitlementWarning(selectedName, assignmentDiv);
              }
              
              updateDisplays();
              updateAssignmentDisplay(assignmentDiv, assignment);
              
              // Auto-save logic
              setTimeout(() => {
                const validAssignments = window.currentAssignments.filter(a => a.staffName);
                console.log('🔍 Valid assignments for auto-save:', validAssignments.length);
                console.log('🔍 Valid assignments:', validAssignments);
                
                if (validAssignments.length === 1 && validAssignments[0].staffName === selectedName) {
                  console.log('🚀 Auto-saving single assignment after Enter key selection');
                  
                  // Show auto-save indicator
                  const autoSaveIndicator = document.createElement('div');
                  autoSaveIndicator.className = 'auto-save-indicator';
                  autoSaveIndicator.textContent = '💾 Auto-saving assignment...';
                  document.body.appendChild(autoSaveIndicator);
                  
                  // Remove indicator after animation
                  setTimeout(() => {
                    if (autoSaveIndicator.parentNode) {
                      autoSaveIndicator.remove();
                    }
                  }, 1500);
                  
                  // Trigger the save button click
                  const saveBtn = document.getElementById('save-btn');
                  if (saveBtn) {
                    console.log('🎯 Found save button, clicking...');
                    setTimeout(() => {
                      saveBtn.click();
                    }, 200); // Slightly longer delay to ensure assignment is set
                  } else {
                    console.log('❌ Save button not found!');
                  }
                } else {
                  console.log('ℹ️ Not auto-saving: multiple assignments or no valid assignment');
                  console.log('ℹ️ Valid assignments count:', validAssignments.length);
                  console.log('ℹ️ First valid assignment:', validAssignments[0]);
                  console.log('ℹ️ Selected name:', selectedName);
                }
              }, 50); // Small delay to ensure assignment is updated
            } else {
              console.log('⚠️ No staff name found for Enter key');
            }
          }
        });

        // Handle Tab key for auto-completion (selection only, no auto-save)
        staffInput.addEventListener('keydown', async (e) => {
          if (e.key === 'Tab') {
            console.log('🎯 TAB KEY DETECTED!');
            e.preventDefault();
            e.stopPropagation();
            
            const inputValue = staffInput.value.trim();
            console.log('🎯 Tab pressed with input value:', inputValue);
            console.log('🎯 Available dropdown items:', dropdownItems.length);
            
            // Log all available staff names for debugging
            const allStaffNames = Array.from(dropdownItems).map(item => item.getAttribute('data-value'));
            console.log('🎯 All staff names:', allStaffNames);
            
            let selectedName = '';
            
            // Check if input value exactly matches a staff name
            const exactMatch = Array.from(dropdownItems).find(item => 
              item.getAttribute('data-value').toLowerCase() === inputValue.toLowerCase()
            );
            
            if (exactMatch) {
              selectedName = exactMatch.getAttribute('data-value');
              console.log('✅ Found exact match for Tab:', selectedName);
            } else {
              console.log('❌ No exact match found for Tab');
              
              // Look for first visible item in dropdown
              const visibleItems = Array.from(dropdownItems).filter(item => item.style.display !== 'none');
              console.log('🎯 Visible items count for Tab:', visibleItems.length);
              
              if (visibleItems.length > 0) {
                selectedName = visibleItems[0].getAttribute('data-value');
                console.log('✅ Found visible item for Tab:', selectedName);
              } else if (inputValue) {
                console.log('🔍 Looking for partial match for Tab...');
                // If no visible items but there's input, try to find a partial match
                const partialMatch = Array.from(dropdownItems).find(item => 
                  item.getAttribute('data-value').toLowerCase().includes(inputValue.toLowerCase())
                );
                if (partialMatch) {
                  selectedName = partialMatch.getAttribute('data-value');
                  console.log('✅ Found partial match for Tab:', selectedName);
                } else {
                  console.log('❌ No partial match found for Tab');
                }
              }
            }
            
            if (selectedName) {
              console.log('🎯 Setting staff name to (Tab):', selectedName);
              staffInput.value = selectedName;
              assignment.staffName = selectedName;
              staffDropdown.style.display = 'none';
              dropdownToggle.textContent = '▼';
              console.log('👤 Staff selected (Tab):', assignment.staffName);
              
              // Check if this is a holiday cell and if the staff member has fully utilized their holiday entitlement
              const isHolidayCell = window.currentRoleName && window.currentRoleName.toLowerCase().includes('holiday');
              if (isHolidayCell && selectedName) {
                await checkHolidayEntitlementWarning(selectedName, assignmentDiv);
              }
              
              updateDisplays();
              updateAssignmentDisplay(assignmentDiv, assignment);
              
              // Tab only selects staff, doesn't auto-save
              console.log('ℹ️ Tab key: Staff selected but not auto-saving - use Enter to save');
            } else {
              console.log('⚠️ No staff name found for Tab key');
            }
          }
        });

        startTimeInput.addEventListener('change', (e) => {
          e.stopPropagation();
          assignment.startTime = e.target.value;
          console.log('⏰ Start time changed:', assignment.startTime);
          updateDisplays();
          updateAssignmentDisplay(assignmentDiv, assignment);
        });

        endTimeInput.addEventListener('change', (e) => {
          e.stopPropagation();
          assignment.endTime = e.target.value;
          console.log('⏰ End time changed:', assignment.endTime);
          updateDisplays();
          updateAssignmentDisplay(assignmentDiv, assignment);
        });

        // Flag event listeners (only for non-holiday cells)
        if (!isHolidayCell && soloShiftFlag) {
          soloShiftFlag.addEventListener('change', async (e) => {
          e.stopPropagation();
          assignment.soloShift = e.target.checked;
          console.log('🚨 Solo shift flag changed:', assignment.soloShift, 'for assignment:', assignment);
          console.log('🚨 All assignments after solo shift change:', window.currentAssignments);
          
          // Update the database if this assignment has a shift ID
          if (assignment.shiftId && assignment.shiftId !== null && assignment.shiftId !== undefined) {
            try {
              console.log(`🔄 Updating solo shift flag for ${assignment.staffName} with shift ID: ${assignment.shiftId}`);
              await apiService.updateShiftSoloFlag(assignment.shiftId, assignment.soloShift);
              console.log('✅ Solo shift flag updated in database');
            } catch (error) {
              console.error('❌ Failed to update solo shift flag in database:', error);
              // Revert the change if the API call failed
              assignment.soloShift = !e.target.checked;
              e.target.checked = assignment.soloShift;
            }
          } else {
            console.log(`⚠️ No valid shift ID found for assignment ${assignment.staffName}, skipping database update. Shift ID: ${assignment.shiftId}`);
          }
          
          updateDisplays();
          updateAssignmentDisplay(assignmentDiv, assignment);
          updateRotaTableCells(); // Update the rota table to show flag changes immediately
          });
        }

        if (!isHolidayCell && trainingFlag) {
          trainingFlag.addEventListener('change', async (e) => {
          e.stopPropagation();
          assignment.training = e.target.checked;
          console.log('📚 Training flag changed:', assignment.training, 'for assignment:', assignment);
          console.log('📚 All assignments after training change:', window.currentAssignments);
          
          // Update the database if this assignment has a shift ID
          if (assignment.shiftId && assignment.shiftId !== null && assignment.shiftId !== undefined) {
            try {
              console.log(`🔄 Updating training flag for ${assignment.staffName} with shift ID: ${assignment.shiftId}`);
              await apiService.updateShiftTrainingFlag(assignment.shiftId, assignment.training);
              console.log('✅ Training flag updated in database');
            } catch (error) {
              console.error('❌ Failed to update training flag in database:', error);
              // Revert the change if the API call failed
              assignment.training = !e.target.checked;
              e.target.checked = assignment.training;
            }
          } else {
            console.log(`⚠️ No valid shift ID found for assignment ${assignment.staffName}, skipping database update. Shift ID: ${assignment.shiftId}`);
          }
          
          updateDisplays();
          updateAssignmentDisplay(assignmentDiv, assignment);
          updateRotaTableCells(); // Update the rota table to show flag changes immediately
          });
        }

        if (!isHolidayCell && shortNoticeFlag) {
          shortNoticeFlag.addEventListener('change', async (e) => {
          e.stopPropagation();
          assignment.shortNotice = e.target.checked;
          console.log('⚠️ Short notice flag changed:', assignment.shortNotice, 'for assignment:', assignment);
          console.log('⚠️ All assignments after short notice change:', window.currentAssignments);
          
          // Update the database if this assignment has a shift ID
          if (assignment.shiftId && assignment.shiftId !== null && assignment.shiftId !== undefined) {
            try {
              console.log(`🔄 Updating short notice flag for ${assignment.staffName} with shift ID: ${assignment.shiftId}`);
              await apiService.updateShiftShortNoticeFlag(assignment.shiftId, assignment.shortNotice);
              console.log('✅ Short notice flag updated in database');
            } catch (error) {
              console.error('❌ Failed to update short notice flag in database:', error);
              // Revert the change if the API call failed
              assignment.shortNotice = !e.target.checked;
              e.target.checked = assignment.shortNotice;
            }
          } else {
            console.log(`⚠️ No valid shift ID found for assignment ${assignment.staffName}, skipping database update. Shift ID: ${assignment.shiftId}`);
          }
          
          updateDisplays();
          updateAssignmentDisplay(assignmentDiv, assignment);
          updateRotaTableCells(); // Update the rota table to show flag changes immediately
          });
        }


        if (!isHolidayCell && overtimeFlag) {
          overtimeFlag.addEventListener('change', async (e) => {
          e.stopPropagation();
          assignment.overtime = e.target.checked;
          console.log('⏰ Overtime flag changed:', assignment.overtime, 'for assignment:', assignment);
          console.log('⏰ All assignments after overtime change:', window.currentAssignments);
          
          // Update the database if this assignment has a shift ID
          if (assignment.shiftId && assignment.shiftId !== null && assignment.shiftId !== undefined) {
            try {
              console.log(`🔄 Updating overtime flag for ${assignment.staffName} with shift ID: ${assignment.shiftId}`);
              await apiService.updateShiftOvertimeFlag(assignment.shiftId, assignment.overtime);
              console.log('✅ Overtime flag updated in database');
            } catch (error) {
              console.error('❌ Failed to update overtime flag in database:', error);
              // Revert the change if the API call failed
              assignment.overtime = !e.target.checked;
              e.target.checked = assignment.overtime;
            }
          } else {
            console.log(`⚠️ No valid shift ID found for assignment ${assignment.staffName}, skipping database update. Shift ID: ${assignment.shiftId}`);
          }
          
          updateDisplays();
          updateAssignmentDisplay(assignmentDiv, assignment);
          updateRotaTableCells(); // Update the rota table to show flag changes immediately
          });
        }

        if (!isHolidayCell && calloutFlag) {
          calloutFlag.addEventListener('change', async (e) => {
          e.stopPropagation();
          assignment.callout = e.target.checked;
          console.log('📞 Callout flag changed:', assignment.callout, 'for assignment:', assignment);
          console.log('📞 All assignments after callout change:', window.currentAssignments);
          
          // Update the database if this assignment has a shift ID
          if (assignment.shiftId && assignment.shiftId !== null && assignment.shiftId !== undefined) {
            try {
              console.log(`🔄 Updating callout flag for ${assignment.staffName} with shift ID: ${assignment.shiftId}`);
              await apiService.updateShiftCalloutFlag(assignment.shiftId, assignment.callout);
              console.log('✅ Callout flag updated in database');
            } catch (error) {
              console.error('❌ Failed to update callout flag in database:', error);
              // Revert the change if the API call failed
              assignment.callout = !e.target.checked;
              e.target.checked = assignment.callout;
            }
          } else {
            console.log(`⚠️ No valid shift ID found for assignment ${assignment.staffName}, skipping database update. Shift ID: ${assignment.shiftId}`);
          }
          
          updateDisplays();
          updateAssignmentDisplay(assignmentDiv, assignment);
          updateRotaTableCells(); // Update the rota table to show flag changes immediately
          });
        }

        // Notes textarea event listener
        const notesTextarea = assignmentDiv.querySelector('.notes-textarea');
        if (notesTextarea) {
          notesTextarea.addEventListener('input', async (e) => {
            e.stopPropagation();
            assignment.notes = e.target.value;
            console.log('📝 Notes changed:', assignment.notes, 'for assignment:', assignment);
            console.log('📝 All assignments after notes change:', window.currentAssignments);
            
            // Update the database if this assignment has a shift ID
            if (assignment.shiftId && assignment.shiftId !== null && assignment.shiftId !== undefined) {
              try {
                console.log(`🔄 Updating notes for ${assignment.staffName} with shift ID: ${assignment.shiftId}`);
                await apiService.updateShiftNotes(assignment.shiftId, assignment.notes);
                console.log('✅ Notes updated in database');
              } catch (error) {
                console.error('❌ Failed to update notes in database:', error);
                // Note: We don't revert notes on error as it would be disruptive to user input
              }
            } else {
              console.log(`⚠️ No valid shift ID found for assignment ${assignment.staffName}, skipping database update. Shift ID: ${assignment.shiftId}`);
            }
          });
        }



        removeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          console.log('🗑️ Removing staff assignment at index:', index);
          
          // Store the assignment details before removing for potential database deletion
          const removedAssignment = { ...assignment };
          console.log('🗑️ Removed assignment details:', removedAssignment);
          
          // Remove from global assignments array
          window.currentAssignments = window.currentAssignments.filter((_, i) => i !== index);
          
          // Animate removal
          assignmentDiv.style.animation = 'slideOut 0.3s ease-in';
          setTimeout(() => {
            assignmentDiv.remove();
            updateDisplays();
          }, 300);
          
          // If this was a saved assignment (had a staff name), mark it for deletion
          if (removedAssignment.staffName && removedAssignment.staffName.trim() !== '') {
            console.log('🗑️ Marking assignment for deletion from database:', removedAssignment);
            console.log('📊 Current assignments after removal:', window.currentAssignments);
            console.log('📊 Original assignments:', originalAssignments);
            // We'll handle the deletion when save is clicked
          }
        });

        return assignmentDiv;
      }

      // Function to update assignment display
      function updateAssignmentDisplay(assignmentDiv, assignment) {
        const startTime = new Date(`2000-01-01T${assignment.startTime}`);
        const endTime = new Date(`2000-01-01T${assignment.endTime}`);
        if (endTime < startTime) {
          endTime.setDate(endTime.getDate() + 1);
        }
        const hoursWorked = Math.round((endTime - startTime) / (1000 * 60 * 60));
        
        const hoursSpan = assignmentDiv.querySelector('span[style*="color: #28a745"]');
        if (hoursSpan) {
          hoursSpan.textContent = `(${hoursWorked}h)`;
        }
        
        const descriptionDiv = assignmentDiv.querySelector('div[style*="font-size: 12px"]');
        if (descriptionDiv) {
          descriptionDiv.textContent = assignment.staffName ? 
            `${assignment.staffName} assigned` : 
            'Select staff member and set times';
        }
      }
              // Function to update rota table cells to reflect flag changes immediately
        function updateRotaTableCells() {
          console.log('🔄 Updating rota table cells to reflect flag changes...');
          
          // Use the global rotaData directly
          const rotaData = window.rotaData;
          if (!rotaData) {
            console.log('⚠️ No rota data found');
            return;
          }
          
          // Update each cell in the rota table
          const rotaTable = document.querySelector('.rota-table');
          if (!rotaTable) {
            console.log('⚠️ Rota table not found');
            return;
          }
          
          const cells = rotaTable.querySelectorAll('td[data-week-index][data-row-index][data-day-index]');
          cells.forEach(cell => {
            const weekIndex = parseInt(cell.dataset.weekIndex);
            const rowIndex = parseInt(cell.dataset.rowIndex);
            const dayIndex = parseInt(cell.dataset.dayIndex);
            
            // Get the day data for this cell
            const weekKey = `week${weekIndex}`;
            if (rotaData[weekKey] && rotaData[weekKey][rowIndex]) {
              const day = rotaData[weekKey][rowIndex].days[dayIndex];
              
              if (day && day.assignments && day.assignments.length > 0) {
                // Regenerate the entire cell content with updated flags
                const displayText = day.displayText || '';
                const isMultipleStaff = day.assignments && day.assignments.length > 1;
                
                // Generate flag indicators
                const flagHtml = day.assignments.map(assignment => {
                  const flags = [];
                  if (assignment.soloShift) flags.push('<span class="flag-indicator solo-shift">Solo</span>');
                  if (assignment.training) flags.push('<span class="flag-indicator training">Training</span>');
                  if (assignment.shortNotice) flags.push('<span class="flag-indicator short-notice"><12h Notice</span>');
                  if (assignment.overtime) flags.push('<span class="flag-indicator overtime">Overtime</span>');
                  if (assignment.callout) flags.push('<span class="flag-indicator callout">Call-out</span>');
                  
                  return flags.join('');
                }).join('');
                
                // Check if any assignment has notes
                const hasNotes = day.assignments.some(assignment => assignment.notes && assignment.notes.trim() !== '');
                const noteIcon = hasNotes ? '<div class="note-icon" title="Has notes">📝</div>' : '';
                
                // Update the cell content
                if (flagHtml) {
                  cell.innerHTML = `<div style="text-align: center; position: relative;">
                    <div style="font-weight: 600; margin-bottom: 4px;">${displayText}</div>
                    <div class="flag-indicators">${flagHtml}</div>
                    ${noteIcon}
                  </div>`;
                } else {
                  cell.innerHTML = `<div style="position: relative;">
                    ${displayText}
                    ${noteIcon}
                  </div>`;
                }
                
                // Re-add the data attributes and classes
                cell.dataset.assignments = JSON.stringify(day.assignments);
                
                
                cell.classList.add('editable-cell');
                
                // Re-apply styling
                if (isMultipleStaff) {
                  cell.classList.add('multiple-staff-cell');
                } else if (staffColors[displayText]) {
                  cell.style.backgroundColor = staffColors[displayText];
                }
                
                console.log(`🔄 Updated cell ${weekIndex}-${rowIndex}-${dayIndex} with flags:`, flagHtml);
              }
            }
          });
          
          console.log('✅ Rota table cells updated');
        }

        // Function to add new assignment
      function addNewAssignment() {
        console.log('➕ Adding new staff assignment...');
        
        const container = document.getElementById('staff-assignments-container');
        if (!container) {
          console.error('❌ staff-assignments-container not found!');
          return;
        }
        
        const newAssignment = {
          staffName: '',
          startTime: defaultStartTime,
          endTime: defaultEndTime,
          shiftId: null, // Will be set when saved to database
          periodId: null, // Will be set when saved to database
          soloShift: false,
          training: false,
          shortNotice: false,
          callout: false,
          overtime: false,
          paymentPeriodEnd: false,
          financialYearEnd: false,
          notes: ''
        };
        
        console.log('➕ Created new assignment with flags:', newAssignment);
        
        const assignmentIndex = window.currentAssignments.length;
        window.currentAssignments.push(newAssignment);
        
        const assignmentDiv = createAssignmentRow(newAssignment, assignmentIndex);
        container.appendChild(assignmentDiv);
        updateDisplays();
        
        // Auto-focus on the new staff input
        setTimeout(() => {
          const newStaffInput = assignmentDiv.querySelector('.staff-input');
          if (newStaffInput) {
            newStaffInput.focus();
            console.log('🎯 Auto-focused on new staff input');
          }
        }, 50);
        
        console.log('✅ New staff assignment added. Total assignments:', window.currentAssignments.length);
      }

      // Create initial assignment rows
      const container = document.getElementById('staff-assignments-container');
        console.log('🔄 Creating initial assignment rows for:', window.currentAssignments);
      window.currentAssignments.forEach((assignment, index) => {
          console.log(`📝 Creating row ${index} for assignment:`, assignment);
        const assignmentDiv = createAssignmentRow(assignment, index);
        container.appendChild(assignmentDiv);
      });
      updateDisplays();
      
      // Auto-focus on the first empty staff input
      setTimeout(() => {
        const firstEmptyInput = container.querySelector('.staff-input[value=""]');
        if (firstEmptyInput) {
          firstEmptyInput.focus();
          console.log('🎯 Auto-focused on first empty staff input');
        } else {
          // If no empty input, focus on the first input
          const firstInput = container.querySelector('.staff-input');
          if (firstInput) {
            firstInput.focus();
            console.log('🎯 Auto-focused on first staff input');
          }
        }
      }, 100);

      // Add staff button
      const addStaffBtn = document.getElementById('popup-add-staff-btn');
      if (addStaffBtn) {
        console.log('✅ Add staff button found, setting up event listener...');
        addStaffBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          console.log('🖱️ Add staff button clicked');
          console.log('📋 Current assignments before adding new:', window.currentAssignments);
          addNewAssignment();
          console.log('📋 Assignments after adding new:', window.currentAssignments);
        });
        console.log('✅ Add staff button event listener set up successfully');
      } else {
        console.error('❌ Add staff button not found!');
      }
      

      


      // Close button
      const closeBtn = document.getElementById('close-popup');
      console.log('🔴 Looking for close button, found:', closeBtn);
      if (closeBtn) {
        console.log('🔴 Setting up close button click handler...');
        closeBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          console.log('🔴 Close button clicked, closing popup...');
          closePopupCompletely();
        });
        console.log('🔴 Close button handler set up successfully');
      } else {
        console.error('❌ Close button not found!');
      }
      
      // Function to close popup completely
      window.closePopupCompletely = function() {
        console.log('🔴 Global closePopupCompletely called');
        
        // First try to close the current popup
        try {
          if (popup && popup.parentNode) {
          popup.remove();
            console.log('🔴 Current popup removed');
          }
        } catch (e) {
          console.log('🔴 Error removing current popup:', e);
        }
        
        // Then try to close any popup by ID
        try {
          const popupById = document.getElementById('assign-staff-popup');
          if (popupById) {
            popupById.remove();
            console.log('🔴 Popup removed by ID');
          }
        } catch (e) {
          console.log('🔴 Error removing popup by ID:', e);
        }
        
        // Then try to close any popup by class
        try {
          const popups = document.querySelectorAll('.cell-popup');
          popups.forEach(p => {
            if (p.innerHTML.includes('Assign Staff')) {
              p.remove();
              console.log('🔴 Popup removed by class and content');
            }
          });
        } catch (e) {
          console.log('🔴 Error removing popup by class:', e);
        }
        
        // Reset global reference
          currentDropdown = null;
        console.log('🔴 Current dropdown reset to null');
        
        return;
        try {
          console.log('🔴 Closing popup completely...');
          
          // Clean up handlers
          if (popup && popup.dataset.resizeHandler) {
            window.removeEventListener('resize', popup.dataset.resizeHandler);
            console.log('🔴 Removed resize handler');
          }
          if (popup && popup.dataset.scrollHandler) {
            window.removeEventListener('scroll', popup.dataset.scrollHandler);
            console.log('🔴 Removed scroll handler');
          }
          if (popup && popup.dataset.visibilityInterval) {
            clearInterval(popup.dataset.visibilityInterval);
            console.log('🔴 Cleared visibility interval');
          }
          if (popup && popup.dataset.escapeHandler) {
            document.removeEventListener('keydown', popup.dataset.escapeHandler);
            console.log('🔴 Removed escape handler');
          }
          if (popup && popup.dataset.globalEscapeHandler) {
            document.removeEventListener('keydown', popup.dataset.globalEscapeHandler);
            console.log('🔴 Removed global escape handler');
          }
          
          // Remove popup from DOM
          if (popup && popup.parentNode) {
            popup.remove();
            console.log('🔴 Popup removed from DOM');
          } else {
            console.log('🔴 Popup not found in DOM, trying alternative removal...');
            // Try to find and remove by ID
            const popupById = document.getElementById('assign-staff-popup');
            if (popupById) {
              popupById.remove();
              console.log('🔴 Popup removed by ID');
            } else {
              // Try to find by class and content
              const popups = document.querySelectorAll('.cell-popup');
              popups.forEach(p => {
                if (p.innerHTML.includes('Assign Staff')) {
                  p.remove();
                  console.log('🔴 Popup removed by class and content');
                }
              });
            }
          }
          
          // Verify popup is actually removed
          setTimeout(() => {
            const remainingPopup = document.getElementById('assign-staff-popup');
            if (remainingPopup) {
              console.log('🔴 Popup still exists, forcing removal...');
              remainingPopup.remove();
            } else {
              console.log('🔴 Popup successfully removed');
            }
          }, 100);
          
          // Reset global reference
          currentDropdown = null;
          console.log('🔴 Current dropdown reset to null');
          
        } catch (error) {
          console.error('❌ Error closing popup:', error);
          // Fallback: try to remove by class or force remove
          try {
            const popups = document.querySelectorAll('[style*="position: fixed"]');
            popups.forEach(p => {
              if (p.innerHTML.includes('Assign Staff')) {
                p.remove();
                console.log('🔴 Popup removed via fallback method');
              }
            });
          } catch (fallbackError) {
            console.error('❌ Fallback removal also failed:', fallbackError);
          }
        }
      }

      // Save button
      const saveBtn = document.getElementById('save-btn');
      if (saveBtn) {
        saveBtn.addEventListener('click', async function(e) {
          e.stopPropagation();
          console.log('💾 Save button clicked!');
          console.log('📋 Current assignments:', window.currentAssignments);
          console.log('🔍 Window currentAssignments:', window.currentAssignments);
          
          // Use the global assignments array
          const validAssignments = window.currentAssignments.filter(a => a.staffName);
          console.log('✅ Valid assignments:', validAssignments);
          
          // Basic validation - only check for required fields
          const validationErrors = [];
          
          validAssignments.forEach((assignment, index) => {
            if (!assignment.staffName) {
              validationErrors.push(`Assignment ${index + 1}: Staff name is required`);
            }
            if (!assignment.startTime) {
              validationErrors.push(`${assignment.staffName}: Start time is required`);
            }
            if (!assignment.endTime) {
              validationErrors.push(`${assignment.staffName}: End time is required`);
            }
          });
          
          if (validationErrors.length > 0) {
            alert('Please fix the following issues:\n' + validationErrors.join('\n'));
            return;
          }
          
          if (validAssignments.length === 0) {
            console.log('🗑️ No valid assignments - clearing cell and database...');
            
            // Clear the cell visually
            cell.textContent = '';
            cell.style.backgroundColor = '';
            
            // Update local rota data
            const weekKey = `week${weekIndex + 1}`;
            rotaData[weekKey][rowIndex].days[dayIndex] = '';
            
            // Clear from database using saveShiftToDatabase with empty array
            await saveShiftToDatabase(weekIndex, rowIndex, dayIndex, []);
            
            console.log('✅ Cell and database cleared successfully');
            
            // Update rota table to show flag changes immediately
            updateRotaTableCells();
            
            // Force regenerate tables to ensure flags are displayed
            setTimeout(() => {
              generateTables();
              console.log('🔄 Tables regenerated to show updated flags');
            }, 100);
          } else if (validAssignments.length < window.currentAssignments.length) {
            // Some assignments were removed - update with new assignments
            console.log('🗑️ Some assignments removed, updating with remaining assignments...');
            
            // Create display text for remaining assignments
            let displayText = '';
            if (validAssignments.length === 1) {
              const assignment = validAssignments[0];
              displayText = assignment.staffName;
            } else {
              // For multiple staff, show just names
              const staffNames = validAssignments.map(a => a.staffName).join(', ');
              displayText = staffNames;
            }
            
            cell.textContent = displayText;
            
            // Apply appropriate styling based on number of staff
            if (validAssignments.length === 1) {
              const staffName = validAssignments[0].staffName;
              cell.className = 'editable-cell';
              if (staffColors[staffName]) {
                cell.style.backgroundColor = staffColors[staffName];
              }
            } else {
              // Multiple staff styling - use gradient or light background
              cell.className = 'editable-cell multiple-staff-cell';
              cell.style.backgroundColor = '#e9ecef';
            }
            
            // Update rota data with detailed information including flags
            const weekKey = `week${weekIndex + 1}`;
            if (validAssignments.length === 0) {
              rotaData[weekKey][rowIndex].days[dayIndex] = '';
            } else {
              // Create the detailed assignment object with updated flags
              const assignmentObject = {
                displayText: displayText,
                assignments: validAssignments.map(assignment => ({
                  staffName: assignment.staffName,
                  startTime: assignment.startTime,
                  endTime: assignment.endTime,
                  shiftId: assignment.shiftId,
                  periodId: assignment.periodId,
                  soloShift: assignment.soloShift || false,
                  training: assignment.training || false,
                  shortNotice: assignment.shortNotice || false,
                  callout: assignment.callout || false,
                  overtime: assignment.overtime || false,
                  paymentPeriodEnd: assignment.paymentPeriodEnd || false,
                  financialYearEnd: assignment.financialYearEnd || false,
                  notes: assignment.notes || ''
                }))
              };
              
              rotaData[weekKey][rowIndex].days[dayIndex] = assignmentObject;
              console.log('🔄 Updated local rotaData with remaining assignments and flags:', assignmentObject);
            }
            
            // Save to database with remaining assignments
            await saveShiftToDatabase(weekIndex, rowIndex, dayIndex, validAssignments);
            
            console.log('✅ Assignments updated successfully');
            
            // Update rota table to show flag changes immediately
            updateRotaTableCells();
            
            // Force regenerate tables to ensure flags are displayed
            setTimeout(() => {
              generateTables();
              console.log('🔄 Tables regenerated to show updated flags');
            }, 100);
          } else {
            // Create display text without timing information
            let displayText = '';
            if (validAssignments.length === 1) {
              const assignment = validAssignments[0];
              displayText = assignment.staffName;
            } else {
              // For multiple staff, show just names
              const staffNames = validAssignments.map(a => a.staffName).join(', ');
              displayText = staffNames;
            }
            
            cell.textContent = displayText;
            
            // Apply appropriate styling based on number of staff
            if (validAssignments.length === 1) {
              const staffName = validAssignments[0].staffName;
              cell.className = 'editable-cell';
              if (staffColors[staffName]) {
                cell.style.backgroundColor = staffColors[staffName];
              }
            } else {
              // Multiple staff styling - use gradient or light background
              cell.className = 'editable-cell multiple-staff-cell';
              cell.style.backgroundColor = '#e9ecef';
            }
            
            // Update rota data with detailed information including flags
            const weekKey = `week${weekIndex + 1}`;
            if (validAssignments.length === 0) {
              rotaData[weekKey][rowIndex].days[dayIndex] = '';
            } else {
              // Create the detailed assignment object with updated flags
              const assignmentObject = {
                displayText: displayText,
                assignments: validAssignments.map(assignment => ({
                  staffName: assignment.staffName,
                  startTime: assignment.startTime,
                  endTime: assignment.endTime,
                  shiftId: assignment.shiftId,
                  periodId: assignment.periodId,
                  soloShift: assignment.soloShift || false,
                  training: assignment.training || false,
                  shortNotice: assignment.shortNotice || false,
                  callout: assignment.callout || false,
                  overtime: assignment.overtime || false,
                  paymentPeriodEnd: assignment.paymentPeriodEnd || false,
                  financialYearEnd: assignment.financialYearEnd || false,
                  notes: assignment.notes || ''
                }))
              };
              
              rotaData[weekKey][rowIndex].days[dayIndex] = assignmentObject;
              console.log('🔄 Updated local rotaData with new assignment and flags:', assignmentObject);
            }
            
            // Save to database
          try {
            await saveShiftToDatabase(weekIndex, rowIndex, dayIndex, validAssignments);
          
          // Show success message
          const successMsg = document.createElement('div');
          successMsg.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
          `;
          
          if (validAssignments.length === 0) {
            successMsg.textContent = '✅ Assignment cleared successfully!';
          } else {
            successMsg.textContent = `✅ ${validAssignments.length} assignment(s) saved successfully!`;
          }
          
          document.body.appendChild(successMsg);
          
          setTimeout(() => {
            successMsg.style.animation = 'slideOutRight 0.3s ease-in';
            setTimeout(() => successMsg.remove(), 300);
          }, 2000);
          
          // Update rota table to show flag changes immediately
          updateRotaTableCells();
          
          // Force regenerate tables to ensure flags are displayed
          setTimeout(() => {
            generateTables();
            console.log('🔄 Tables regenerated to show updated flags');
          }, 100);
          
          } catch (error) {
            console.error('❌ Error during save operation:', error);
            
            // Show error message
            const errorMsg = document.createElement('div');
            errorMsg.style.cssText = `
              position: fixed;
              top: 20px;
              right: 20px;
              background: #dc3545;
              color: white;
              padding: 12px 20px;
              border-radius: 8px;
              font-size: 14px;
              font-weight: 600;
              z-index: 10000;
              animation: slideInRight 0.3s ease-out;
            `;
            errorMsg.textContent = '❌ Error saving assignment. Check console for details.';
            
            document.body.appendChild(errorMsg);
            
            setTimeout(() => {
              errorMsg.style.animation = 'slideOutRight 0.3s ease-in';
              setTimeout(() => errorMsg.remove(), 300);
            }, 3000);
          }
        }
        
        // Close popup properly (always close, regardless of save success/failure)
          closePopupCompletely();
        });
      }


      


      // Cancel button
      const cancelBtn = document.getElementById('cancel-btn');
      if (cancelBtn) {
        cancelBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          console.log('🔴 Cancel button clicked, closing popup...');
          closePopupCompletely();
        });
      }

      // Close popup when clicking outside
      setTimeout(() => {
        document.addEventListener('click', function closePopup(e) {
          // Check if the click target is within the popup or is the original cell
          const isClickInPopup = popup && popup.contains && popup.contains(e.target);
          const isClickOnCell = e.target === cell;
          const isClickOnPopupElement = e.target.closest && e.target.closest('#assign-staff-popup');
          const isClickOnFormElement = e.target.tagName && ['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA'].includes(e.target.tagName.toUpperCase());
          const isClickOnPopupForm = isClickOnFormElement && e.target.closest && e.target.closest('#assign-staff-popup');
          
          // Additional check: is the target or any of its parents the popup?
          const isTargetOrParentPopup = e.target === popup || e.target.parentElement === popup || e.target.closest('#assign-staff-popup');
          
          console.log('🔍 Click detection:', {
            target: e.target,
            tagName: e.target.tagName,
            isClickInPopup: isClickInPopup,
            isClickOnCell: isClickOnCell,
            isClickOnPopupElement: isClickOnPopupElement,
            isClickOnFormElement: isClickOnFormElement,
            isClickOnPopupForm: isClickOnPopupForm,
            isTargetOrParentPopup: isTargetOrParentPopup,
            popupExists: !!popup,
            popupContains: !!popup?.contains
          });
          
          // Only close if click is truly outside both popup and cell
          if (!isClickInPopup && !isClickOnCell && !isClickOnPopupElement && !isClickOnPopupForm && !isTargetOrParentPopup) {
            console.log('🔴 Outside click detected, closing popup...');
            closePopupCompletely();
            document.removeEventListener('click', closePopup);
          } else {
            console.log('✅ Click is within popup or on cell, keeping popup open');
            
            // Prevent event bubbling for popup interactions
            e.stopPropagation();
          }
        });
      }, 100);

      // Add CSS animations
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { opacity: 0; transform: translateY(-10px); }
          to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideOut {
          from { opacity: 1; transform: translateY(0); }
          to { opacity: 0; transform: translateY(-10px); }
        }
        @keyframes slideInRight {
          from { opacity: 0; transform: translateX(100px); }
          to { opacity: 1; transform: translateX(0); }
        }
        @keyframes slideOutRight {
          from { opacity: 1; transform: translateX(0); }
          to { opacity: 0; transform: translateX(100px); }
        }
        .cell-popup button:hover {
          opacity: 0.8;
        }
        #close-popup:hover {
          background: rgba(255,255,255,0.4) !important;
          transform: scale(1.1);
        }
        #cancel-btn:hover {
          background: #5a6268 !important;
        }
        #save-btn:hover {
          background: #218838 !important;
        }
      `;
      document.head.appendChild(style);
      
      console.log('✅ Popup created and configured successfully');
      
      // Ensure popup is visible
      setTimeout(() => {
        if (popup && popup.parentNode) {
          console.log('🔍 Popup visibility check - popup is in DOM');
          console.log('🔍 Popup dimensions:', popup.offsetWidth, 'x', popup.offsetHeight);
          console.log('🔍 Popup position:', popup.offsetLeft, popup.offsetTop);
          console.log('🔍 Popup computed style:', window.getComputedStyle(popup).display);
          
          // Force popup to be visible
          popup.style.display = 'block';
          popup.style.visibility = 'visible';
          popup.style.opacity = '1';
          popup.style.zIndex = '10001';
          
          console.log('🔍 Popup forced to be visible');
        } else {
          console.error('❌ Popup visibility check failed - popup not in DOM');
        }
      }, 100);
    }



    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (currentDropdown && !currentDropdown.contains(e.target)) {
        currentDropdown.remove();
        currentDropdown = null;
      }
    });
    // Function to generate all tables
    function generateTables() {
      console.log('🔄 Generating tables...');
      const container = document.getElementById('tables-container');
      if (!container) {
        console.error('❌ Tables container not found!');
        return;
      }
      
      console.log('📊 Container found, clearing existing content...');
      container.innerHTML = '';
      
      const startDates = getCurrentStartDates();
      console.log('📅 Start dates for tables:', startDates);
      console.log('📊 Available rotaData weeks:', Object.keys(rotaData));
      
      startDates.forEach((startDate, weekIndex) => {
        const weekKey = `week${weekIndex + 1}`;
        console.log(`📊 Generating table for ${weekKey}, startDate: ${startDate.toLocaleDateString()}`);
        console.log(`📊 RotaData for ${weekKey}:`, rotaData[weekKey]);
        
        if (!rotaData[weekKey]) {
          console.error(`❌ No rotaData found for ${weekKey}`);
          return;
        }
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const trHead = document.createElement('tr');
        const thEmpty = document.createElement('th');
        thEmpty.innerHTML = 'Shift Type';
        trHead.appendChild(thEmpty);

        // Generate headers with dates
        for (let i = 0; i < 7; i++) {
          const date = new Date(startDate);
          date.setDate(startDate.getDate() + i);
          const th = document.createElement('th');
          th.innerHTML = `${date.toLocaleDateString('en-GB', { weekday: 'long' })}<br>${date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })}<br><small style="font-size: 10px; opacity: 0.7; cursor: pointer;">Click to set flags</small>`;
          
          // Add click handler for payment period end flag popup
          th.addEventListener('click', () => {
            showPaymentPeriodEndPopup(weekIndex, i, date);
          });
          
          // Check if this column should be highlighted as payment period end
          if (isPaymentPeriodEndColumn(weekIndex, i, date)) {
            th.classList.add('payment-period-end-header');
          }
          
          // Check if this column should be highlighted as financial year end
          if (isFinancialYearEndColumn(weekIndex, i, date)) {
            th.classList.add('financial-year-end-header');
          console.log(`💰 Financial year end header highlighted for ${date.toLocaleDateString('en-GB')}`);
          }
          
          // Check if this column should be highlighted as current date
          if (isCurrentDate(date)) {
            th.classList.add('current-date-header');
          }
          
          trHead.appendChild(th);
        }
        thead.appendChild(trHead);
        table.appendChild(thead);

        // Generate table body
        const tbody = document.createElement('tbody');
        console.log(`📊 Generating table for ${weekKey}:`, rotaData[weekKey]);
        rotaData[weekKey].forEach(row => {
          const tr = document.createElement('tr');
          const tdRole = document.createElement('td');
          tdRole.textContent = row.role;
          tr.appendChild(tdRole);

          row.days.forEach((day, dayIndex) => {
            const td = document.createElement('td');
            
            // Handle new data structure with assignments
            let displayText = '';
            let isMultipleStaff = false;
            let flagIndicators = '';
            
            if (typeof day === 'object' && day !== null && day.assignments) {
              // New format with detailed assignments
              displayText = day.displayText || '';
              isMultipleStaff = day.assignments && day.assignments.length > 1;
              
              // Generate flag indicators (excluding payment period end)
              if (day.assignments && day.assignments.length > 0) {
                const flags = [];
                let hasStyledFlags = false;
                day.assignments.forEach(assignment => {
                  if (assignment.soloShift) flags.push('🚨');
                  if (assignment.training) flags.push('📚');
                  if (assignment.shortNotice) flags.push('⚠️');
                  if (assignment.overtime) flags.push('⏰');
                  if (assignment.callout) flags.push('📞');
                  // Check if we have any flags that should be styled
                  if (assignment.soloShift || assignment.training || assignment.shortNotice || assignment.overtime || assignment.callout) {
                    hasStyledFlags = true;
                  }
                  // Removed payment period end flag from cell display
                });
                if (flags.length > 0) {
                  flagIndicators = `\n${flags.join(' ')}`;
                }
                // Force styled indicators if we have callout flag
                if (hasStyledFlags) {
                  flagIndicators = 'styled'; // This will trigger the styled flag display
                }
              }
              
              // Store the assignments data for later use
              td.dataset.assignments = JSON.stringify(day.assignments);
              
            } else {
              // Legacy format (just string)
              displayText = day || '';
              isMultipleStaff = displayText && displayText.includes(',');
            }
            
            // Check if any assignment has notes
            let hasNotes = false;
            if (typeof day === 'object' && day !== null && day.assignments) {
              hasNotes = day.assignments.some(assignment => assignment.notes && assignment.notes.trim() !== '');
            }
            
            // Set cell content with flags
            if (flagIndicators || (typeof day === 'object' && day !== null && day.assignments && day.assignments.some(assignment => assignment.soloShift || assignment.training || assignment.shortNotice || assignment.overtime || assignment.callout))) {
              // Create styled flag indicators (excluding payment period end)
              const flagHtml = day.assignments.map(assignment => {
                const flags = [];
                if (assignment.soloShift) flags.push('<span class="flag-indicator solo-shift">Solo</span>');
                if (assignment.training) flags.push('<span class="flag-indicator training">Training</span>');
                if (assignment.shortNotice) flags.push('<span class="flag-indicator short-notice"><12h Notice</span>');
                if (assignment.overtime) flags.push('<span class="flag-indicator overtime">Overtime</span>');
                if (assignment.callout) flags.push('<span class="flag-indicator callout">Call-out</span>');
                // Removed payment period end flag from styled indicators
                return flags.join('');
              }).join('');
              
              const noteIcon = hasNotes ? '<div class="note-icon" title="Has notes">📝</div>' : '';
              
              td.innerHTML = `<div style="text-align: center; position: relative;">
                <div style="font-weight: 600; margin-bottom: 4px;">${displayText}</div>
                <div class="flag-indicators">${flagHtml}</div>
                ${noteIcon}
              </div>`;
            } else {
              const noteIcon = hasNotes ? '<div class="note-icon" title="Has notes">📝</div>' : '';
              
              td.innerHTML = `<div style="position: relative;">
                ${displayText}
                ${noteIcon}
              </div>`;
            }
            td.classList.add('editable-cell');
            
            // Check for custom color first
            const cellKey = `w${weekIndex}_r${rotaData[weekKey].indexOf(row)}_d${dayIndex}`;
            if (customCellColors[cellKey]) {
              td.style.backgroundColor = customCellColors[cellKey];
            } else if (staffColors[displayText]) {
              td.style.backgroundColor = staffColors[displayText];
            }
            
            // Check if this column should be highlighted as payment period end
            if (isPaymentPeriodEndColumn(weekIndex, dayIndex, new Date(startDate.getTime() + dayIndex * 24 * 60 * 60 * 1000))) {
              td.classList.add('payment-period-end-column');
              
              // Automatically set payment period end flag for Friday of first week
              if (weekIndex === 0 && dayIndex === 4) { // Friday of first week
                if (rotaData[weekKey] && rotaData[weekKey].length > 0) {
                  for (let rowIndex = 0; rowIndex < rotaData[weekKey].length; rowIndex++) {
                    const day = rotaData[weekKey][rowIndex].days[dayIndex];
                    if (day && typeof day === 'object' && day.assignments) {
                      for (const assignment of day.assignments) {
                        assignment.paymentPeriodEnd = true;
                        console.log(`💰 Auto-set payment period end flag for ${assignment.staffName || 'staff member'} on Friday of first week`);
                      }
                    }
                  }
                }
              }
            }
            
            // Check if this column should be highlighted as financial year end
            const cellDate = new Date(startDate.getTime() + dayIndex * 24 * 60 * 60 * 1000);
            if (isFinancialYearEndColumn(weekIndex, dayIndex, cellDate)) {
              td.classList.add('financial-year-end-column');
              console.log(`💰 Financial year end cell highlighted for ${cellDate.toLocaleDateString('en-GB')}`);
              
              // Automatically set financial year end flag for all assignments in this column
              if (rotaData[weekKey] && rotaData[weekKey].length > 0) {
                for (let rowIndex = 0; rowIndex < rotaData[weekKey].length; rowIndex++) {
                  const day = rotaData[weekKey][rowIndex].days[dayIndex];
                  if (day && typeof day === 'object' && day.assignments) {
                    for (const assignment of day.assignments) {
                      assignment.financialYearEnd = true;
                      console.log(`💰 Auto-set financial year end flag for ${assignment.staffName || 'staff member'}`);
                    }
                  }
                }
              }
            }
            
            // Check if this cell should be highlighted as current date
            if (isCurrentDate(cellDate)) {
              td.classList.add('current-date-cell');
            }
            
            // Apply appropriate classes based on content
            if (isMultipleStaff) {
              td.classList.add('multiple-staff-cell');
            }
            

            
            // Add click event for editing
            td.addEventListener('click', async (e) => {
              e.stopPropagation();
              
              if (multiSelectMode) {
                // In multi-select mode, toggle selection
                toggleCellSelection(td, weekIndex, rotaData[weekKey].indexOf(row), dayIndex);
              } else {
                // Normal mode - show compact popup for all cells
                await createDropdown(td, weekIndex, rotaData[weekKey].indexOf(row), dayIndex);
              }
            });
            
            // Right-click context menu removed
            

            
            // Add hover event for detailed tooltip
            if (isMultipleStaff) {
              td.title = `Multiple staff assigned. Click to edit.`;
              td.style.cursor = 'pointer';
            } else if (displayText && displayText.trim() !== '') {
              td.title = `Click to edit staff assignment.`;
              td.style.cursor = 'pointer';
            }
            
            tr.appendChild(td);
          });

          tbody.appendChild(tr);
        });
        table.appendChild(tbody);

        // Add a heading for each table
        const weekHeading = document.createElement('h2');
        weekHeading.className = 'week-heading';
        weekHeading.textContent = `Week ${weekIndex + 1}`;
        
        // For Week 1, create a special container with the print button
        if (weekIndex === 0) {
          const week1Container = document.createElement('div');
          week1Container.className = 'week1-header-container';
          
          const week1Header = document.createElement('div');
          week1Header.className = 'week1-header';
          week1Header.appendChild(weekHeading);
          
          // Create a new print button if the original one doesn't exist or is hidden
          let printBtn = document.getElementById('print-rota-btn');
          if (!printBtn || printBtn.style.display === 'none') {
            printBtn = document.createElement('button');
            printBtn.id = 'print-rota-btn';
            printBtn.className = 'print-btn';
            printBtn.title = 'Print Rota Tables';
            printBtn.innerHTML = '🖨️ Print';
            
            // Add the event listener
            printBtn.addEventListener('click', printRotaTables);
          } else {
            // Move the existing print button
            printBtn.parentNode.removeChild(printBtn);
          }
          
          week1Header.appendChild(printBtn);
          week1Container.appendChild(week1Header);
          week1Container.appendChild(table);
          container.appendChild(week1Container);
        } else {
          container.appendChild(weekHeading);
          container.appendChild(table);
        }
      });
    }
    
    // Function to check if a column should be highlighted as payment period end
    function isPaymentPeriodEndColumn(weekIndex, dayIndex, date) {
      // Default: Friday of first week (weekIndex === 0, dayIndex === 4 for Friday)
      if (weekIndex === 0 && dayIndex === 4) {
        return true;
      }
      
      // Check if any assignment in this column has payment period end flag
      const weekKey = `week${weekIndex + 1}`;
      if (rotaData[weekKey] && rotaData[weekKey].length > 0) {
        for (let rowIndex = 0; rowIndex < rotaData[weekKey].length; rowIndex++) {
          const day = rotaData[weekKey][rowIndex].days[dayIndex];
          if (day && typeof day === 'object' && day.assignments) {
            for (const assignment of day.assignments) {
              if (assignment.paymentPeriodEnd) {
                return true;
              }
            }
          }
        }
      }
      return false;
    }
    
    // Function to check if a column should be highlighted as financial year end
    function isFinancialYearEndColumn(weekIndex, dayIndex, date) {
      // First check if this is April 5th (financial year end)
      const month = date.getMonth() + 1; // getMonth() returns 0-11
      const day = date.getDate();
      
      if (month === 4 && day === 5) {
        console.log(`💰 Financial year end detected: ${date.toLocaleDateString('en-GB')}`);
        return true;
      }
      
      // Also check if any assignment in this column has financial year end flag
      const weekKey = `week${weekIndex + 1}`;
      if (rotaData[weekKey] && rotaData[weekKey].length > 0) {
        for (let rowIndex = 0; rowIndex < rotaData[weekKey].length; rowIndex++) {
          const day = rotaData[weekKey][rowIndex].days[dayIndex];
          if (day && typeof day === 'object' && day.assignments) {
            for (const assignment of day.assignments) {
              if (assignment.financialYearEnd) {
                return true;
              }
            }
          }
        }
      }
      return false;
    }

    // Function to check if a date is today
    function isCurrentDate(date) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const checkDate = new Date(date);
      checkDate.setHours(0, 0, 0, 0);
      return checkDate.getTime() === today.getTime();
    }
    
    // Function to show payment period end popup
    function showPaymentPeriodEndPopup(weekIndex, dayIndex, date) {
      console.log(`💰 Showing payment period end popup for column: Week ${weekIndex + 1}, Day ${dayIndex + 1}, Date: ${date.toDateString()}`);
      
      const weekKey = `week${weekIndex + 1}`;
      if (!rotaData[weekKey]) {
        console.warn('⚠️ Week data not found:', weekKey);
        return;
      }
      
      // Check if any assignment in this column already has the flags
      let hasPaymentPeriodEnd = false;
      let hasFinancialYearEnd = false;
      for (let rowIndex = 0; rowIndex < rotaData[weekKey].length; rowIndex++) {
        const day = rotaData[weekKey][rowIndex].days[dayIndex];
        if (day && typeof day === 'object' && day.assignments) {
          for (const assignment of day.assignments) {
            if (assignment.paymentPeriodEnd) {
              hasPaymentPeriodEnd = true;
            }
            if (assignment.financialYearEnd) {
              hasFinancialYearEnd = true;
            }
          }
        }
      }
      
      // Create popup
      const popup = document.createElement('div');
      popup.className = 'payment-period-end-popup';
      popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        padding: 25px;
        z-index: 10000;
        min-width: 350px;
        max-width: 450px;
        border: 2px solid #f39c12;
      `;
      
      const dateString = date.toLocaleDateString('en-GB', { 
        weekday: 'long', 
        day: 'numeric', 
        month: 'long', 
        year: 'numeric' 
      });
      
      popup.innerHTML = `
        <div style="text-align: center; margin-bottom: 20px;">
          <h3 style="margin: 0 0 8px 0; color: #2c3e50; font-size: 18px;">Column Flags</h3>
          <p style="margin: 0; color: #7f8c8d; font-size: 14px;">${dateString}</p>
        </div>
        
        <div style="margin-bottom: 20px;">
          <label style="display: flex; align-items: center; gap: 12px; font-size: 16px; color: #2c3e50; cursor: pointer; padding: 12px; border-radius: 8px; background: #f8f9fa; border: 2px solid #e9ecef;">
            <input type="checkbox" id="payment-period-end-checkbox" ${hasPaymentPeriodEnd ? 'checked' : ''} style="width: 20px; height: 20px; accent-color: #f39c12;">
            <span style="font-weight: 600; color: #f39c12;">Pay Date</span>
          </label>
          <p style="margin: 8px 0 0 0; font-size: 12px; color: #7f8c8d; font-style: italic;">
            This will highlight the entire column in orange and mark all assignments for this day as payment date.
          </p>
        </div>
        
        <div style="margin-bottom: 25px;">
          <label style="display: flex; align-items: center; gap: 12px; font-size: 16px; color: #2c3e50; cursor: pointer; padding: 12px; border-radius: 8px; background: #f8f9fa; border: 2px solid #e9ecef;">
            <input type="checkbox" id="financial-year-end-checkbox" ${hasFinancialYearEnd ? 'checked' : ''} style="width: 20px; height: 20px; accent-color: #e74c3c;">
            <span style="font-weight: 600; color: #e74c3c;">End of Financial Year</span>
          </label>
          <p style="margin: 8px 0 0 0; font-size: 12px; color: #7f8c8d; font-style: italic;">
            This will highlight the entire column in red and mark all assignments for this day as end of financial year.
          </p>
        </div>
        
        <div style="display: flex; gap: 12px; justify-content: flex-end;">
          <button id="cancel-payment-popup" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer; transition: background 0.2s;">Cancel</button>
          <button id="save-payment-popup" style="padding: 10px 20px; background: #f39c12; color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; transition: background 0.2s;">Save Changes</button>
        </div>
      `;
      
      document.body.appendChild(popup);
      
      // Add event listeners
      const paymentCheckbox = popup.querySelector('#payment-period-end-checkbox');
      const financialCheckbox = popup.querySelector('#financial-year-end-checkbox');
      const cancelBtn = popup.querySelector('#cancel-payment-popup');
      const saveBtn = popup.querySelector('#save-payment-popup');
      
      // Cancel button
      cancelBtn.addEventListener('click', () => {
        popup.remove();
      });
      
      // Save button
      saveBtn.addEventListener('click', async () => {
        const newPaymentFlagValue = paymentCheckbox.checked;
        const newFinancialFlagValue = financialCheckbox.checked;
        console.log(`💰 Setting payment period end flag to ${newPaymentFlagValue} for entire column`);
        console.log(`💰 Setting financial year end flag to ${newFinancialFlagValue} for entire column`);
        
        // Update all assignments in this column
        for (let rowIndex = 0; rowIndex < rotaData[weekKey].length; rowIndex++) {
          const day = rotaData[weekKey][rowIndex].days[dayIndex];
          if (day && typeof day === 'object' && day.assignments) {
            for (const assignment of day.assignments) {
              assignment.paymentPeriodEnd = newPaymentFlagValue;
              assignment.financialYearEnd = newFinancialFlagValue;
              console.log(`💰 Updated assignment for ${assignment.staffName}: paymentPeriodEnd = ${newPaymentFlagValue}, financialYearEnd = ${newFinancialFlagValue}`);
            }
          }
        }
        
        // Save changes to database
        try {
          await saveColumnFlagChanges(weekIndex, dayIndex, newPaymentFlagValue, newFinancialFlagValue);
          
          // Regenerate tables to show the updated highlighting
          generateTables();
          
          // Show feedback to user
          let message = '';
          if (newPaymentFlagValue && newFinancialFlagValue) {
            message = `💰 Both flags set for ${dateString}`;
          } else if (newPaymentFlagValue) {
            message = `💰 Payment period end flag set for ${dateString}`;
          } else if (newFinancialFlagValue) {
            message = `💰 Financial year end flag set for ${dateString}`;
          } else {
            message = `💰 All flags removed for ${dateString}`;
          }
          
          showNotification(message, 'success');
          
          // Close popup
          popup.remove();
        } catch (error) {
          console.error('❌ Error saving column flag changes:', error);
          showNotification('❌ Error saving changes. Please try again.', 'error');
        }
      });
      
      // Close popup when clicking outside
      popup.addEventListener('click', (e) => {
        if (e.target === popup) {
          popup.remove();
        }
      });
      
      // Close popup with Escape key
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          popup.remove();
          document.removeEventListener('keydown', escapeHandler);
        }
      };
      document.addEventListener('keydown', escapeHandler);
    }
    
    // Function to save column flag changes to database
    async function saveColumnFlagChanges(weekIndex, dayIndex, paymentFlagValue, financialFlagValue) {
      console.log(`💾 Saving column flag changes: Week ${weekIndex + 1}, Day ${dayIndex + 1}, Payment Flag: ${paymentFlagValue}, Financial Flag: ${financialFlagValue}`);
      
      const weekKey = `week${weekIndex + 1}`;
      const currentPeriod = allPeriods[currentPeriodIndex];
      
      if (!currentPeriod) {
        throw new Error('No current period found');
      }
      
      // Get all assignments for this column that need to be updated
      const assignmentsToUpdate = [];
      
      for (let rowIndex = 0; rowIndex < rotaData[weekKey].length; rowIndex++) {
        const day = rotaData[weekKey][rowIndex].days[dayIndex];
        if (day && typeof day === 'object' && day.assignments) {
          for (const assignment of day.assignments) {
            if (assignment.staffName) {
              assignmentsToUpdate.push({
                ...assignment,
                paymentPeriodEnd: paymentFlagValue,
                financialYearEnd: financialFlagValue
              });
            }
          }
        }
      }
      
      if (assignmentsToUpdate.length === 0) {
        console.log('ℹ️ No assignments to update for payment period end flag');
        return;
      }
      
      // Save each assignment with updated flag
      for (const assignment of assignmentsToUpdate) {
        try {
          // Find the row index for this assignment
          let foundRowIndex = -1;
          for (let rowIndex = 0; rowIndex < rotaData[weekKey].length; rowIndex++) {
            const day = rotaData[weekKey][rowIndex].days[dayIndex];
            if (day && typeof day === 'object' && day.assignments) {
              const foundAssignment = day.assignments.find(a => a.staffName === assignment.staffName);
              if (foundAssignment) {
                foundRowIndex = rowIndex;
                break;
              }
            }
          }
          
          if (foundRowIndex !== -1) {
            await saveShiftToDatabase(weekIndex, foundRowIndex, dayIndex, [assignment]);
          } else {
            console.warn(`⚠️ Could not find row index for assignment: ${assignment.staffName}`);
          }
        } catch (error) {
          console.error(`❌ Error saving assignment for ${assignment.staffName}:`, error);
          throw error;
        }
      }
      
      console.log(`✅ Successfully updated payment period end flag for ${assignmentsToUpdate.length} assignments`);
    }
    
    // Function to show notifications
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      `;
      
      if (type === 'success') {
        notification.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
      } else if (type === 'error') {
        notification.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
      } else {
        notification.style.background = 'linear-gradient(135deg, #17a2b8 0%, #138496 100%)';
      }
      
      notification.textContent = message;
      document.body.appendChild(notification);
      
      // Remove notification after 3 seconds
      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-in';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }, 3000);
    }
    
    // Add CSS animations for notifications
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      @keyframes slideOut {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
      }
    `;
    document.head.appendChild(style);
    

    
    // Initialize the application
    async function init() {
      console.log('🚀 Initializing application with database connection');
      
      try {
        // Initialize periods first
        console.log('📅 Initializing periods...');
        await initializePeriods();
        console.log('✅ Periods initialized');
        
        // Ensure database is properly initialized first
        console.log('🔧 Checking database initialization...');
        const dbInitialized = await ensureDatabaseInitialized();
        if (!dbInitialized) {
          throw new Error('Database initialization failed');
        }
        
        // Load data from database first
        console.log('📊 Loading initial data from database...');
        await loadDataFromDatabase();
        console.log('✅ Initial data loading completed');
        
        // Update UI components
        console.log('🔄 Updating UI components...');
        updateStaffList();
        
        // Always generate tables, even with empty data
        console.log('📊 Generating tables...');
        generateTables();
        console.log('✅ Tables generated');
        
        await displayEmployeeSummaries();
        
        // Set up event listeners after a short delay to ensure DOM is ready
        setTimeout(() => {
          setupStaffManagementEventListeners();
  
        }, 100);
        
        // Add navigation event listeners
        document.getElementById('prev-period').addEventListener('click', () => {
          changePeriod(currentPeriodIndex - 1);
        });
        
        document.getElementById('next-period').addEventListener('click', () => {
          changePeriod(currentPeriodIndex + 1);
        });
        
        document.getElementById('period-selector').addEventListener('change', (e) => {
          changePeriod(parseInt(e.target.value));
        });
        
        // Add event listener for Shift Summary period selector
        const summaryPeriodSelector = document.getElementById('summary-period-selector');
        if (summaryPeriodSelector) {
          summaryPeriodSelector.addEventListener('change', (e) => {
            const selectedIndex = parseInt(e.target.value);
            if (!isNaN(selectedIndex) && selectedIndex >= 0) {
              changePeriod(selectedIndex);
            }
          });
        }
        
        // Initialize navigation
        populatePeriodSelector();
        updatePeriodTitle();
        updateNavigationButtons();
        
        // Initialize tabs
        initTabs();
        
        // Ensure rota tab is visible by default
        console.log('🔍 Ensuring rota tab is visible...');
        const rotaTab = document.getElementById('rota-tab');
        const staffTab = document.getElementById('staff-tab');
        if (rotaTab && staffTab) {
          rotaTab.classList.add('active');
          staffTab.classList.remove('active');
          console.log('✅ Rota tab set as active');
        } else {
          console.error('❌ Tab elements not found!');
        }
        

        

        

        
        // Set up real-time sync for active user sessions
        let lastUserAction = Date.now();
        const userActivityTimeout = 5000; // 5 seconds
        
        // Track user activity
        document.addEventListener('click', () => {
          lastUserAction = Date.now();
        });
        
        document.addEventListener('keydown', () => {
          lastUserAction = Date.now();
        });
        

        
        console.log('✅ Application initialization completed successfully');
        
        // Setup print button event listener
        const printBtn = document.getElementById('print-rota-btn');
        if (printBtn) {
          printBtn.addEventListener('click', printRotaTables);
        }
        
        // Show success message
        const successMsg = document.createElement('div');
        successMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #28a745;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        successMsg.textContent = '✅ Application loaded successfully!';
        document.body.appendChild(successMsg);
        
        setTimeout(() => {
          successMsg.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => successMsg.remove(), 300);
        }, 2000);
        
      } catch (error) {
        console.error('❌ Error during application initialization:', error);
        
        // Show error message
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc3545;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        errorMsg.textContent = '❌ Failed to initialize application!';
        document.body.appendChild(errorMsg);
        
        setTimeout(() => {
          errorMsg.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => errorMsg.remove(), 300);
        }, 3000);
      }
    }
    // Function to set up staff management event listeners
    function setupStaffManagementEventListeners() {
      console.log('🔧 Setting up staff management event listeners...');
      
      const addStaffBtn = document.getElementById('dashboard-add-staff-btn');
      const submitBtn = document.getElementById('submit-staff-btn');
      const cancelBtn = document.getElementById('cancel-staff-btn');
      const inputField = document.getElementById('new-staff-input');
      
      if (addStaffBtn) {
        console.log('✅ Found dashboard add staff button');
        addStaffBtn.addEventListener('click', () => {
          console.log('🖱️ Dashboard Add Staff button clicked');
          const form = document.getElementById('add-staff-form');
          if (form) {
            form.style.display = 'block';
            console.log('✅ Form displayed');
            const input = document.getElementById('new-staff-input');
            if (input) {
              input.focus();
              console.log('✅ Input focused');
            } else {
              console.error('❌ Input element not found');
            }
          } else {
            console.error('❌ Form element not found');
          }
        });
      } else {
        console.error('❌ Dashboard add staff button not found');
      }
      
      if (submitBtn) {
        console.log('✅ Found submit staff button');
        submitBtn.addEventListener('click', () => {
          console.log('🖱️ Submit Staff button clicked');
          
          // Collect all form data
          const staffData = {
            name: document.getElementById('new-staff-input').value,
            role: document.getElementById('new-staff-role').value,
            employment_start_date: document.getElementById('new-staff-employment-date').value,
            employment_end_date: document.getElementById('new-staff-employment-end-date').value || null,
            contracted_hours: document.getElementById('new-staff-contracted-hours').value || null,
            pay_rate: document.getElementById('new-staff-pay-rate').value || null
          };
          
          console.log('📝 Form data collected:', staffData);
          
          if (staffData.name && staffData.employment_start_date) {
            addStaffMember(staffData);
            document.getElementById('add-staff-form').style.display = 'none';
            // Clear form
            Object.keys(staffData).forEach(key => {
              const element = document.getElementById(`new-staff-${key.replace('_', '-')}`);
              if (element) element.value = '';
            });
          } else {
            alert('Please fill in the required fields (Name and Employment Start Date)');
          }
        });
      } else {
        console.error('❌ Submit staff button not found');
      }
      
      if (cancelBtn) {
        console.log('✅ Found cancel staff button');
        cancelBtn.addEventListener('click', () => {
          console.log('🖱️ Cancel Staff button clicked');
          document.getElementById('add-staff-form').style.display = 'none';
          // Clear all form fields
          const formFields = ['new-staff-input', 'new-staff-role', 'new-staff-employment-date', 'new-staff-employment-end-date', 'new-staff-contracted-hours', 'new-staff-pay-rate'];
          formFields.forEach(fieldId => {
            const element = document.getElementById(fieldId);
            if (element) element.value = '';
          });
        });
      } else {
        console.error('❌ Cancel staff button not found');
      }
      
      if (inputField) {
        console.log('✅ Found new staff input field');
        inputField.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            console.log('🖱️ Enter key pressed in input field');
            addStaffMember(e.target.value);
            document.getElementById('add-staff-form').style.display = 'none';
            e.target.value = '';
          }
        });
      } else {
        console.error('❌ New staff input field not found');
      }
      
      console.log('✅ Staff management event listeners setup complete');
    }


    
    // Function to generate random colors for staff members
    function getRandomColor() {
      const colors = [
        '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
        '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
        '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2'
      ];
      return colors[Math.floor(Math.random() * colors.length)];
    }
    
    // Load data from database
    async function loadDataFromDatabase() {
      try {
        console.log('🔄 Loading data from database...');
        
        // Load staff members first
        console.log('👥 Loading staff members...');
        const staffMembers = await apiService.getStaffMembers();
        console.log('✅ Staff members loaded:', staffMembers.length);
        
        // Update global staff members variable with role information
        window.globalStaffMembers = staffMembers;
        console.log('📋 Global staff members updated:', window.globalStaffMembers.map(s => ({ name: s.staff_name, role: s.role })));
        
        if (staffMembers.length > 0) {
          console.log('🔄 Rebuilding availableNames array from database...');
          
          // Clear and rebuild availableNames array
          availableNames = ['']; // Start with empty string
          
          // Clear and rebuild staffColors object
          staffColors = { '': '' }; // Keep empty string
          
                     staffMembers.forEach(staff => {
             // Only add active staff members to availableNames
             if (staff.is_active !== false) { // Default to true if not set
             availableNames.push(staff.staff_name);
             
             // Use color_code from database or fallback to predefined colors
             const predefinedColors = {
               'Helen': '#EE0000',
               'Fung': '#FFFF00', 
               'Anne': '#00B050',
               'Annie': '#247A00',
               'Lisa': '#CC99FF',
               'Janet': '#FF66FF',
               'Clara': '#0070C0',
               'John': '#00B0F0',
               'Vania': '#7030A0',
               'Yasser': '#C4BC96',
               'Matt': '#FFC000',
               'FW': '#935CC3',
               'HC': '#D52BD5'
             };
             
             // Check if color_code property exists on staff object
             const colorCode = staff.hasOwnProperty('color_code') ? staff.color_code : null;
             staffColors[staff.staff_name] = colorCode || predefinedColors[staff.staff_name] || getRandomColor();
            
              console.log(`✅ Loaded active staff member: ${staff.staff_name} (${staff.role}) with color: ${staffColors[staff.staff_name]}`);
                         } else {
               // Still assign colors for inactive staff (for display purposes)
               const colorCode = staff.hasOwnProperty('color_code') ? staff.color_code : null;
               staffColors[staff.staff_name] = colorCode || predefinedColors[staff.staff_name] || getRandomColor();
              
              console.log(`⚠️ Loaded inactive staff member: ${staff.staff_name} (${staff.role}) - not available for assignment`);
            }
          });
          
          console.log('📊 Staff members loaded from database:', staffMembers.length);
          console.log('📋 Available names after loading:', availableNames);
          console.log('🎨 Staff colors after loading:', Object.keys(staffColors).filter(key => key !== ''));
          
          // Immediately update the staff list display
          console.log('🔄 Updating staff list display after loading...');
          updateStaffList();
          
          // Update tab visibility based on staff status
          console.log('🔄 Updating tab visibility based on staff status...');
          await updateTabVisibility();
          
          // Debug: Log the current state
          console.log('🔍 Current state after staff loading:', {
            availableNames: availableNames,
            staffColors: Object.keys(staffColors).filter(key => key !== ''),
            rotaData: rotaData
          });
        } else {
          console.log('⚠️ No staff members found in database');
          // Still update the staff list to clear it
          updateStaffList();
        }
        
        // Load periods from database
        console.log('📅 Loading periods from database...');
        const periods = await apiService.getPeriods();
        console.log('✅ Periods loaded:', periods.length);
        
        if (periods && periods.length > 0) {
          // Remember the current period ID before updating allPeriods
          const previousCurrentPeriod = allPeriods[currentPeriodIndex];
          const previousPeriodId = previousCurrentPeriod ? previousCurrentPeriod.period_id : null;
          console.log('📅 Previous current period ID:', previousPeriodId);
          
          // Update allPeriods with database data
          allPeriods = periods.map(period => {
            const startDate = new Date(period.start_date);
            const endDate = new Date(period.end_date);
            const formattedStartDate = startDate.toLocaleDateString('en-GB', { 
              day: 'numeric', 
              month: 'long', 
              year: 'numeric' 
            });
            const formattedEndDate = endDate.toLocaleDateString('en-GB', { 
              day: 'numeric', 
              month: 'long', 
              year: 'numeric' 
            });
            
            return {
              period_id: period.period_id,
              title: `${formattedStartDate} to ${formattedEndDate}`,
              start: startDate,
              end: endDate,
              weeks: [
                new Date(period.start_date),
                new Date(new Date(period.start_date).getTime() + 7 * 24 * 60 * 60 * 1000),
                new Date(new Date(period.start_date).getTime() + 14 * 24 * 60 * 60 * 1000),
                new Date(new Date(period.start_date).getTime() + 21 * 24 * 60 * 60 * 1000)
              ]
            };
          });
          
          console.log('📅 Periods loaded from database:', allPeriods.length);
          console.log('📅 Previous period index:', currentPeriodIndex);
          console.log('📅 Available periods:', allPeriods.map((p, i) => `${i}: ${p.title}`));
          
          // Try to maintain the same period by finding it by period_id
          if (previousPeriodId) {
            const newCurrentIndex = allPeriods.findIndex(p => p.period_id === previousPeriodId);
            if (newCurrentIndex !== -1) {
              currentPeriodIndex = newCurrentIndex;
              console.log('✅ Maintained current period by ID, new index:', currentPeriodIndex);
            } else {
              console.log('⚠️ Previous period not found by ID, keeping index');
            }
          }
          
          // Ensure currentPeriodIndex is valid
          if (currentPeriodIndex >= allPeriods.length) {
            currentPeriodIndex = 0;
            console.log('⚠️ Adjusted currentPeriodIndex to 0');
          }
          
          console.log('📅 Final current period index:', currentPeriodIndex);
          console.log('📅 Final current period:', allPeriods[currentPeriodIndex]);
          
          // Load existing shifts for the current period
          console.log('📊 Loading shifts for current period...');
          const currentPeriod = allPeriods[currentPeriodIndex];
          if (currentPeriod) {
            console.log('📅 Current period:', currentPeriod);
            console.log('📅 Current period ID:', currentPeriod.period_id);
            
            const shifts = await apiService.getShiftsForPeriod(currentPeriod.period_id);
            console.log('📊 Shifts loaded from database:', shifts.length);
            console.log('📊 Raw shifts data:', shifts);
            
            
            // Clear existing rota data first
            Object.keys(rotaData).forEach(weekKey => {
              rotaData[weekKey].forEach(row => {
                row.days.fill('');
              });
            });
            
            // Group shifts by time slot and shift type to handle multiple staff assignments
            const shiftGroups = {};
            shifts.forEach(shift => {
              // Create a unique key based on period, week, date, shift type, and time slot
              const shiftDate = new Date(shift.shift_start_datetime);
              const dateString = shiftDate.toISOString().split('T')[0]; // Get just the date part
              const timeSlot = shift.shift_start_datetime.split('T')[1].substring(0, 5); // Get HH:MM part
              const groupKey = `${shift.period_id}_${shift.week_number}_${dateString}_${shift.shift_type}_${timeSlot}`;
              if (!shiftGroups[groupKey]) {
                shiftGroups[groupKey] = [];
              }
              shiftGroups[groupKey].push(shift);
            });
            
            console.log('📊 Shift groups created:', Object.keys(shiftGroups).length);
            
            // Process each unique shift group
            Object.keys(shiftGroups).forEach(groupKey => {
              const shiftAssignments = shiftGroups[groupKey];
              const firstShift = shiftAssignments[0]; // Use first shift for common data
              
              console.log(`🔄 Processing shift group ${groupKey}:`, {
                staffCount: shiftAssignments.length,
                staffNames: shiftAssignments.map(s => s.staff_name),
                weekNumber: firstShift.week_number,
                shiftType: firstShift.shift_type,
                startDate: firstShift.shift_start_datetime,
                dateString: new Date(firstShift.shift_start_datetime).toISOString().split('T')[0]
              });
              
              const weekKey = `week${firstShift.week_number}`;
              const weekIndex = firstShift.week_number - 1;
              
              // Calculate the day index based on the shift start date
              const shiftStartDate = new Date(firstShift.shift_start_datetime);
              const weekStartDate = new Date(currentPeriod.weeks[weekIndex]);
              
              // Normalize dates to local timezone for accurate day calculation
              const shiftStartLocal = new Date(shiftStartDate.getFullYear(), shiftStartDate.getMonth(), shiftStartDate.getDate());
              const weekStartLocal = new Date(weekStartDate.getFullYear(), weekStartDate.getMonth(), weekStartDate.getDate());
              
              const dayIndex = Math.floor((shiftStartLocal - weekStartLocal) / (24 * 60 * 60 * 1000));
              
              console.log(`📅 Date calculations:`, {
                shiftStartDate: shiftStartDate.toISOString(),
                weekStartDate: weekStartDate.toISOString(),
                shiftStartLocal: shiftStartLocal.toISOString(),
                weekStartLocal: weekStartLocal.toISOString(),
                dayIndex: dayIndex,
                shiftStartDateLocal: shiftStartDate.toLocaleDateString(),
                weekStartDateLocal: weekStartDate.toLocaleDateString(),
                dayDifference: Math.floor((shiftStartLocal - weekStartLocal) / (24 * 60 * 60 * 1000))
              });
              
              // Validate day index
              if (dayIndex < 0 || dayIndex > 6) {
                console.warn(`⚠️ Invalid day index ${dayIndex} for shift group ${groupKey}, skipping. Shift date: ${shiftStartDate.toLocaleDateString()}, Week start: ${weekStartDate.toLocaleDateString()}`);
                return;
              }
              
              // Find the appropriate row based on shift type
              let rowIndex = 0; // Default to first row
              if (firstShift.shift_type === 'Tom Night') {
                rowIndex = 3; // Tom Night
              } else if (firstShift.shift_type === 'Tom Day') {
                rowIndex = 0; // Tom Day
              } else if (firstShift.shift_type === 'Charlotte Day') {
                rowIndex = 1; // Charlotte Day
              } else if (firstShift.shift_type === 'Double Up') {
                rowIndex = 2; // Double Up
              } else if (firstShift.shift_type === 'Charlotte Night') {
                rowIndex = 4; // Charlotte Night
              } else if (firstShift.shift_type === 'HOLIDAY') {
                rowIndex = 5; // HOLIDAY
              }
              
              console.log(`📍 Row assignment:`, {
                shiftType: firstShift.shift_type,
                rowIndex: rowIndex,
                weekKey: weekKey,
                rotaDataExists: !!rotaData[weekKey],
                rowExists: rotaData[weekKey] ? !!rotaData[weekKey][rowIndex] : false
              });
              
              // Update the rota data with detailed assignment information
              if (rotaData[weekKey] && rotaData[weekKey][rowIndex]) {
                // Create detailed assignment objects with timing information
                const assignments = shiftAssignments.map(shift => {
                  // Extract time information from shift datetime
                  const shiftStart = new Date(shift.shift_start_datetime);
                  const shiftEnd = new Date(shift.shift_end_datetime);
                  
                  // Format times as HH:MM
                  const startTime = shiftStart.toTimeString().substring(0, 5);
                  const endTime = shiftEnd.toTimeString().substring(0, 5);
                  
                  console.log(`🕐 Extracted times for ${shift.staff_name}: ${startTime} to ${endTime}`);
                  
                  const assignment = {
                    staffName: shift.staff_name,
                    startTime: startTime,
                    endTime: endTime,
                    shiftId: shift.shift_id,
                    periodId: shift.period_id,
                        soloShift: shift.solo_shift || false,
                        training: shift.training || false,
                        shortNotice: shift.short_notice || false,
                        callout: shift.call_out || false,
                        overtime: shift.overtime || false,
                    paymentPeriodEnd: shift.payment_period_end || false,
                    financialYearEnd: shift.financial_year_end || false,
                    notes: shift.notes || ''
                  };
                  
                  console.log('🔄 Created assignment from database:', assignment);
                  console.log('🚩 Database shift object had these properties:', Object.keys(shift));
                  console.log('🚩 Flag values from database:', {
                    solo_shift: shift.solo_shift,
                    training: shift.training,
                    short_notice: shift.short_notice,
                    call_out: shift.call_out,
                    overtime: shift.overtime
                  });
                  
                  return assignment;
                });
                
                // Store both the display text and the detailed assignments
                const staffNames = shiftAssignments.map(s => s.staff_name).join(', ');
                
                // Check if there's already content in this cell
                const existingContent = rotaData[weekKey][rowIndex].days[dayIndex];
                if (existingContent && typeof existingContent === 'object' && existingContent.assignments) {
                  // Combine with existing assignments
                  const existingAssignments = existingContent.assignments || [];
                  const combinedAssignments = [...existingAssignments, ...assignments];
                  rotaData[weekKey][rowIndex].days[dayIndex] = {
                    displayText: `${existingContent.displayText || existingContent}, ${staffNames}`,
                    assignments: combinedAssignments
                  };
                  console.log(`✅ Combined shift assignments: ${staffNames} with existing for ${weekKey}, day ${dayIndex + 1}, row ${rowIndex}`);
                } else if (existingContent && existingContent.trim() !== '') {
                  // Convert existing string content to object format
                  // Try to find actual times from database for these staff members
                  const existingStaffNames = existingContent.split(',').map(name => name.trim());
                  const existingAssignments = existingStaffNames.map(name => {
                    // Try to find this staff member's actual shift times from the database
                    const actualShift = shiftAssignments.find(shift => shift.staff_name === name);
                    if (actualShift) {
                      // Use actual times from database
                      const shiftStart = new Date(actualShift.shift_start_datetime);
                      const shiftEnd = new Date(actualShift.shift_end_datetime);
                      const startTime = shiftStart.toTimeString().substring(0, 5);
                      const endTime = shiftEnd.toTimeString().substring(0, 5);
                      
                      console.log(`🕐 Found actual times for ${name}: ${startTime} to ${endTime}`);
                      
                      return {
                        staffName: name,
                        startTime: startTime,
                        endTime: endTime,
                        shiftId: actualShift.shift_id,
                        periodId: actualShift.period_id,
                        soloShift: actualShift.solo_shift || false,
                        training: actualShift.training || false,
                        shortNotice: actualShift.short_notice || false,
                        callout: actualShift.call_out || false,
                        overtime: actualShift.overtime || false,
                        paymentPeriodEnd: actualShift.payment_period_end || false,
                        financialYearEnd: actualShift.financial_year_end || false,
                        notes: actualShift.notes || ''
                      };
                    } else {
                      // Fall back to default times if not found in database
                      console.log(`⚠️ No database record found for ${name}, using default times`);
                      return {
                        staffName: name,
                        startTime: '08:00',
                        endTime: '20:00',
                        shiftId: null,
                        periodId: null,
                        soloShift: false,
                        training: false,
                        shortNotice: false,
                        callout: false,
                        overtime: false,
                        paymentPeriodEnd: false,
                        financialYearEnd: false,
                        notes: ''
                      };
                    }
                  });
                  
                  rotaData[weekKey][rowIndex].days[dayIndex] = {
                    displayText: `${existingContent.displayText || existingContent}, ${staffNames}`,
                    assignments: [...existingAssignments, ...assignments]
                  };
                  console.log(`✅ Combined shift: ${staffNames} with existing "${existingContent.displayText || existingContent}" for ${weekKey}, day ${dayIndex + 1}, row ${rowIndex}`);
                } else {
                  // Set new content with detailed assignments
                  rotaData[weekKey][rowIndex].days[dayIndex] = {
                    displayText: staffNames,
                    assignments: assignments
                  };
                  console.log(`✅ Loaded shift with details: ${staffNames} for ${weekKey}, day ${dayIndex + 1}, row ${rowIndex}`);
                  console.log(`🔍 DEBUG: Assignment details for ${staffNames}:`, assignments);
                }
                
                console.log(`📊 Updated rotaData[${weekKey}][${rowIndex}].days[${dayIndex}] with assignments:`, rotaData[weekKey][rowIndex].days[dayIndex]);
              } else {
                console.warn(`⚠️ Could not update rotaData: weekKey=${weekKey}, rowIndex=${rowIndex}, dayIndex=${dayIndex}`);
              }
            });
            
            console.log('📊 Final rotaData after loading:', JSON.stringify(rotaData, null, 2));
            
            // Debug: Check if any shifts were actually loaded into rotaData
            let totalShiftsLoaded = 0;
            Object.keys(rotaData).forEach(weekKey => {
              rotaData[weekKey].forEach((row, rowIndex) => {
                row.days.forEach((day, dayIndex) => {
                  if (day) {
                    let displayText = '';
                    if (typeof day === 'object' && day.assignments) {
                      displayText = day.displayText || '';
                    } else {
                      displayText = day || '';
                    }
                    
                    if (displayText && displayText.trim() !== '') {
                    totalShiftsLoaded++;
                      console.log(`✅ Found shift in rotaData: ${weekKey}, row ${rowIndex}, day ${dayIndex + 1}: "${displayText}"`);
                    }
                  }
                });
              });
            });
            console.log(`📊 Total shifts loaded into rotaData: ${totalShiftsLoaded}`);
            
            // Regenerate tables to display the loaded data
            console.log('🔄 Regenerating tables to display loaded data...');
            generateTables();
            
          } else {
            console.error('❌ No current period found');
          }
        } else {
          console.error('❌ No periods found in database - cannot proceed with fake periods');
          console.error('❌ Please ensure the database has periods data');
          
          // Show error message to user
          const errorMsg = document.createElement('div');
          errorMsg.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #dc3545;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            z-index: 10000;
            animation: slideInRight 0.3s ease-out;
          `;
          errorMsg.textContent = '❌ No periods found in database. Please check database setup.';
          document.body.appendChild(errorMsg);
          
          setTimeout(() => {
            errorMsg.style.animation = 'slideOutRight 0.3s ease-in';
            setTimeout(() => errorMsg.remove(), 300);
          }, 5000);
          
          return; // Don't proceed without real periods
        }
        
        console.log('✅ Data loading completed successfully');
        
        // Final step: Ensure tables are generated with loaded data
        console.log('🔄 Final table generation with loaded data...');
        generateTables();
        
        // Update employee summaries
        console.log('📊 Updating employee summaries...');
        await displayEmployeeSummaries();
        
      } catch (error) {
        console.error('❌ Error loading data from database:', error);
        console.error('❌ Error details:', error.message);
        console.error('❌ Error stack:', error.stack);
        
        // Show error message to user
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc3545;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        errorMsg.textContent = '❌ Failed to load data from database!';
        document.body.appendChild(errorMsg);
        
        setTimeout(() => {
          errorMsg.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => errorMsg.remove(), 300);
        }, 3000);
      }
    }

    // Tab functionality
    function initTabs() {
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabContents = document.querySelectorAll('.tab-content');
      
      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const targetTab = button.getAttribute('data-tab');
          
          // Remove active class from all buttons and contents
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));
          
          // Add active class to clicked button and corresponding content
          button.classList.add('active');
          document.getElementById(`${targetTab}-tab`).classList.add('active');
          
          // Refresh rota data when rota tab is activated
          if (targetTab === 'rota') {
            console.log('🔄 Rota tab activated, refreshing rota data...');
            // Regenerate tables to ensure latest data is displayed
            if (typeof regenerateTables === 'function') {
              regenerateTables();
            }
          }
          
          // Initialize Shift Summary date range when summary tab is activated
          if (targetTab === 'summary') {
            console.log('🔄 Shift Summary tab activated, refreshing data...');
            updateShiftSummaryDateRange();
            
            // Refresh employee summaries to get latest data
            if (typeof displayEmployeeSummaries === 'function') {
              displayEmployeeSummaries();
            }
            
            // Reinitialize ShiftSummaryModule when summary tab is activated
            setTimeout(() => {
              if (typeof window.reinitializeShiftSummary === 'function') {
                window.reinitializeShiftSummary();
              }
            }, 100);
          }
          
          // Refresh holiday entitlements when time-off tab is activated
          if (targetTab === 'timeoff') {
            console.log('🔄 Time-Off tab activated, refreshing holiday entitlements...');
            if (typeof refreshHolidayEntitlements === 'function') {
              refreshHolidayEntitlements();
            }
            
            // Also refresh staff data to ensure holiday entitlements have latest staff info
            if (typeof forceRefreshStaffList === 'function') {
              forceRefreshStaffList();
            }
          }
          
          // Refresh team members table when staff tab is activated
          if (targetTab === 'staff') {
            console.log('🔄 Staff tab activated, refreshing team members table...');
            if (typeof forceRefreshStaffList === 'function') {
              forceRefreshStaffList();
            }
          }
        });
      });
      
      // Initialize tab visibility based on staff status
      updateTabVisibility();
    }
    
    // Function to update tab visibility based on staff status
    async function updateTabVisibility() {
      try {
        const staffMembers = await apiService.getStaffMembers();
        const hasActiveStaff = staffMembers.some(staff => staff.is_active);
        
        updateTabVisibilityBasedOnStaff(hasActiveStaff);
        console.log(`✅ Tab visibility updated - Active staff: ${hasActiveStaff}`);
      } catch (error) {
        console.error('❌ Error updating tab visibility:', error);
      }
    }
    
    // Function to update tab visibility based on staff status (non-async version)
    function updateTabVisibilityBasedOnStaff(hasActiveStaff) {
      // Get tab buttons
      const shiftSummaryTab = document.querySelector('[data-tab="summary"]');
      const timeOffTab = document.querySelector('[data-tab="timeoff"]');
      
      if (shiftSummaryTab) {
        if (hasActiveStaff) {
          shiftSummaryTab.style.display = 'inline-block';
          shiftSummaryTab.style.visibility = 'visible';
        } else {
          shiftSummaryTab.style.display = 'none';
          shiftSummaryTab.style.visibility = 'hidden';
        }
      }
      
      if (timeOffTab) {
        if (hasActiveStaff) {
          timeOffTab.style.display = 'inline-block';
          timeOffTab.style.visibility = 'visible';
        } else {
          timeOffTab.style.display = 'none';
          timeOffTab.style.visibility = 'hidden';
        }
      }
      
      // If no active staff, ensure we're on a visible tab
      if (!hasActiveStaff) {
        const activeTab = document.querySelector('.tab-button.active');
        if (activeTab && (activeTab.getAttribute('data-tab') === 'summary' || activeTab.getAttribute('data-tab') === 'timeoff')) {
          // Switch to rota tab if summary or timeoff is active but should be hidden
          const rotaTab = document.querySelector('[data-tab="rota"]');
          if (rotaTab) {
            rotaTab.click();
          }
        }
      }
      
      console.log(`✅ Tab visibility updated - Active staff: ${hasActiveStaff}`);
    }

    // Function to handle page refresh and ensure data persistence
    function setupPageRefreshHandling() {
      // Add event listener for beforeunload to save any pending changes
      window.addEventListener('beforeunload', (event) => {
        console.log('🔄 Page is being unloaded, ensuring data is saved...');
        // The database operations are already synchronous, so no additional action needed
      });
      
      // Add event listener for page visibility change
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
          console.log('🔄 Page became visible, checking for data updates...');
          // Page visibility change detected
        }
      });
      
      // Add event listener for online/offline status
      window.addEventListener('online', () => {
        console.log('🔄 Internet connection restored');
      });
      
      console.log('✅ Page refresh handling setup completed');
    }
    
    // Start the application
    init();
    
    // Setup page refresh handling
    setupPageRefreshHandling();
    // Function to calculate employee summaries using real database data
    async function calculateEmployeeSummaries(customFromDate = null, customToDate = null) {
      const summaries = {};
      
      let fromDate, toDate;
      
      if (customFromDate && customToDate) {
        // Use custom date range (from shift summary tab)
        fromDate = customFromDate;
        toDate = customToDate;
        console.log(`📊 Calculating employee summaries for custom date range: ${fromDate} to ${toDate}`);
      } else {
        // Use current period dates (default behavior)
        const currentPeriod = allPeriods[currentPeriodIndex];
        const periodStartDate = new Date(currentPeriod.weeks[0]); // Week 1 starts on Monday
        const periodEndDate = new Date(currentPeriod.weeks[3]); // Week 4 starts on Monday
        periodEndDate.setDate(periodEndDate.getDate() + 6); // End of week 4 (Sunday)
        
        fromDate = periodStartDate.toISOString().split('T')[0];
        toDate = periodEndDate.toISOString().split('T')[0];
        console.log(`📊 Calculating employee summaries for current period: ${fromDate} to ${toDate}`);
      }
      
      // Determine if we're viewing a past period
      const today = new Date();
      const endDateObj = new Date(toDate);
      const isPastPeriod = endDateObj < today;
      
      let staffMembers = window.globalStaffMembers;
      
      // If viewing a past period, get historical staff data
      if (isPastPeriod && staffMembers && staffMembers.length > 0) {
        try {
          console.log('📅 Viewing past period, fetching historical staff data for:', toDate);
          const historicalStaff = await apiService.getHistoricalStaffMembers(toDate);
          if (historicalStaff && historicalStaff.length > 0) {
            staffMembers = historicalStaff;
            console.log('✅ Using historical staff data for period ending:', toDate);
          }
        } catch (error) {
          console.warn('⚠️ Failed to fetch historical staff data, using current data:', error);
        }
      }
      
      // Check if staff members are populated
      if (!staffMembers || staffMembers.length === 0) {
        console.warn('⚠️ Staff members not populated yet, fetching fresh data...');
        // Try to fetch fresh data
        try {
          staffMembers = await apiService.getStaffMembers();
          window.globalStaffMembers = staffMembers;
          console.log('📋 Staff members updated in calculateEmployeeSummaries:', staffMembers.map(s => ({ name: s.staff_name, role: s.role })));
        } catch (error) {
          console.error('❌ Error fetching staff members in calculateEmployeeSummaries:', error);
          return [];
        }
      }
      
      
      // Initialize summaries for all staff members
      staffMembers.forEach(staff => {
        const name = staff.staff_name;
        const roleType = staff.role || 'Staff Member'; // Use role from database
        
        summaries[name] = {
          name: name,
          role: roleType,
          totalShifts: 0,
          dayShifts: 0,
          nightShifts: 0,
          holidayShifts: 0,
          totalHours: 0,
          totalPay: 0,
          shifts: [] // Array to store detailed shift information
        };
      });
      
      // Process real shift data from database for each staff member
      for (const staff of staffMembers) {
        const staffName = staff.staff_name;
        console.log(`📊 Processing real shift data for ${staffName}`);
        
        try {
          // Get real shift data from database for this staff member (same as shift history)
          const shiftDataResult = await getRealShiftDataFromDatabase(staffName, fromDate, toDate);
          const shiftData = shiftDataResult.shifts || [];
          
          // Ensure shiftData is an array
          if (!Array.isArray(shiftData)) {
            console.warn(`⚠️ getRealShiftDataFromDatabase returned non-array for ${staffName}:`, shiftData);
            continue; // Skip this staff member
          }
          
          console.log(`📊 Found ${shiftData.length} real shifts for ${staffName}`);
          console.log(`📅 Date range: ${fromDate} to ${toDate}`);
          
          // Debug: Log first few shifts to see their structure
          if (shiftData.length > 0) {
            console.log(`🔍 Sample shift data for ${staffName}:`, shiftData.slice(0, 2));
          }
          
          // Process each shift (shiftData is already processed by getRealShiftDataFromDatabase)
          for (const shift of shiftData) {
            // Validate processed shift data
            if (!shift.date || !shift.hours || shift.hours <= 0) {
              console.warn(`⚠️ Skipping shift for ${staffName}: Invalid processed shift data`, shift);
              continue;
            }
            
            // Skip shifts with invalid duration
            if (shift.hours > 24) {
              console.warn(`⚠️ Skipping shift for ${staffName}: Invalid duration ${shift.hours} hours`, shift);
              continue;
            }
            
            // Use the processed shift type
            const shiftType = shift.type || 'Day';
            
            // Update summary statistics using processed data (same as shift history)
            summaries[staffName].totalShifts++;
            summaries[staffName].totalHours += shift.hours;
            summaries[staffName].totalPay = Math.round((summaries[staffName].totalPay + shift.pay) * 100) / 100;
            
            if (shiftType === 'Day') {
              summaries[staffName].dayShifts++;
            } else if (shiftType === 'Night') {
              summaries[staffName].nightShifts++;
            } else if (shiftType === 'Holiday') {
              summaries[staffName].holidayShifts++;
            }
            
            // Add detailed shift information using processed data
            summaries[staffName].shifts.push({
              date: shift.date,
              shiftType: shiftType,
              hours: shift.hours,
              pay: shift.pay,
              flags: {
                solo_shift: shift.solo_shift || false,
                training: shift.training || false,
                short_notice: shift.short_notice || false,
                call_out: shift.call_out || false,
                overtime: shift.overtime || false
              }
            });
          }
          
        } catch (error) {
          console.error(`❌ Error processing shift data for ${staffName}:`, error);
          // Continue with other staff members even if one fails
        }
      }
      
      console.log(`📊 Employee summaries calculated for ${Object.keys(summaries).length} staff members`);
      
      return Object.values(summaries);
    }
    
        // Function to display employee summaries
    async function displayEmployeeSummaries(selectedEmployee = null) {
      console.log('📊 displayEmployeeSummaries called with selectedEmployee:', selectedEmployee);
      console.log('📋 Global staff members at display time:', window.globalStaffMembers.map(s => ({ name: s.staff_name, role: s.role })));
      
      const summaries = await calculateEmployeeSummaries();
      const tbody = document.getElementById('summary-table-body');
      const profilesContainer = document.getElementById('employee-profiles-container');
      
      if (!tbody) return;
      
      // Ensure summaries is always an array
      if (!Array.isArray(summaries)) {
        console.warn('⚠️ summaries is not an array:', summaries);
        summaries = [];
      }
      
      tbody.innerHTML = '';
      
      if (summaries.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = '<td colspan="8" style="text-align: center; padding: 20px; color: #6b7280;">No shifts assigned yet for this period</td>';
        tbody.appendChild(row);
        
        if (profilesContainer) {
          profilesContainer.innerHTML = '<div class="no-shifts">No employee profiles available - no shifts assigned yet</div>';
        }
        
        // Update summary cards with zeros
        updateSummaryCards(0, 0, 0, 0, 0);
        return;
      }
      
      // Sort by total hours (descending)
      summaries.sort((a, b) => b.totalHours - a.totalHours);
      
      // Filter summaries if a specific employee is selected
      let displaySummaries = summaries;
      if (selectedEmployee) {
        displaySummaries = summaries.filter(s => s.name === selectedEmployee);
      }
      
      // Calculate totals for summary cards
      let totalShifts = 0;
      let totalDayShifts = 0;
      let totalNightShifts = 0;
      let totalHours = 0;
      let totalPay = 0;
      
      // Display summary table with cumulative hours
      for (const summary of displaySummaries) {
        // Ensure summary has the required properties
        if (!summary || typeof summary !== 'object') {
          console.warn('⚠️ Invalid summary object:', summary);
          continue;
        }
        
        totalShifts += summary.totalShifts || 0;
        totalDayShifts += summary.dayShifts || 0;
        totalNightShifts += summary.nightShifts || 0;
        totalHours += summary.totalHours || 0;
        totalPay += summary.totalPay || 0;
        
        // Calculate cumulative hours for this employee
        const cumulativeHours = await calculateCumulativeHours(summary.name);
        
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>
            <div style="display: flex; align-items: center; gap: 8px;">
              <strong><a href="#" class="staff-name-link" onclick="showEmployeeProfile('${summary.name || 'Unknown'}')">${summary.name || 'Unknown'}</a></strong>
              <button class="shift-history-mini-btn" onclick="showShiftHistoryFromRota('${summary.name || 'Unknown'}', window.globalStaffMembers.find(s => s.staff_name === '${summary.name || 'Unknown'}'))" title="View shift history">📅</button>
            </div>
          </td>
          <td>
            <span class="role-display ${(summary.roleType || 'staff member').replace(' ', '-').toLowerCase()}">${summary.roleType || 'staff member'}</span>
          </td>
          <td class="total-shifts">${summary.totalShifts || 0}</td>
          <td>${summary.dayShifts || 0}</td>
          <td>${summary.nightShifts || 0}</td>
          <td class="total-hours">${summary.totalHours || 0} hrs</td>
          <td class="cumulative-hours">${cumulativeHours || 0} hrs</td>
          <td class="pay-amount">£${(summary.totalPay || 0).toFixed(2)}</td>
        `;
        tbody.appendChild(row);
      }
      
      // Update summary cards for both tabs
      updateSummaryCards(
        totalShifts || 0, 
        totalDayShifts || 0, 
        totalNightShifts || 0, 
        totalHours || 0, 
        totalPay || 0
      );
      
      // Also update the summary tab stats
      updateSummaryTabStats();
      
      // Note: Employee profiles are now shown individually when clicking on staff names
    }

    // Optimized Shift Summary Module
    const ShiftSummaryModule = {
      // Cache for DOM elements
      elements: {},
      
      // Cache for data
      dataCache: {
        summaries: null,
        lastFetch: 0,
        cacheTimeout: 30000 // 30 seconds
      },

      // Initialize the module
      init() {
        try {
          // Only initialize if we're on the summary tab or if elements exist
          const summaryTab = document.getElementById('summary-tab');
          if (!summaryTab) {
            console.log('⚠️ Summary tab not found, skipping ShiftSummaryModule initialization');
            return;
          }

          this.cacheElements();
          
          // Only proceed if we have the essential elements
          if (!this.elements.fromDateInput || !this.elements.toDateInput) {
            console.log('⚠️ Essential shift summary elements not found, skipping initialization');
            return;
          }

          this.setupEventListeners();
          this.populateDateInputs();
          this.updateStats();
          console.log('✅ ShiftSummaryModule initialized successfully');
        } catch (error) {
          console.error('❌ Error initializing ShiftSummaryModule:', error);
        }
      },

      // Cache DOM elements for better performance
      cacheElements() {
        try {
          this.elements = {
            fromDateInput: document.getElementById('summary-from-date'),
            toDateInput: document.getElementById('summary-to-date'),
            tableBody: document.getElementById('summary-table-body'),
            tableLoading: document.getElementById('summary-table-loading'),
            exportBtn: document.getElementById('export-summary-btn'),
            cards: {
              totalShifts: document.getElementById('total-shifts-value'),
              dayShifts: document.getElementById('day-shifts-value'),
              nightShifts: document.getElementById('night-shifts-value'),
              totalHours: document.getElementById('total-hours-value'),
              totalPay: document.getElementById('total-pay-value')
            }
          };
          
          // Log missing elements for debugging
          const missingElements = [];
          Object.entries(this.elements).forEach(([key, element]) => {
            if (key === 'cards') {
              Object.entries(element).forEach(([cardKey, cardElement]) => {
                if (!cardElement) missingElements.push(`cards.${cardKey}`);
              });
            } else if (!element) {
              missingElements.push(key);
            }
          });
          
          if (missingElements.length > 0) {
            console.warn('⚠️ Some shift summary elements not found:', missingElements);
          }
        } catch (error) {
          console.error('❌ Error caching DOM elements:', error);
        }
      },

      // Setup event listeners
      setupEventListeners() {
        // Prevent duplicate event listeners
        if (this.eventListenersSetup) {
          return;
        }

        if (this.elements.fromDateInput && this.elements.toDateInput) {
          this.elements.fromDateInput.addEventListener('change', () => this.handleDateChange());
          this.elements.toDateInput.addEventListener('change', () => this.handleDateChange());
        }

        if (this.elements.exportBtn) {
          this.elements.exportBtn.addEventListener('click', () => this.exportData());
        }

        this.eventListenersSetup = true;
      },

      // Handle date range changes
      async handleDateChange() {
        const fromDate = this.elements.fromDateInput.value;
        const toDate = this.elements.toDateInput.value;
        
        if (fromDate && toDate) {
          await this.loadSummaryData(fromDate, toDate);
        }
      },


      // Update summary tab statistics with caching
      async updateStats() {
        const now = Date.now();
        
        // Use cached data if available and not expired
        if (this.dataCache.summaries && (now - this.dataCache.lastFetch) < this.dataCache.cacheTimeout) {
          return;
        }

        try {
          // Calculate summaries for the table
          const summaries = await this.getEmployeeSummaries();

          // Cache the data
          this.dataCache.summaries = summaries;
          this.dataCache.lastFetch = now;

        } catch (error) {
          console.error('Error updating summary stats:', error);
        }
      },

      // Update stats from cache
      updateStatsFromCache() {
        if (!this.dataCache.summaries) return;
        // No staff count elements to update in shift summary tab
      },

      // Get employee summaries with caching
      async getEmployeeSummaries() {
        const now = Date.now();
        
        if (this.dataCache.summaries && (now - this.dataCache.lastFetch) < this.dataCache.cacheTimeout) {
          return this.dataCache.summaries;
        }

        return await calculateEmployeeSummaries();
      },

      // Populate date inputs with default values
      populateDateInputs() {
        if (!this.elements.fromDateInput || !this.elements.toDateInput) return;

        try {
          const startDate = getPreviousPayPeriodStartDate();
          const endDate = getPreviousPayPeriodEndDate();
          
          this.elements.fromDateInput.value = startDate;
          this.elements.toDateInput.value = endDate;
          
          // Load initial data
          setTimeout(() => {
            if (startDate && endDate) {
              this.loadSummaryData(startDate, endDate);
            }
          }, 100);
        } catch (error) {
          console.error('Error populating date inputs:', error);
          // Fallback to default dates
          const today = new Date();
          const fromDate = new Date(today);
          fromDate.setMonth(today.getMonth() - 1);
          const toDate = new Date(today);
          toDate.setMonth(today.getMonth() + 1);
          
          this.elements.fromDateInput.value = fromDate.toISOString().split('T')[0];
          this.elements.toDateInput.value = toDate.toISOString().split('T')[0];
        }
      },

      // Load summary data with loading states
      async loadSummaryData(fromDate, toDate) {
        try {
          this.showLoading(true);
          
          const summaryStats = await this.calculateSummaryStatsForDateRange(fromDate, toDate);
          
          this.updateSummaryCards(summaryStats);
          await this.updateEmployeeBreakdownTable(summaryStats);
          
        } catch (error) {
          console.error('Error loading summary data:', error);
          this.showError('Failed to load summary data. Please try again.');
        } finally {
          this.showLoading(false);
        }
      },

      // Show/hide loading state
      showLoading(show) {
        if (this.elements.tableLoading) {
          this.elements.tableLoading.style.display = show ? 'flex' : 'none';
        }
        if (this.elements.tableBody) {
          this.elements.tableBody.style.display = show ? 'none' : 'table-row-group';
        }
      },

      // Show error message
      showError(message) {
        if (this.elements.tableBody) {
          this.elements.tableBody.innerHTML = `
            <tr>
              <td colspan="8" class="error-message">
                <div style="text-align: center; padding: 2rem; color: #dc2626;">
                  <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">⚠️</div>
                  <div>${message}</div>
                </div>
              </td>
            </tr>
          `;
        }
      },

      // Calculate summary statistics for date range (optimized) - using same data as shift history
      async calculateSummaryStatsForDateRange(fromDate, toDate) {
        console.log(`📊 ShiftSummaryModule: Calculating stats for ${fromDate} to ${toDate}`);
        
        // Use the same calculation method as the main calculateEmployeeSummaries function with custom date range
        const summaries = await calculateEmployeeSummaries(fromDate, toDate);
        
        // Convert to the expected format
        const totalShifts = summaries.reduce((sum, emp) => sum + emp.totalShifts, 0);
        const dayShifts = summaries.reduce((sum, emp) => sum + emp.dayShifts, 0);
        const nightShifts = summaries.reduce((sum, emp) => sum + emp.nightShifts, 0);
        const holidayShifts = summaries.reduce((sum, emp) => sum + emp.holidayShifts, 0);
        const totalHours = summaries.reduce((sum, emp) => sum + emp.totalHours, 0);
        const totalPay = summaries.reduce((sum, emp) => sum + emp.totalPay, 0);
        
        return {
          totalShifts,
          dayShifts,
          nightShifts,
          holidayShifts,
          totalHours,
          totalPay,
          employeeStats: summaries
        };
      },

      // Update summary cards efficiently
      updateSummaryCards(stats) {
        try {
          // Ensure stats is an object with proper properties
          if (!stats || typeof stats !== 'object') {
            console.error('❌ updateSummaryCards received invalid stats:', stats);
            return;
          }

          // Try to use cached elements first
          if (this.elements && this.elements.cards) {
            const cards = this.elements.cards;
            
            // Safely update each card with fallback values
            if (cards.totalShifts) cards.totalShifts.textContent = stats.totalShifts || 0;
            if (cards.dayShifts) cards.dayShifts.textContent = stats.dayShifts || 0;
            if (cards.nightShifts) cards.nightShifts.textContent = stats.nightShifts || 0;
            if (cards.totalHours) cards.totalHours.textContent = (stats.totalHours || 0).toFixed(1);
            if (cards.totalPay) cards.totalPay.textContent = `£${(stats.totalPay || 0).toFixed(2)}`;
          } else {
            // Fallback: Update elements directly if cache is not available
            console.log('⚠️ ShiftSummaryModule elements not cached, updating directly');
            this.updateSummaryCardsDirectly(stats);
          }
          
        } catch (error) {
          console.error('❌ Error in updateSummaryCards:', error);
        }
      },

      // Direct update method for when cache is not available
      updateSummaryCardsDirectly(stats) {
        try {
          const elements = {
            totalShifts: document.getElementById('total-shifts-value'),
            dayShifts: document.getElementById('day-shifts-value'),
            nightShifts: document.getElementById('night-shifts-value'),
            totalHours: document.getElementById('total-hours-value'),
            totalPay: document.getElementById('total-pay-value')
          };

          if (elements.totalShifts) elements.totalShifts.textContent = stats.totalShifts || 0;
          if (elements.dayShifts) elements.dayShifts.textContent = stats.dayShifts || 0;
          if (elements.nightShifts) elements.nightShifts.textContent = stats.nightShifts || 0;
          if (elements.totalHours) elements.totalHours.textContent = (stats.totalHours || 0).toFixed(1);
          if (elements.totalPay) elements.totalPay.textContent = `£${(stats.totalPay || 0).toFixed(2)}`;
        } catch (error) {
          console.error('❌ Error in updateSummaryCardsDirectly:', error);
        }
      },

      // Update employee breakdown table (optimized)
      async updateEmployeeBreakdownTable(stats) {
        if (!this.elements.tableBody) {
        console.error('❌ Summary table body not found');
        return;
      }
      
      if (stats.employeeStats.length === 0) {
          this.elements.tableBody.innerHTML = `
            <tr>
              <td colspan="8" class="no-data">
                <div style="text-align: center; padding: 2rem; color: #64748b;">
                  <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">📊</div>
                  <div>No employee data available for selected date range</div>
                </div>
              </td>
            </tr>
          `;
        return;
      }
      
      // Sort by total hours (descending)
      stats.employeeStats.sort((a, b) => b.totalHours - a.totalHours);
      
        // Use DocumentFragment for better performance
        const fragment = document.createDocumentFragment();
      
      // Generate table rows with cumulative hours
      for (const employee of stats.employeeStats) {
          const cumulativeHours = await this.calculateCumulativeHours(employee.name);
        
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>
            <div style="display: flex; align-items: center; gap: 8px;">
              <strong><a href="#" class="staff-name-link" onclick="showEmployeeProfile('${employee.name}')">${employee.name}</a></strong>
              <button class="shift-history-mini-btn" onclick="showShiftHistoryFromRota('${employee.name}', window.globalStaffMembers.find(s => s.staff_name === '${employee.name}'))" title="View shift history">📅</button>
            </div>
          </td>
          <td>
            <span class="role-display ${(employee.role || 'Staff Member').replace(' ', '-').toLowerCase()}">${employee.role || 'Staff Member'}</span>
          </td>
          <td class="total-shifts">${employee.totalShifts}</td>
          <td>${employee.dayShifts}</td>
          <td>${employee.nightShifts}</td>
            <td class="total-hours">${employee.totalHours.toFixed(1)} hrs</td>
            <td class="cumulative-hours">${cumulativeHours.toFixed(1)} hrs</td>
          <td class="pay-amount">£${employee.totalPay.toFixed(2)}</td>
        `;
          fragment.appendChild(row);
        }
        
        // Clear and append all rows at once
        this.elements.tableBody.innerHTML = '';
        this.elements.tableBody.appendChild(fragment);
      },

      // Calculate cumulative hours for an employee (corrected implementation)
      async calculateCumulativeHours(employeeName) {
        try {
          // Calculate cumulative hours from the beginning of the current financial year to TODAY
          // Financial year runs from April 6th to April 5th next year
          const currentDate = new Date();
          const currentYear = currentDate.getFullYear();
          
          // Determine the current financial year
          let currentFYStart, currentFYEnd;
          
          // Financial year runs from April 6th to April 5th next year
          if (currentDate.getMonth() > 3 || (currentDate.getMonth() === 3 && currentDate.getDate() >= 6)) {
            // After April 6th - we're in the current financial year
            currentFYStart = new Date(currentYear, 3, 6); // April 6th current year
            currentFYEnd = new Date(currentYear + 1, 3, 5); // April 5th next year
          } else {
            // Before April 6th - we're in the previous financial year
            currentFYStart = new Date(currentYear - 1, 3, 6); // April 6th previous year
            currentFYEnd = new Date(currentYear, 3, 5); // April 5th current year
          }
          
          // Format dates for API call
          const formatDate = (date) => {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
          };
          
          const fromDateStr = formatDate(currentFYStart);
          const toDateStr = formatDate(currentDate); // FIXED: Use current date instead of FY end
          
          // Fetch shifts for the employee from the beginning of the current financial year to today
          const response = await fetch(`/api/shifts/employee/${encodeURIComponent(employeeName)}?from=${fromDateStr}&to=${toDateStr}`);
          
          if (!response.ok) {
            console.error(`❌ Failed to fetch shifts for ${employeeName}:`, response.statusText);
            return 0;
          }
          
          const shiftsData = await response.json();
          
          if (!shiftsData.success) {
            console.error(`❌ API Error for ${employeeName}:`, shiftsData.error);
            return 0;
          }
          
          const shifts = shiftsData.data || [];
          
          if (shifts.length === 0) {
            return 0;
          }
          
          // Calculate total hours
          let totalHours = 0;
          shifts.forEach((shift) => {
            const startTime = new Date(shift.shift_start_datetime);
            const endTime = new Date(shift.shift_end_datetime);
            const duration = (endTime - startTime) / (1000 * 60 * 60); // Convert to hours
            totalHours += duration;
          });
          
          return Math.round(totalHours * 100) / 100; // Round to 2 decimal places
          
        } catch (error) {
          console.error('Error calculating cumulative hours:', error);
          return 0;
        }
      },
      // Export data to CSV
      exportData() {
        // Prevent multiple exports in quick succession
        if (this.isExporting) {
          return;
        }
        this.isExporting = true;

        const fromDate = this.elements.fromDateInput.value;
        const toDate = this.elements.toDateInput.value;
        
        if (!fromDate || !toDate) {
          console.warn('⚠️ Please select a date range before exporting.');
          this.isExporting = false;
          return;
        }

        // Get current table data
        const table = document.getElementById('summary-table');
        if (!table) {
          console.warn('⚠️ Summary table not found');
          this.isExporting = false;
          return;
        }

        // Check if table has data
        const rows = table.querySelectorAll('tbody tr');
        if (rows.length === 0) {
          console.warn('⚠️ No data to export');
          this.isExporting = false;
          return;
        }

        let csvContent = 'data:text/csv;charset=utf-8,';

        // Add header row matching the table structure exactly
        csvContent += 'Employee,Role,Total,Day,Night,Hours,Cumulative Hours,Pay\n';

        // Add data rows
        rows.forEach(row => {
          const cells = row.querySelectorAll('td');
          if (cells.length >= 8) {
            // Clean employee name - remove calendar icons and extra whitespace
            const employeeName = cells[0].textContent
              .replace(/📅/g, '') // Remove calendar icons
              .replace(/\s+/g, ' ') // Replace multiple spaces with single space
              .trim();
            
            // Clean role - remove extra whitespace
            const role = cells[1].textContent
              .replace(/\s+/g, ' ')
              .trim();
            
            // Clean numeric values - remove extra whitespace
            const total = cells[2].textContent.trim();
            const day = cells[3].textContent.trim();
            const night = cells[4].textContent.trim();
            const hours = cells[5].textContent.trim();
            const cumulativeHours = cells[6].textContent.trim();
            const pay = cells[7].textContent.trim();
            
            const rowData = [
              `"${employeeName}"`, // Clean employee name
              `"${role}"`,         // Clean role
              total,               // Total
              day,                 // Day
              night,               // Night
              hours,               // Hours
              cumulativeHours,     // Cumulative Hours
              pay                  // Pay
            ];
            csvContent += rowData.join(',') + '\n';
          }
        });

        // Create and trigger download
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement('a');
        link.setAttribute('href', encodedUri);
        link.setAttribute('download', `shift_summary_${fromDate}_to_${toDate}.csv`);
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        console.log('📊 Shift summary data exported successfully');
        
        // Reset flag after a short delay
        setTimeout(() => {
          this.isExporting = false;
        }, 1000);
      },

      // Clear cache when data changes
      clearCache() {
        this.dataCache.summaries = null;
        this.dataCache.lastFetch = 0;
      },

      // Refresh data (clear cache and reload)
      async refresh() {
        this.clearCache();
        await this.updateStats();
        
        const fromDate = this.elements.fromDateInput.value;
        const toDate = this.elements.toDateInput.value;
        
        if (fromDate && toDate) {
          await this.loadSummaryData(fromDate, toDate);
        }
      },

      // Reinitialize the module (useful when DOM elements become available later)
      reinitialize() {
        try {
          this.cacheElements();
          this.eventListenersSetup = false; // Reset flag to allow re-setup
          this.setupEventListeners();
          console.log('✅ ShiftSummaryModule reinitialized');
        } catch (error) {
          console.error('❌ Error reinitializing ShiftSummaryModule:', error);
        }
      }
    };

    // Function to update summary tab statistics (optimized)
    async function updateSummaryTabStats() {
      if (ShiftSummaryModule && typeof ShiftSummaryModule.updateStats === 'function') {
        await ShiftSummaryModule.updateStats();
      }
    }

    // Function to populate summary date inputs with pay date ranges (optimized)
    function populateSummaryDateInputs() {
      if (ShiftSummaryModule && typeof ShiftSummaryModule.populateDateInputs === 'function') {
        ShiftSummaryModule.populateDateInputs();
      }
    }

    // Function to setup summary date change listeners (optimized)
    function setupSummaryDateListeners() {
      // Event listeners are now handled by ShiftSummaryModule
      // This function is kept for backward compatibility
    }

    // Function to load summary data for a date range (optimized)
    async function loadSummaryData(fromDate, toDate) {
      if (ShiftSummaryModule && typeof ShiftSummaryModule.loadSummaryData === 'function') {
        await ShiftSummaryModule.loadSummaryData(fromDate, toDate);
      }
    }

    // Function to calculate summary statistics for a specific date range (optimized)
    async function calculateSummaryStatsForDateRange(fromDate, toDate) {
      if (ShiftSummaryModule && typeof ShiftSummaryModule.calculateSummaryStatsForDateRange === 'function') {
        return await ShiftSummaryModule.calculateSummaryStatsForDateRange(fromDate, toDate);
      }
      return { totalShifts: 0, dayShifts: 0, nightShifts: 0, totalHours: 0, totalPay: 0, employeeStats: [] };
    }

    // Function to update employee breakdown table for date range (optimized)
    async function updateEmployeeBreakdownTableForDateRange(stats) {
      if (ShiftSummaryModule && typeof ShiftSummaryModule.updateEmployeeBreakdownTable === 'function') {
        await ShiftSummaryModule.updateEmployeeBreakdownTable(stats);
      }
    }
    
    // Function to update summary cards (optimized)
    function updateSummaryCards(totalShifts, totalDayShifts, totalNightShifts, totalHours, totalPay) {
      // Handle both individual parameters and object format
      let stats;
      if (typeof totalShifts === 'object' && totalShifts !== null) {
        // Called with object format
        stats = totalShifts;
      } else {
        // Called with individual parameters
        stats = {
          totalShifts: totalShifts || 0,
          dayShifts: totalDayShifts || 0,
          nightShifts: totalNightShifts || 0,
          totalHours: totalHours || 0,
          totalPay: totalPay || 0
        };
      }
      
      // Try to use ShiftSummaryModule if available
      if (ShiftSummaryModule && typeof ShiftSummaryModule.updateSummaryCards === 'function') {
        ShiftSummaryModule.updateSummaryCards(stats);
      } else {
        // Fallback: Update cards directly if ShiftSummaryModule is not ready
        updateSummaryCardsDirectly(stats);
      }
    }

    // Fallback function to update summary cards directly
    function updateSummaryCardsDirectly(stats) {
      try {
        const elements = {
          totalShifts: document.getElementById('total-shifts-value'),
          dayShifts: document.getElementById('day-shifts-value'),
          nightShifts: document.getElementById('night-shifts-value'),
          totalHours: document.getElementById('total-hours-value'),
          totalPay: document.getElementById('total-pay-value')
        };

        if (elements.totalShifts) elements.totalShifts.textContent = stats.totalShifts || 0;
        if (elements.dayShifts) elements.dayShifts.textContent = stats.dayShifts || 0;
        if (elements.nightShifts) elements.nightShifts.textContent = stats.nightShifts || 0;
        if (elements.totalHours) elements.totalHours.textContent = (stats.totalHours || 0).toFixed(1);
        if (elements.totalPay) elements.totalPay.textContent = `£${(stats.totalPay || 0).toFixed(2)}`;
      } catch (error) {
        console.error('❌ Error in updateSummaryCardsDirectly:', error);
      }
    }

    // Global function to refresh shift summary data
    window.refreshShiftSummary = function() {
      if (ShiftSummaryModule && typeof ShiftSummaryModule.refresh === 'function') {
        ShiftSummaryModule.refresh();
      }
    };

    // Global function to clear shift summary cache
    window.clearShiftSummaryCache = function() {
      if (ShiftSummaryModule && typeof ShiftSummaryModule.clearCache === 'function') {
        ShiftSummaryModule.clearCache();
      }
    };

    // Global function to reinitialize shift summary module
    window.reinitializeShiftSummary = function() {
      if (ShiftSummaryModule && typeof ShiftSummaryModule.reinitialize === 'function') {
        ShiftSummaryModule.reinitialize();
      }
    };
    

    
    // Function to show individual employee profile
    window.showEmployeeProfile = async function(staffName) {
      const summaries = await calculateEmployeeSummaries();
      const employeeSummary = summaries.find(s => s.name === staffName);
      
      if (!employeeSummary) {
        console.error('Employee not found:', staffName);
        return;
      }
      
      // Determine which tab is currently active
      const activeTab = document.querySelector('.tab-button.active').getAttribute('data-tab');
      
      let profileSection, profileDetail;
      if (activeTab === 'summary') {
        profileSection = document.getElementById('summary-profiles-section');
        profileDetail = document.getElementById('summary-employee-profile-detail');
      } else {
        profileSection = document.getElementById('profiles-section');
        profileDetail = document.getElementById('employee-profile-detail');
      }
      
      // Create profile content
      let profileHTML = `
        <div class="profile-header">
          <div class="profile-info">
            <h2>${employeeSummary.name}</h2>
            <p class="profile-role">${employeeSummary.roleType}</p>
          </div>
          <div class="profile-stats">
            <div class="stat-item">
              <span class="stat-label">Total Shifts:</span>
              <span class="stat-value">${employeeSummary.totalShifts}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Day Shifts:</span>
              <span class="stat-value">${employeeSummary.dayShifts}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Night Shifts:</span>
              <span class="stat-value">${employeeSummary.nightShifts}</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Total Hours:</span>
              <span class="stat-value">${employeeSummary.totalHours} hrs</span>
            </div>
          </div>
        </div>
      `;
      
      if (employeeSummary.shifts.length === 0) {
        profileHTML += '<div class="no-shifts">No shifts assigned for this period</div>';
      } else {
        profileHTML += '<div class="shifts-container">';
        profileHTML += '<h3>Shift Schedule</h3>';
        profileHTML += '<div class="shifts-list">';
        
        // Sort shifts by date
        employeeSummary.shifts.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        employeeSummary.shifts.forEach(shift => {
          const dateStr = shift.date.toLocaleDateString('en-GB', {
            weekday: 'short',
            day: 'numeric',
            month: 'short',
            year: 'numeric'
          });
          
          profileHTML += `
            <div class="shift-card ${shift.shiftType}">
              <div class="shift-header">
                <div class="shift-date">${dateStr}</div>
                <div class="shift-type-badge ${shift.shiftType}">${shift.shiftTypeLabel}</div>
              </div>
              <div class="shift-details">
                <div class="shift-time">
                  <span class="time-label">Start:</span> ${shift.startTime}
                </div>
                <div class="shift-time">
                  <span class="time-label">End:</span> ${shift.endTime}
                </div>
                <div class="shift-role">
                  <span class="role-label">Role:</span> ${shift.role}
                </div>
              </div>
            </div>
          `;
        });
        
        profileHTML += '</div></div>';
      }
      
      profileDetail.innerHTML = profileHTML;
      profileSection.style.display = 'block';
      
      // Update the summary table to show only this employee
      await displayEmployeeSummaries(staffName);
      
      // Scroll to profile section
      profileSection.scrollIntoView({ behavior: 'smooth' });
    }
    
    // Function to close employee profile
    window.closeEmployeeProfile = async function() {
      // Determine which tab is currently active
      const activeTab = document.querySelector('.tab-button.active').getAttribute('data-tab');
      
      let profileSection;
      if (activeTab === 'summary') {
        profileSection = document.getElementById('summary-profiles-section');
      } else {
        profileSection = document.getElementById('profiles-section');
      }
      
      profileSection.style.display = 'none';
      
      // Show all employees in the summary table again
      await displayEmployeeSummaries();
    }
    
    
    // Function to save shift changes to database
    async function saveShiftToDatabase(weekIndex, rowIndex, dayIndex, staffAssignments) {
      try {
        console.log('🚀 saveShiftToDatabase called with:', { weekIndex, rowIndex, dayIndex, staffAssignments });
        
        console.log(`💾 Saving shift change: Week ${weekIndex + 1}, Role ${rowIndex}, Day ${dayIndex}`);
        
        // Get current period
        const currentPeriod = allPeriods[currentPeriodIndex];
        if (!currentPeriod) {
          console.error('No current period found');
          return;
        }
        
        console.log('📅 Current period:', currentPeriod);
        console.log('📅 Current period index:', currentPeriodIndex);
        
        // Calculate the shift date and times
        const shiftDate = new Date(currentPeriod.weeks[weekIndex]);
        shiftDate.setDate(shiftDate.getDate() + dayIndex);
        
        // Get role information
        const weekKey = `week${weekIndex + 1}`;
        const roleData = rotaData[weekKey][rowIndex];
        const roleName = roleData.role;
        
        console.log('👤 Role name:', roleName);
        console.log('📍 Row index:', rowIndex);
        console.log('📅 Shift date:', shiftDate.toISOString());
        
        // Determine shift type based on row index and role name
        let shiftType = 'Tom Day';
        
        if (rowIndex === 0) {
          shiftType = 'Tom Day';
          console.log('✅ Determined: Tom Day shift');
        } else if (rowIndex === 1) {
          shiftType = 'Charlotte Day';
          console.log('✅ Determined: Charlotte Day shift');
        } else if (rowIndex === 2) {
          shiftType = 'Double Up';
          console.log('✅ Determined: Double Up shift');
        } else if (rowIndex === 3) {
          shiftType = 'Tom Night';
          console.log('✅ Determined: Tom Night shift');
        } else if (rowIndex === 4) {
          shiftType = 'Charlotte Night';
          console.log('✅ Determined: Charlotte Night shift');
        } else if (rowIndex === 5) {
          shiftType = 'HOLIDAY';
          console.log('✅ Determined: HOLIDAY shift');
        } else {
          // Fallback to role name parsing for backward compatibility
          console.log('⚠️ Using fallback role name parsing');
          if (roleName.toLowerCase().includes('night')) {
            shiftType = 'Tom Night';
          } else if (roleName.toLowerCase().includes('holiday')) {
            shiftType = 'HOLIDAY';
          } else if (roleName.toLowerCase().includes('charlotte')) {
            if (roleName.toLowerCase().includes('night')) {
              shiftType = 'Charlotte Night';
            } else {
              shiftType = 'Charlotte Day';
            }
          } else if (roleName.toLowerCase().includes('double')) {
            shiftType = 'Double Up';
          }
        }
        
        // Use actual times from staff assignments instead of hardcoded defaults
        let startTime = '08:00';
        let endTime = '20:00';
        let totalHours = 12;
        
        if (staffAssignments && staffAssignments.length > 0) {
          // Use the first assignment's times as the base times
          const firstAssignment = staffAssignments[0];
          startTime = firstAssignment.startTime;
          endTime = firstAssignment.endTime;
          
          // Calculate total hours from actual assignments
          totalHours = staffAssignments.reduce((sum, assignment) => {
            const start = new Date(`2000-01-01T${assignment.startTime}`);
            const end = new Date(`2000-01-01T${assignment.endTime}`);
            if (end < start) {
              end.setDate(end.getDate() + 1);
            }
            return sum + Math.round((end - start) / (1000 * 60 * 60));
          }, 0);
          
          console.log('🕐 Using actual assignment times:', { startTime, endTime, totalHours });
          
          // For night shifts, ensure proper date handling
          if (shiftType === 'Tom Night' || shiftType === 'Charlotte Night') {
            console.log('🌙 Night shift detected, adjusting time calculations');
          }
        } else {
          console.log('⚠️ No staff assignments, using default times');
        }
        
        // Create shift start and end datetime
        const shiftStartDatetime = new Date(shiftDate);
        const [startHour, startMinute] = startTime.split(':');
        shiftStartDatetime.setHours(parseInt(startHour), parseInt(startMinute), 0, 0);
        
        const shiftEndDatetime = new Date(shiftDate);
        const [endHour, endMinute] = endTime.split(':');
        shiftEndDatetime.setHours(parseInt(endHour), parseInt(endMinute), 0, 0);
        
        // If it's a night shift, the end time is the next day
        if (shiftType === 'Tom Night' || shiftType === 'Charlotte Night') {
          shiftEndDatetime.setDate(shiftEndDatetime.getDate() + 1);
        }
        
        console.log('🕐 Shift details:', {
          type: shiftType,
          start: shiftStartDatetime.toISOString(),
          end: shiftEndDatetime.toISOString(),
          totalHours: totalHours,
          rowIndex: rowIndex,
          roleName: roleName
        });
        
        // Get current period from database
        const periods = await apiService.getPeriods();
        const currentDbPeriod = periods[currentPeriodIndex];
        
        if (!currentDbPeriod) {
          console.error('No current period found in database');
          return;
        }
        
        console.log('📅 Current period from database:', currentDbPeriod);
        
        // Check if we're clearing the assignment (empty staff assignments)
        if (!staffAssignments || staffAssignments.length === 0) {
          console.log('🗑️ Empty staff assignments - clearing from database...');
          
          // Clear the assignment from database using the clear-cell endpoint
          const shiftDate = shiftStartDatetime.toISOString().split('T')[0];
          
          try {
            const clearResponse = await fetch(`${API_BASE_URL}/shifts/clear-cell`, {
              method: 'DELETE',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                periodId: currentDbPeriod.period_id,
                weekNumber: weekIndex + 1,
                date: shiftDate,
                shiftType: shiftType
              })
            });
            
            if (!clearResponse.ok) {
              const errorText = await clearResponse.text();
              console.error('Clear cell error response:', errorText);
              throw new Error(`HTTP ${clearResponse.status}: ${errorText}`);
            }
            
            const clearResult = await clearResponse.json();
            console.log('✅ Assignment cleared from database:', clearResult);
            
            // Update employee summaries
            await displayEmployeeSummaries();
            
            // Refresh holiday entitlements if this is a holiday shift
            if (shiftType === 'HOLIDAY') {
              console.log('🏖️ Holiday shift cleared, refreshing holiday entitlements...');
              await refreshHolidayEntitlements();
            }
            
            // Clear shift summary cache to ensure fresh data
            if (typeof window.clearShiftSummaryCache === 'function') {
              window.clearShiftSummaryCache();
            }
            
            console.log('✅ Clear operation completed successfully');
          return;
          } catch (error) {
            console.error('❌ Error clearing assignment from database:', error);
            throw error;
          }
        }
        
        // For partial updates (some assignments removed), we need to clear and recreate
        // This ensures consistency and avoids complex partial update logic
        console.log('🔄 Handling assignment update - clearing existing assignments first...');
        
        // Clear existing assignments for this cell
        const clearDate = shiftStartDatetime.toISOString().split('T')[0];
        
        try {
          const clearResponse = await fetch(`${API_BASE_URL}/shifts/clear-cell`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              periodId: currentDbPeriod.period_id,
              weekNumber: weekIndex + 1,
              date: clearDate,
              shiftType: shiftType
            })
          });
          
          if (!clearResponse.ok) {
            const errorText = await clearResponse.text();
            console.error('Clear cell error response:', errorText);
            throw new Error(`HTTP ${clearResponse.status}: ${errorText}`);
          }
          
          console.log('✅ Existing assignments cleared, now saving new assignments...');
        } catch (error) {
          console.error('❌ Error clearing existing assignments:', error);
          throw error;
        }
        
        // Prepare staff assignments for the new schema
        const assignments = staffAssignments.map(assignment => {
          // Calculate hours from time range
          const startTime = new Date(`2000-01-01T${assignment.startTime}`);
          const endTime = new Date(`2000-01-01T${assignment.endTime}`);
          
          // Handle overnight shifts
          if (endTime < startTime) {
            endTime.setDate(endTime.getDate() + 1);
          }
          
          const hoursWorked = Math.round((endTime - startTime) / (1000 * 60 * 60));
          
          return {
            staffName: assignment.staffName,
            hoursWorked: hoursWorked,
            startTime: assignment.startTime,
            endTime: assignment.endTime,
            soloShift: assignment.soloShift || false,
            training: assignment.training || false,
            shortNotice: assignment.shortNotice || false,
            callout: assignment.callout || false,
            overtime: assignment.overtime || false,
            paymentPeriodEnd: assignment.paymentPeriodEnd || false,
            financialYearEnd: assignment.financialYearEnd || false,
            notes: assignment.notes || ''
          };
        });
        
        // Calculate total hours from actual assignments
        const calculatedTotalHours = assignments.reduce((sum, assignment) => sum + assignment.hoursWorked, 0);
        
        const shiftData = {
          periodId: currentDbPeriod.period_id,
          weekNumber: weekIndex + 1,
          shiftStartDatetime: shiftStartDatetime.toISOString(),
          shiftEndDatetime: shiftEndDatetime.toISOString(),
          shiftType: shiftType,
          totalHours: calculatedTotalHours,
          staffAssignments: assignments
        };
        
        console.log('📋 Shift data to save:', shiftData);
        console.log('🚩 Flag details in assignments:', assignments.map(a => ({
          staffName: a.staffName,
          soloShift: a.soloShift,
          training: a.training,
          shortNotice: a.shortNotice,
          callout: a.callout,
          overtime: a.overtime,
          paymentPeriodEnd: a.paymentPeriodEnd,
          notes: a.notes
        })));

        
        // Save or update the shift
        try {
          console.log('💾 Attempting to save shift to database...');
          console.log('🚩 Final shift data with flags:', JSON.stringify(shiftData, null, 2));
          
          // Check if the database API supports flag properties
          console.log('🔍 Checking database API support for flags...');
          console.log('🔍 API endpoint:', `${API_BASE_URL}/shifts`);
          console.log('🔍 Request method: POST');
          console.log('🔍 Request headers: Content-Type: application/json');
          
          const result = await apiService.saveShiftAssignment(shiftData);
          console.log('✅ Shift saved successfully:', result);
          
          if (result) {
            console.log('✅ Shift operation completed successfully');
            
            // Update employee summaries
            await displayEmployeeSummaries();
            
            // Refresh holiday entitlements if this is a holiday shift
            if (shiftType === 'HOLIDAY') {
              console.log('🏖️ Holiday shift assigned, refreshing holiday entitlements...');
              await refreshHolidayEntitlements();
            }
            
            // Clear shift summary cache to ensure fresh data
            if (typeof window.clearShiftSummaryCache === 'function') {
              window.clearShiftSummaryCache();
            }
            
            console.log('✅ Display updated successfully after save');
          } else {
            console.warn('⚠️ No result returned from saveShiftAssignment');
          }
        } catch (error) {
          console.error('❌ Error in saveShiftAssignment:', error);
          console.error('❌ Error details:', error.message);
          console.error('❌ Error stack:', error.stack);
        }
        
      } catch (error) {
        console.error('❌ Error saving shift to database:', error);
        console.error('❌ Error details:', error.message);
        console.error('❌ Error stack:', error.stack);
        // Log error for debugging - no popup to block console view
        console.error('❌ Failed to save changes to database. Check console for details.');
      }
    }
    async function clearCell(cell, weekIndex, rowIndex, dayIndex) {

      
      try {
        // Get current period information
        const currentPeriod = allPeriods[currentPeriodIndex];
        if (!currentPeriod) {
          throw new Error('No current period found');
        }
        
        // Calculate the specific date for this cell
        const shiftDate = new Date(currentPeriod.weeks[weekIndex]);
        shiftDate.setDate(shiftDate.getDate() + dayIndex);
        const cellDateString = shiftDate.toISOString().split('T')[0]; // Get YYYY-MM-DD format
        
        // Get role information to determine shift type
        const weekKey = `week${weekIndex + 1}`;
        const roleData = rotaData[weekKey][rowIndex];
        const roleName = roleData.role;
        
        // Determine shift type based on row index
        let shiftType = 'Tom Day';
        if (rowIndex === 0) {
          shiftType = 'Tom Day';
        } else if (rowIndex === 1) {
          shiftType = 'Charlotte Day';
        } else if (rowIndex === 2) {
          shiftType = 'Double Up';
        } else if (rowIndex === 3) {
          shiftType = 'Tom Night';
        } else if (rowIndex === 4) {
          shiftType = 'Charlotte Night';
        } else if (rowIndex === 5) {
          shiftType = 'HOLIDAY';
        }
        

        
        // Clear from database using the clear-cell endpoint
        const response = await fetch(`${API_BASE_URL}/shifts/clear-cell`, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            periodId: currentPeriod.period_id,
            weekNumber: weekIndex + 1,
            date: cellDateString,
            shiftType: shiftType
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Clear cell error response:', errorText);
          throw new Error(`HTTP ${response.status}: ${errorText}`);
        }
        
        await response.json();
        
        // Clear the cell visually
        cell.textContent = '';
        cell.style.backgroundColor = '';
        
        // Clear from local data
        rotaData[weekKey][rowIndex].days[dayIndex] = '';

        
        // Clear custom colors if any
        const cellKey = `w${weekIndex}_r${rowIndex}_d${dayIndex}`;
        if (customCellColors[cellKey]) {
          delete customCellColors[cellKey];

        }
        
        // Update employee summaries to reflect the change (no need for full refresh)
        console.log('📊 Updating employee summaries after clear...');
        await displayEmployeeSummaries();
        
        // Update the specific cell in the table to ensure consistency
        console.log('🔄 Updating specific cell display...');
        
        // Find the correct table and cell using a more robust selector
        const tables = document.querySelectorAll('#tables-container table');
        if (tables[weekIndex]) {
          const rows = tables[weekIndex].querySelectorAll('tbody tr');
          if (rows[rowIndex]) {
            const cells = rows[rowIndex].querySelectorAll('td');
            if (cells[dayIndex + 1]) { // +1 because first cell is the role name
              const targetCell = cells[dayIndex + 1];
              targetCell.textContent = '';
              targetCell.style.backgroundColor = '';
              console.log('✅ Cell updated in table display');
            } else {
              console.warn('⚠️ Target cell not found in table');
            }
          } else {
            console.warn('⚠️ Target row not found in table');
          }
        } else {
          console.warn('⚠️ Target table not found');
        }
        
        console.log('✅ Cell cleared successfully without full refresh');
        
        // Show success message to user
        const successMsg = document.createElement('div');
        successMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #28a745;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        successMsg.textContent = '✅ Cell cleared successfully!';
        document.body.appendChild(successMsg);
        
        setTimeout(() => {
          successMsg.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => successMsg.remove(), 300);
        }, 2000);
        
      } catch (error) {
        console.error('Error in clearCell:', error);
        
        // Still try to clear visually even if database operation fails
        cell.textContent = '';
        cell.style.backgroundColor = '';
        const weekKey = `week${weekIndex + 1}`;
        rotaData[weekKey][rowIndex].days[dayIndex] = '';
        
        // Show error message to user
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc3545;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        errorMsg.textContent = `Failed to clear from database: ${error.message}`;
        document.body.appendChild(errorMsg);
        
        setTimeout(() => {
          errorMsg.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => errorMsg.remove(), 300);
        }, 3000);
      }
    }


    

    

    
    // Function to ensure database is properly initialized
    async function ensureDatabaseInitialized() {
      console.log('🔧 Ensuring database is properly initialized...');
      
      try {
        // Test database connection
        const testResponse = await fetch(`${API_BASE_URL}/test-db`);
        if (!testResponse.ok) {
          throw new Error('Database connection test failed');
        }
        
        const testData = await testResponse.json();
        console.log('✅ Database connection test passed:', testData);
        
        // Check if we have the required data
        if (testData.dataCounts.staff === 0) {
          console.log('⚠️ No staff members in database, initializing...');
          // The database schema should have inserted sample staff members
          // If not, we'll need to add them manually
        }
        
        if (testData.dataCounts.periods === 0) {
          console.log('⚠️ No periods in database, initializing...');
          // The database schema should have inserted sample periods
          // If not, we'll need to add them manually
        }
        
        console.log('✅ Database initialization check completed');
        return true;
        
      } catch (error) {
        console.error('❌ Database initialization check failed:', error);
        return false;
      }
    }
    
    // Function to check and fix data inconsistencies
    async function checkAndFixDataInconsistencies() {
      console.log('🔍 Checking for data inconsistencies...');
      
      try {
        // Get current database state
        const dbStaff = await apiService.getStaffMembers();
        const dbShifts = await apiService.getShifts();
        
        console.log('📊 Database staff count:', dbStaff.length);
        console.log('📊 Database shifts count:', dbShifts.length);
        
        // Check if UI has all database staff
        const missingStaff = dbStaff.filter(staff => !availableNames.includes(staff.staff_name));
        if (missingStaff.length > 0) {
          console.log('⚠️ Found missing staff in UI:', missingStaff.map(s => s.staff_name));
        }
        
        // Check if UI has extra staff not in database
        const extraStaff = availableNames.filter(name => name !== '' && !dbStaff.some(s => s.staff_name === name));
        if (extraStaff.length > 0) {
          console.log('⚠️ Found extra staff in UI:', extraStaff);
        }
        
        // Log summary
        if (missingStaff.length === 0 && extraStaff.length === 0) {
          console.log('✅ No data inconsistencies found');
        } else {
          console.log('⚠️ Data inconsistencies detected - will be fixed during sync');
        }
        
      } catch (error) {
        console.error('❌ Error checking data inconsistencies:', error);
      }
    }
    

    
    // Function to force refresh staff list from database
    async function forceRefreshStaffList() {
      console.log('🔄 Force refreshing staff list from database...');
      
      try {
        // Get fresh data from database
        const staffMembers = await apiService.getStaffMembers();
        console.log('📊 Fresh staff data from database:', staffMembers);
        
        // Update global staff members variable with role information
        window.globalStaffMembers = staffMembers;
        
        // Clear and rebuild availableNames
        availableNames = [''];
        staffColors = { '': '' };
        
        // Add predefined colors
        const predefinedColors = {
          'Helen': '#EE0000', 'Fung': '#FFFF00', 'Anne': '#00B050', 'Annie': '#247A00',
          'Lisa': '#CC99FF', 'Janet': '#FF66FF', 'Clara': '#0070C0', 'John': '#00B0F0',
          'Vania': '#7030A0', 'Yasser': '#C4BC96', 'Matt': '#FFC000', 'FW': '#935CC3', 'HC': '#D52BD5'
        };
        
        staffMembers.forEach(staff => {
          // Only add active staff members to availableNames
          if (staff.is_active !== false) { // Default to true if not set
          availableNames.push(staff.staff_name);
          }
          staffColors[staff.staff_name] = predefinedColors[staff.staff_name] || getRandomColor();
        });
        
        console.log('📋 Updated availableNames:', availableNames);
        console.log('🎨 Updated staffColors:', Object.keys(staffColors).filter(key => key !== ''));
        
        // Force update the UI
        updateStaffList();
        
        console.log('✅ Staff list force refresh completed');
        
        // Show success message
        const successMsg = document.createElement('div');
        successMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #28a745;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        successMsg.textContent = `🔄 Staff list refreshed! (${staffMembers.length} staff members)`;
        document.body.appendChild(successMsg);
        
        setTimeout(() => {
          successMsg.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => successMsg.remove(), 300);
        }, 2000);
        
      } catch (error) {
        console.error('❌ Error force refreshing staff list:', error);
        
        // Show error message
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc3545;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        errorMsg.textContent = '❌ Failed to refresh staff list!';
        document.body.appendChild(errorMsg);
        
        setTimeout(() => {
          errorMsg.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => errorMsg.remove(), 300);
        }, 3000);
      }
    }
    

    


    // Function to clear existing shifts for testing
    window.clearExistingShifts = async function() {
      try {
        console.log('🗑️ Clearing existing shifts for testing...');
        
        // Get current period from frontend
        const currentPeriod = allPeriods[currentPeriodIndex];
        console.log('📅 Current frontend period:', currentPeriod);
        console.log('📅 Current period index:', currentPeriodIndex);
        console.log('📅 All periods array:', allPeriods);
        
        if (!currentPeriod) {
          console.error('❌ No current period found');
          alert('No current period found. Please try refreshing the page.');
          return false;
        }
        
        console.log('🔍 Current period structure:', {
          period_id: currentPeriod.period_id,
          title: currentPeriod.title,
          start: currentPeriod.start,
          end: currentPeriod.end,
          hasValidPeriodId: !!currentPeriod.period_id
        });
        
        // Show confirmation dialog first
        const confirmClear = confirm('Are you sure you want to clear all shifts for the current period? This action cannot be undone.');
        if (!confirmClear) {
          console.log('🚫 Clear operation cancelled by user');
          return false;
        }
        
        // Get database periods to find matching period
        const dbPeriods = await apiService.getPeriods();
        console.log('📅 Database periods:', dbPeriods.length);
        console.log('📅 All database periods:', dbPeriods);
        
        if (dbPeriods.length === 0) {
          alert('No periods found in database. Please check your database connection.');
          return false;
        }
        
        let currentDbPeriod = null;
        
        // First, try to find matching period by period_id if available
        if (currentPeriod.period_id) {
          currentDbPeriod = dbPeriods.find(p => p.period_id === currentPeriod.period_id);
          console.log('🔍 Matching by period_id:', currentDbPeriod ? 'Found' : 'Not found');
          if (currentDbPeriod) {
            console.log('✅ Found exact match by period_id:', currentDbPeriod.period_id);
          }
        }
        
        // If not found by period_id, try matching by dates with better date handling
        if (!currentDbPeriod) {
          console.log('🔍 Trying to match by dates...');
          
          try {
            // Convert frontend dates to YYYY-MM-DD format properly
            const frontendStartDate = currentPeriod.start.toISOString().split('T')[0];
            const frontendEndDate = currentPeriod.end.toISOString().split('T')[0];
            
            console.log('📅 Frontend dates:', { start: frontendStartDate, end: frontendEndDate });
            
            currentDbPeriod = dbPeriods.find(p => {
              // Convert database dates to same format for comparison
              const dbStartDate = new Date(p.start_date).toISOString().split('T')[0];
              const dbEndDate = new Date(p.end_date).toISOString().split('T')[0];
              
              console.log(`📅 Comparing: Frontend(${frontendStartDate}, ${frontendEndDate}) vs DB(${dbStartDate}, ${dbEndDate})`);
              
              return dbStartDate === frontendStartDate && dbEndDate === frontendEndDate;
            });
            
            if (currentDbPeriod) {
              console.log('✅ Found match by dates:', currentDbPeriod.period_id);
            }
          } catch (dateError) {
            console.error('❌ Error processing dates:', dateError);
          }
        }
        
        // If still not found, try using the current period index as a fallback
        if (!currentDbPeriod && currentPeriodIndex < dbPeriods.length) {
          console.log('🔍 Trying fallback by index...');
          currentDbPeriod = dbPeriods[currentPeriodIndex];
          console.log('⚠️ Using period by index as fallback:', currentDbPeriod.period_id);
        }
        
        if (!currentDbPeriod) {
          console.error('❌ No matching database period found');
          console.log('📅 Available database periods:');
          dbPeriods.forEach((p, index) => {
            const dbStart = new Date(p.start_date).toISOString().split('T')[0];
            const dbEnd = new Date(p.end_date).toISOString().split('T')[0];
            console.log(`  ${index + 1}. ID: ${p.period_id}, Dates: ${dbStart} to ${dbEnd}`);
          });
          
          // Offer to use the first available period as fallback
          if (dbPeriods.length > 0) {
            const useFallback = confirm('No matching period found. Use the first available period instead?');
            if (useFallback) {
              currentDbPeriod = dbPeriods[0];
              console.log('📅 Using fallback period:', currentDbPeriod);
            } else {
              alert('Clear operation cancelled - no matching period found.');
              return false;
            }
          } else {
            alert('No periods found in database. Please check your database connection.');
            return false;
          }
        }
        
        console.log('📅 Selected database period:', currentDbPeriod);
        
        // Clear all shifts for the current period using the dedicated clear endpoint
        console.log('🗑️ Calling clearShifts API with:', {
          periodId: currentDbPeriod.period_id,
          weekNumber: null,
          date: null,
          shiftType: null
        });
        
        const clearResult = await apiService.clearShifts(
          currentDbPeriod.period_id,
          null, // weekNumber - null means clear all weeks
          null, // date - null means clear all dates
          null  // shiftType - null means clear all shift types
        );
        
        console.log('✅ Clear result:', clearResult);
        const totalCleared = clearResult.clearedCount || 0;
        
        console.log(`🗑️ Total cleared shifts: ${totalCleared}`);
        
        // Clear the local rota data
        Object.keys(rotaData).forEach(weekKey => {
          rotaData[weekKey].forEach(row => {
            row.days.fill('');
          });
        });
        
        console.log('✅ Local rota data cleared');
        
        // Debug: Check shifts before refresh
        console.log('🔍 Checking shifts before refresh...');
        try {
          const shiftsBeforeRefresh = await apiService.getShiftsForPeriod(currentDbPeriod.period_id);
          console.log('📊 Shifts remaining before refresh:', shiftsBeforeRefresh.length);
        } catch (e) {
          console.warn('Could not check shifts before refresh:', e);
        }
        
        // Update display
        console.log('🔄 Updating display...');
        console.log('✅ Display update completed');
        
        // Force regenerate tables to ensure UI is updated
        console.log('🔄 Force regenerating tables after clear...');
        generateTables();
        console.log('✅ Tables regenerated after clear');
        
        // Debug: Check local rota data after refresh
        console.log('🔍 Local rota data after refresh:');
        Object.keys(rotaData).forEach((weekKey, weekIndex) => {
          rotaData[weekKey].forEach((row, rowIndex) => {
            row.days.forEach((day, dayIndex) => {
              if (day) {
                let displayText = '';
                if (typeof day === 'object' && day.assignments) {
                  displayText = day.displayText || '';
                } else {
                  displayText = day || '';
                }
                
                if (displayText && displayText.trim() !== '') {
                  console.log(`📊 Found data in ${weekKey}, row ${rowIndex}, day ${dayIndex}: "${displayText}"`);
                }
              }
            });
          });
        });
        
        // Show success message
        if (totalCleared > 0) {
          alert(`Successfully cleared ${totalCleared} shifts from the database and UI.`);
        } else {
          alert('Clear operation completed. No shifts were found to clear.');
        }
        
        return true;
        
      } catch (error) {
        console.error('❌ Error clearing shifts:', error);
        alert(`Failed to clear shifts: ${error.message}. Please check the console for details.`);
        return false;
      }
    };
    
    // Multi-select functionality
    let multiSelectMode = false;
    let selectedCells = new Set();
    // Context menu functionality removed
    
    // Function to enable multi-select mode
    function enableMultiSelectMode() {
      multiSelectMode = true;
      selectedCells.clear();
      
      // Add multi-select class to tables container
      const tablesContainer = document.getElementById('tables-container');
      tablesContainer.classList.add('multi-select-mode');
      
      // Show toolbar
      const toolbar = document.getElementById('multi-select-toolbar');
      toolbar.classList.add('show');
      updateSelectedCount();
      
      console.log('🔧 Multi-select mode enabled');
    }
    
    // Function to disable multi-select mode
    function disableMultiSelectMode() {
      multiSelectMode = false;
      selectedCells.clear();
      
      // Remove multi-select class from tables container
      const tablesContainer = document.getElementById('tables-container');
      tablesContainer.classList.remove('multi-select-mode');
      
      // Hide toolbar
      const toolbar = document.getElementById('multi-select-toolbar');
      toolbar.classList.remove('show');
      
      // Clear all selected cells
      document.querySelectorAll('.editable-cell.selected').forEach(cell => {
        cell.classList.remove('selected');
      });
      
      console.log('🔧 Multi-select mode disabled');
    }
    
    // Function to toggle cell selection
    function toggleCellSelection(cell, weekIndex, rowIndex, dayIndex) {
      if (!multiSelectMode) return;
      
      const cellKey = `${weekIndex}-${rowIndex}-${dayIndex}`;
      
      if (selectedCells.has(cellKey)) {
        selectedCells.delete(cellKey);
        cell.classList.remove('selected');
      } else {
        selectedCells.add(cellKey);
        cell.classList.add('selected');
      }
      
      updateSelectedCount();
    }
    
    // Function to update selected count
    function updateSelectedCount() {
      const countElement = document.getElementById('selected-count');
      countElement.textContent = selectedCells.size;
    }
    
    // Function to bulk delete selected cells
    async function bulkDeleteSelectedCells() {
      if (selectedCells.size === 0) {
        alert('No cells selected for deletion.');
        return;
      }
      
      const confirmed = confirm(`Are you sure you want to delete ${selectedCells.size} shift(s)? This action cannot be undone.`);
      if (!confirmed) return;
      
      try {
        console.log('🗑️ Starting bulk delete of', selectedCells.size, 'cells...');
        
        let successCount = 0;
        let errorCount = 0;
        
        for (const cellKey of selectedCells) {
          const [weekIndex, rowIndex, dayIndex] = cellKey.split('-').map(Number);
          
          try {
            // Find the actual cell element
            const tables = document.querySelectorAll('#tables-container table');
            if (tables[weekIndex]) {
              const rows = tables[weekIndex].querySelectorAll('tbody tr');
              if (rows[rowIndex]) {
                const cells = rows[rowIndex].querySelectorAll('td');
                if (cells[dayIndex + 1]) { // +1 because first cell is the role name
                  const cell = cells[dayIndex + 1];
                  await clearCell(cell, weekIndex, rowIndex, dayIndex);
                  successCount++;
                }
              }
            }
          } catch (error) {
            console.error(`❌ Error deleting cell ${cellKey}:`, error);
            errorCount++;
          }
        }
        
        // Disable multi-select mode after bulk delete
        disableMultiSelectMode();
        
        // Show results
        if (errorCount > 0) {
          alert(`Bulk delete completed with ${successCount} successful deletions and ${errorCount} errors. Check console for details.`);
        } else {
          alert(`Successfully deleted ${successCount} shift(s).`);
        }
        
      } catch (error) {
        console.error('❌ Error in bulk delete:', error);
        alert(`Bulk delete failed: ${error.message}`);
      }
    }
    
    // Initialize the page when it loads
    document.addEventListener('DOMContentLoaded', async function() {
      console.log('🚀 Page loaded, initializing...');
      
      try {
        // Initialize periods first
        await initializePeriods();
        console.log('✅ Periods initialized');
        
        // Load data from database
        await loadDataFromDatabase();
        console.log('✅ Data loaded from database');
        
        // Generate initial tables
        generateTables();
        console.log('✅ Initial tables generated');
        
        // Staff filter event listeners removed for simplicity
        
        // Initialize optimized shift summary module (with delay to ensure DOM is ready)
        console.log('✅ Initializing optimized shift summary module...');
        setTimeout(() => {
          if (ShiftSummaryModule && typeof ShiftSummaryModule.init === 'function') {
            ShiftSummaryModule.init();
          }
        }, 100);
        
        // Setup summary date change listeners (legacy support)
        setupSummaryDateListeners();
        console.log('✅ Summary date listeners setup');
        
        // Populate summary date inputs with pay date ranges (with delay to ensure periods are loaded)
        setTimeout(() => {
          populateSummaryDateInputs();
          console.log('✅ Summary date inputs populated with pay date ranges');
        }, 500);
        
        // Setup multi-select toolbar event listeners
        const bulkDeleteBtn = document.getElementById('bulk-delete-btn');
        const cancelMultiSelectBtn = document.getElementById('cancel-multi-select-btn');
        
        if (bulkDeleteBtn) {
          bulkDeleteBtn.addEventListener('click', bulkDeleteSelectedCells);
        }
        
        if (cancelMultiSelectBtn) {
          cancelMultiSelectBtn.addEventListener('click', disableMultiSelectMode);
        }
        
        console.log('✅ Multi-select toolbar listeners setup');
        
        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && multiSelectMode) {
            disableMultiSelectMode();
          }
        });
        
        console.log('✅ Keyboard shortcuts setup');
        
        // Initialize time-off tab functionality
        await initializeTimeOffTab();
        
        console.log('🎉 Page initialization completed successfully!');
        
        // Start real-time change request monitoring
        startChangeRequestMonitoring();
      } catch (error) {
        console.error('❌ Page initialization failed:', error);
        // Show error message to user
        const errorMsg = document.createElement('div');
        errorMsg.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc3545;
          color: white;
          padding: 12px 20px;
          border-radius: 8px;
          font-size: 14px;
          font-weight: 600;
          z-index: 10000;
          animation: slideInRight 0.3s ease-out;
        `;
        errorMsg.textContent = '❌ Failed to initialize page! Check console for details.';
        document.body.appendChild(errorMsg);
        
        setTimeout(() => {
          errorMsg.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => errorMsg.remove(), 300);
        }, 5000);
      }
    });
    // =====================================================
    // REAL-TIME CHANGE REQUEST MONITORING
    // =====================================================
    
    let changeRequestMonitorInterval = null;
    let lastStaffData = new Map();
    let lastChangeRequestCount = 0;
    
    // Start monitoring for applied change requests
    function startChangeRequestMonitoring() {
      console.log('🔄 Starting real-time change request monitoring...');
      
      // Initialize with current data
      initializeDataCache();
      
      // Check for changes every 10 seconds
      changeRequestMonitorInterval = setInterval(async () => {
        await checkForAppliedChanges();
      }, 10000); // 10 seconds for more responsive updates
      
      console.log('✅ Real-time change request monitoring started');
    }
    
    // Initialize data cache
    async function initializeDataCache() {
      try {
        // Cache staff data
        const staffResponse = await fetch(`${API_BASE_URL}/staff`);
        const staffData = await staffResponse.json();
        
        if (staffData.success) {
          lastStaffData.clear();
          staffData.data.forEach(staff => {
            lastStaffData.set(staff.unique_id, {
              role: staff.role,
              pay_rate: staff.pay_rate,
              contracted_hours: staff.contracted_hours,
              employment_start_date: staff.employment_start_date,
              employment_end_date: staff.employment_end_date,
              color_code: staff.color_code,
              is_active: staff.is_active
            });
          });
          console.log('📊 Staff data cache initialized with', lastStaffData.size, 'staff members');
        }
        
        // Cache change request count
        const changeResponse = await fetch(`${API_BASE_URL}/staff/change-requests`);
        const changeData = await changeResponse.json();
        if (changeData.success) {
          lastChangeRequestCount = changeData.data.length;
        }
        
      } catch (error) {
        console.error('❌ Error initializing data cache:', error);
      }
    }
    
    // Check for applied changes and update UI
    async function checkForAppliedChanges() {
      try {
        // Check for new applied changes
        const changeResponse = await fetch(`${API_BASE_URL}/staff/changes-history`);
        const changeData = await changeResponse.json();
        
        if (!changeData.success) return;
        
        // Get current staff data
        const staffResponse = await fetch(`${API_BASE_URL}/staff`);
        const staffData = await staffResponse.json();
        
        if (!staffData.success) return;
        
        let hasChanges = false;
        const changedStaff = [];
        
        // Compare current data with cached data
        for (const staff of staffData.data) {
          const cachedData = lastStaffData.get(staff.unique_id);
          if (!cachedData) continue;
          
          // Check for changes
          const changes = [];
          if (cachedData.role !== staff.role) changes.push('role');
          if (cachedData.pay_rate !== staff.pay_rate) changes.push('pay_rate');
          if (cachedData.contracted_hours !== staff.contracted_hours) changes.push('contracted_hours');
          if (cachedData.employment_start_date !== staff.employment_start_date) changes.push('employment_start_date');
          if (cachedData.employment_end_date !== staff.employment_end_date) changes.push('employment_end_date');
          if (cachedData.color_code !== staff.color_code) changes.push('color_code');
          if (cachedData.is_active !== staff.is_active) changes.push('is_active');
          
          if (changes.length > 0) {
            hasChanges = true;
            changedStaff.push({
              staff: staff,
              changes: changes
            });
            
            // Update cache
            lastStaffData.set(staff.unique_id, {
              role: staff.role,
              pay_rate: staff.pay_rate,
              contracted_hours: staff.contracted_hours,
              employment_start_date: staff.employment_start_date,
              employment_end_date: staff.employment_end_date,
              color_code: staff.color_code,
              is_active: staff.is_active
            });
          }
        }
        
        // Update UI if changes detected
        if (hasChanges) {
          console.log('🔄 Applied changes detected for', changedStaff.length, 'staff members');
          await updateUIForAppliedChanges(changedStaff);
        }
        
      } catch (error) {
        console.error('❌ Error checking for applied changes:', error);
      }
    }
    
    // Update UI components for applied changes
    async function updateUIForAppliedChanges(changedStaff) {
      try {
        console.log('🔄 Updating UI for applied changes...');
        
        // Update staff data in memory
        await loadStaff();
        
        // Update shift summary if it's visible (for pay rate changes)
        const hasPayRateChanges = changedStaff.some(item => item.changes.includes('pay_rate'));
        if (hasPayRateChanges && document.getElementById('shift-summary-tab').classList.contains('active')) {
          console.log('🔄 Updating shift summary due to pay rate changes...');
          if (typeof ShiftSummaryModule !== 'undefined' && ShiftSummaryModule.refresh) {
            ShiftSummaryModule.refresh();
          }
        }
        
        // Update holiday entitlements if contracted hours or employment dates changed
        const hasHolidayAffectingChanges = changedStaff.some(item => 
          item.changes.includes('contracted_hours') || 
          item.changes.includes('employment_start_date') || 
          item.changes.includes('employment_end_date')
        );
        
        if (hasHolidayAffectingChanges) {
          console.log('🔄 Updating holiday entitlements due to employment changes...');
          await loadHolidayEntitlements();
        }
        
        // Update change request dialogs if they're open
        const hasRoleChanges = changedStaff.some(item => item.changes.includes('role'));
        if (hasRoleChanges) {
          console.log('🔄 Refreshing change request dialogs due to role changes...');
          // Refresh any open change request dialogs
          const openDialogs = document.querySelectorAll('.change-request-dialog');
          openDialogs.forEach(dialog => {
            if (dialog.style.display !== 'none') {
              const staffId = dialog.dataset.staffId;
              if (staffId) {
                refreshChangeRequestDialog(staffId);
              }
            }
          });
        }
        
        // Show notification to user
        showChangeNotification(changedStaff);
        
        console.log('✅ UI updated for applied changes');
        
      } catch (error) {
        console.error('❌ Error updating UI for applied changes:', error);
      }
    }
    
    // Show notification to user about applied changes
    function showChangeNotification(changedStaff) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #28a745;
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        z-index: 10000;
        animation: slideInRight 0.3s ease-out;
        max-width: 350px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      `;
      
      const changeText = changedStaff.map(item => 
        `${item.staff.staff_name}: ${item.changes.join(', ')}`
      ).join('\n');
      
      notification.innerHTML = `
        <div>✅ Changes Applied Automatically</div>
        <div style="font-size: 12px; margin-top: 4px; opacity: 0.9; white-space: pre-line;">
          ${changeText}
        </div>
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.animation = 'slideOutRight 0.3s ease-in';
        setTimeout(() => notification.remove(), 300);
      }, 4000);
    }
    
    // Stop monitoring (can be called when page is unloaded)
    function stopChangeRequestMonitoring() {
      if (changeRequestMonitorInterval) {
        clearInterval(changeRequestMonitorInterval);
        changeRequestMonitorInterval = null;
        console.log('🛑 Change request monitoring stopped');
      }
    }
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      stopChangeRequestMonitoring();
    });
    
    // =====================================================
    // TIME-OFF MANAGEMENT FUNCTIONS
    // =====================================================

    // Initialize time-off tab functionality
    async function initializeTimeOffTab() {
      console.log('🏖️ Initializing time-off tab...');
      
      try {
        // Setup event listeners for time-off tab
        setupTimeOffEventListeners();
        
        // Load initial data
        await loadHolidayEntitlements();
        
        console.log('✅ Time-off tab initialized successfully');
      } catch (error) {
        console.error('❌ Error initializing time-off tab:', error);
      }
    }

    // Setup event listeners for time-off functionality
    function setupTimeOffEventListeners() {
      
      
      // Refresh entitlements
      const refreshEntitlementsBtn = document.getElementById('refresh-entitlements-btn');
      if (refreshEntitlementsBtn) {
        refreshEntitlementsBtn.addEventListener('click', refreshHolidayEntitlements);
      }
    }

    // Load time-off data



    // Load holiday entitlements
    async function loadHolidayEntitlements() {
      try {
        const response = await fetch(`${API_BASE_URL}/time-off/holiday-entitlements`);
        const data = await response.json();
        
        if (data.success) {
          displayHolidayEntitlements(data.data);
        } else {
          console.error('❌ Failed to load holiday entitlements:', data.message);
        }
      } catch (error) {
        console.error('❌ Error loading holiday entitlements:', error);
      }
    }

    // Display holiday entitlements in table
    function displayHolidayEntitlements(entitlements) {
      const tbody = document.getElementById('holiday-entitlements-tbody');
      if (!tbody) return;
      
      tbody.innerHTML = '';
      
      if (entitlements.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #6b7280; font-style: italic;">No holiday entitlements found</td></tr>';
        return;
      }
      
      entitlements.forEach(entitlement => {
        const usagePercentage = (entitlement.days_taken / entitlement.statutory_entitlement_days) * 100;
        const status = getEntitlementStatus(entitlement);
        
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>
            <div style="display: flex; align-items: center; gap: 8px;">
              <strong>${entitlement.staff_name}</strong>
              <button class="holiday-requests-mini-btn" onclick="showHolidayRequests('${entitlement.staff_name}')" title="View holiday requests">🏖️</button>
            </div>
          </td>
          <td>${entitlement.statutory_entitlement_days} days (${entitlement.statutory_entitlement_hours} hours)</td>
          <td>${entitlement.days_taken} days (${entitlement.hours_taken} hours)</td>
          <td>
            ${entitlement.days_remaining} days (${entitlement.hours_remaining} hours)
            <div class="entitlement-progress">
              <div class="entitlement-progress-bar ${status}" style="width: ${Math.min(usagePercentage, 100)}%"></div>
            </div>
          </td>
        `;
        tbody.appendChild(row);
      });
    }


    // Update time-off dashboard stats
    async function updateTimeOffDashboardStats() {
      try {
        const response = await fetch(`${API_BASE_URL}/time-off/summary`);
        const data = await response.json();
        
        if (data.success) {
          const summary = data.data;
          
          // Calculate totals
          const totalRequests = summary.reduce((sum, item) => sum + item.request_count, 0);
          const pendingRequests = summary.reduce((sum, item) => sum + item.pending_requests, 0);
          const approvedRequests = summary.reduce((sum, item) => sum + item.approved_requests, 0);
          
          // Update dashboard stats
          document.getElementById('timeoff-total-requests').textContent = totalRequests;
          document.getElementById('timeoff-pending-requests').textContent = pendingRequests;
          document.getElementById('timeoff-approved-requests').textContent = approvedRequests;
          
          // Get active entitlements count
          const entitlementsResponse = await fetch(`${API_BASE_URL}/time-off/holiday-entitlements`);
          const entitlementsData = await entitlementsResponse.json();
          const activeEntitlements = entitlementsData.success ? entitlementsData.data.length : 0;
          document.getElementById('timeoff-active-entitlements').textContent = activeEntitlements;
          
        }
      } catch (error) {
        console.error('❌ Error updating time-off dashboard stats:', error);
      }
    }



    // Populate staff select dropdown
    async function populateStaffSelect(selectId) {
      const select = document.getElementById(selectId);
      if (!select) return;
      
      try {
        const staffMembers = await apiService.getStaffMembers();
        
        // Clear existing options except the first one
        select.innerHTML = '<option value="">Select Staff Member</option>';
        
        staffMembers.forEach(staff => {
          const option = document.createElement('option');
          option.value = staff.unique_id;
          option.textContent = staff.staff_name;
          select.appendChild(option);
        });
      } catch (error) {
        console.error('❌ Error populating staff select:', error);
      }
    }


    // Submit sick pay record


    // Simple refresh function for holiday entitlements
    async function refreshHolidayEntitlements() {
      console.log('🔄 Refreshing holiday entitlements...');
      await loadHolidayEntitlements();
    }

    // Function to show holiday requests for a staff member
    window.showHolidayRequests = async function(staffName) {
      console.log('🏖️ showHolidayRequests called for:', staffName);
      
      try {
        // Calculate current financial year date range
        const currentDate = new Date();
        const currentYear = currentDate.getFullYear();
        
        // Determine the current financial year
        let currentFYStart, currentFYEnd;
        
        if (currentDate.getMonth() >= 3 && currentDate.getDate() >= 6) {
          // After April 6th - we're in the current financial year
          currentFYStart = new Date(currentYear, 3, 6); // April 6th current year
          currentFYEnd = new Date(currentYear + 1, 3, 5); // April 5th next year
        } else {
          // Before April 6th - we're in the previous financial year
          currentFYStart = new Date(currentYear - 1, 3, 6); // April 6th previous year
          currentFYEnd = new Date(currentYear, 3, 5); // April 5th current year
        }
        
        // Format dates for API call
        const formatDate = (date) => {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        };
        
        const startDate = formatDate(currentFYStart);
        const endDate = formatDate(currentFYEnd);
        
        console.log('📅 Using current financial year date range:', startDate, 'to', endDate);
        
        // Create holiday requests dialog
        const requestsDialog = document.createElement('div');
        requestsDialog.className = 'shift-history-dialog';
        requestsDialog.innerHTML = `
          <div class="shift-history-content-dialog">
            <div class="shift-history-header">
              <h3>Holiday Requests - ${staffName}</h3>
              <button class="close-shift-history-dialog" onclick="this.closest('.shift-history-dialog').remove()">×</button>
            </div>
            <div class="shift-history-body">
              <div class="date-range-section">
                <h4>Current Financial Year</h4>
                <div class="date-inputs">
                  <div class="date-input-group">
                    <label>From:</label>
                    <input type="date" id="holiday-requests-from-date" class="shift-history-date-input" value="${startDate}" readonly>
                  </div>
                  <div class="date-input-group">
                    <label>To:</label>
                    <input type="date" id="holiday-requests-to-date" class="shift-history-date-input" value="${endDate}" readonly>
                  </div>
                </div>
              </div>
              
              <div class="shift-summary-section">
                <h4>Holiday Shifts Summary (Current Financial Year)</h4>
                <div class="shift-summary-cards">
                  <div class="summary-card">
                    <div class="summary-label">Total Days</div>
                    <div class="summary-value" id="total-holiday-days-count">0</div>
                  </div>
                  <div class="summary-card">
                    <div class="summary-label">Total Hours</div>
                    <div class="summary-value" id="total-holiday-hours-count">0 hrs</div>
                  </div>
                </div>
              </div>
              
              <div class="shifts-table-section">
                <div class="shifts-section-header">
                <h4>Holiday Requests Details</h4>
                  <button id="export-holiday-requests-btn" class="export-btn" title="Export holiday requests to CSV">
                    <span class="btn-icon">📊</span>
                    Export
                  </button>
                </div>
                <div class="table-container">
                  <table class="shifts-table">
                    <thead>
                      <tr>
                        <th>Start Date</th>
                        <th>End Date</th>
                        <th>Days</th>
                        <th>Hours</th>
                        <th>Status</th>
                        <th>Notes</th>
                      </tr>
                    </thead>
                    <tbody id="holiday-requests-table-body">
                      <!-- Holiday requests will be populated here -->
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        `;

        document.body.appendChild(requestsDialog);
        
        // Add event listener for export button
        const exportBtn = document.getElementById('export-holiday-requests-btn');
        if (exportBtn) {
          exportBtn.addEventListener('click', () => {
            window.exportHolidayRequests();
          });
        }
        
        // Load holiday requests data
        await loadHolidayRequestsData(staffName, startDate, endDate);
        
      } catch (error) {
        console.error('❌ Error in showHolidayRequests:', error);
        alert('Error creating holiday requests dialog. Please refresh the page and try again.');
      }
    }

    // Function to load holiday requests data from shifts table
    window.loadHolidayRequestsData = async function(staffName, fromDate, toDate) {
      try {
        console.log(`🏖️ Loading holiday shifts for ${staffName} from ${fromDate} to ${toDate}`);
        
        // Fetch holiday shifts from shifts table using the same API as shift history
        const response = await fetch(`/api/shifts/employee/${encodeURIComponent(staffName)}?from=${fromDate}&to=${toDate}`);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        if (!data.success) {
          throw new Error(data.error || 'Failed to fetch holiday shifts');
        }
        
        // Filter shifts to only include HOLIDAY type shifts
        const allShifts = data.data || [];
        const holidayShifts = allShifts.filter(shift => {
          return shift.shift_type === 'HOLIDAY';
        });
        
        console.log(`🏖️ Found ${holidayShifts.length} holiday shifts for ${staffName} (filtered from ${allShifts.length} total shifts)`);
        
        // Convert shifts to holiday request format for display
        const holidayRequests = holidayShifts.map(shift => {
          const startTime = new Date(shift.shift_start_datetime);
          const endTime = new Date(shift.shift_end_datetime);
          const hours = (endTime - startTime) / (1000 * 60 * 60);
          const days = hours / 12; // Assuming 12 hours per day for holiday shifts
          
          return {
            id: shift.shift_id,
            staff_name: shift.staff_name,
            start_date: startTime.toISOString().split('T')[0],
            end_date: endTime.toISOString().split('T')[0],
            days: days,
            hours: hours,
            status: 'approved', // Holiday shifts in the shifts table are considered approved
            notes: shift.notes || '',
            shift_type: shift.shift_type
          };
        });
        
        // Update summary cards
        updateHolidayRequestsSummary(holidayRequests);
        
        // Update detailed requests table
        updateHolidayRequestsTable(holidayRequests);
        
      } catch (error) {
        console.error('❌ Error loading holiday requests data:', error);
        const tableBody = document.getElementById('holiday-requests-table-body');
        if (tableBody) {
          tableBody.innerHTML = '<tr><td colspan="6" class="error-message">Error loading holiday requests data</td></tr>';
        }
      }
    }

    // Function to update holiday requests summary cards
    window.updateHolidayRequestsSummary = function(requests) {
      const totalDays = requests.reduce((sum, req) => sum + (req.days || 0), 0);
      const totalHours = requests.reduce((sum, req) => sum + (req.hours || 0), 0);
      
      // Update summary cards
      const totalDaysElement = document.getElementById('total-holiday-days-count');
      const totalHoursElement = document.getElementById('total-holiday-hours-count');
      
      if (totalDaysElement) totalDaysElement.textContent = totalDays;
      if (totalHoursElement) totalHoursElement.textContent = `${totalHours} hrs`;
    }

    // Function to update holiday requests table
    window.updateHolidayRequestsTable = function(requests) {
      const tableBody = document.getElementById('holiday-requests-table-body');
      if (!tableBody) return;
      
      tableBody.innerHTML = '';
      
      if (requests.length === 0) {
        tableBody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #6b7280; font-style: italic;">No holiday requests found for this period</td></tr>';
        return;
      }
      
      requests.forEach(request => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${new Date(request.start_date).toLocaleDateString('en-GB')}</td>
          <td>${new Date(request.end_date).toLocaleDateString('en-GB')}</td>
          <td>${request.days || 0}</td>
          <td>${request.hours || 0}</td>
          <td>
            <span class="status-badge ${request.status}">${request.status}</span>
          </td>
          <td>${request.notes || '-'}</td>
        `;
        tableBody.appendChild(row);
      });
    }

    // Function to export holiday requests data to CSV
    window.exportHolidayRequests = function() {
      // Prevent multiple exports in quick succession
      if (window.isExportingHolidayRequests) {
        return;
      }
      window.isExportingHolidayRequests = true;

      try {
        // Get the holiday requests table
        const table = document.getElementById('holiday-requests-table-body');
        if (!table) {
          console.warn('⚠️ Holiday requests table not found');
          window.isExportingHolidayRequests = false;
          return;
        }

        // Get date range
        const fromDate = document.getElementById('holiday-requests-from-date')?.value || 'unknown';
        const toDate = document.getElementById('holiday-requests-to-date')?.value || 'unknown';
        
        // Get staff name from dialog header
        const headerElement = document.querySelector('.shift-history-header h3');
        const staffName = headerElement ? headerElement.textContent.replace('Holiday Requests - ', '') : 'Unknown Staff';

        // Check if table has data
        const rows = table.querySelectorAll('tr');
        if (rows.length === 0) {
          console.warn('⚠️ No holiday request data to export');
          window.isExportingHolidayRequests = false;
          return;
        }

        // Check if it's just the no data message
        const firstRow = rows[0];
        if (firstRow.querySelector('td[colspan]')) {
          console.warn('⚠️ No valid holiday request data to export');
          window.isExportingHolidayRequests = false;
          return;
        }

        let csvContent = 'data:text/csv;charset=utf-8,';
        
        // Add summary information at the top
        csvContent += 'HOLIDAY REQUESTS SUMMARY\n';
        csvContent += `Staff Name,${staffName}\n`;
        csvContent += `Date Range,${fromDate} to ${toDate}\n`;
        csvContent += '\n';
        
        // Get summary data from the cards
        const totalDays = document.getElementById('total-holiday-days-count')?.textContent || '0';
        const totalHours = document.getElementById('total-holiday-hours-count')?.textContent || '0 hrs';
        
        csvContent += 'SUMMARY METRICS\n';
        csvContent += 'Metric,Value\n';
        csvContent += `Total Days,${totalDays}\n`;
        csvContent += `Total Hours,${totalHours}\n`;
        csvContent += '\n';
        
        // Add detailed holiday requests header
        csvContent += 'DETAILED HOLIDAY REQUESTS\n';
        csvContent += 'Start Date,End Date,Days,Hours,Status,Notes\n';

        // Add data rows
        rows.forEach(row => {
          const cells = row.querySelectorAll('td');
          if (cells.length >= 6) {
            // Clean and format each cell
            const startDate = cells[0].textContent.trim();
            const endDate = cells[1].textContent.trim();
            const days = cells[2].textContent.trim();
            const hours = cells[3].textContent.trim();
            const status = cells[4].textContent.trim();
            const notes = cells[5].textContent.trim();
            
            const rowData = [
              `"${startDate}"`,
              `"${endDate}"`,
              `"${days}"`,
              `"${hours}"`,
              `"${status}"`,
              `"${notes}"`
            ];
            csvContent += rowData.join(',') + '\n';
          }
        });

        // Create and trigger download
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement('a');
        link.setAttribute('href', encodedUri);
        link.setAttribute('download', `holiday_requests_${staffName.replace(/\s+/g, '_')}_${fromDate}_to_${toDate}.csv`);
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        console.log('📊 Holiday requests data exported successfully');
        
        // Reset flag after a short delay
        setTimeout(() => {
          window.isExportingHolidayRequests = false;
        }, 1000);
        
      } catch (error) {
        console.error('❌ Error exporting holiday requests:', error);
        window.isExportingHolidayRequests = false;
      }
    };

    // Helper functions
    function formatDate(dateString) {
      return new Date(dateString).toLocaleDateString('en-GB');
    }

    function getEntitlementStatus(entitlement) {
      if (entitlement.is_zero_hours) {
        return 'zero-hours';
      }
      
      const usagePercentage = (entitlement.days_taken / entitlement.statutory_entitlement_days) * 100;
      
      if (usagePercentage >= 100) {
        return 'exhausted';
      } else if (usagePercentage >= 80) {
        return 'low';
      } else {
        return 'available';
      }
    }

    // Placeholder functions for future implementation

    function editHolidayEntitlement(staffId) {
      alert(`Edit holiday entitlement for staff ${staffId} - To be implemented`);
    }

    function viewHolidayEntitlement(staffId) {
      alert(`View holiday entitlement for staff ${staffId} - To be implemented`);
    }

    // Make functions globally accessible for inline onclick handlers
    window.editHolidayEntitlement = editHolidayEntitlement;
    window.viewHolidayEntitlement = viewHolidayEntitlement;

    // Function to print rota tables
    function printRotaTables() {
      try {
        console.log('🖨️ Printing rota tables...');
        
        // Get the current period title
        const periodTitle = document.getElementById('period-title').textContent;
        
        // Get the tables container
        const tablesContainer = document.getElementById('tables-container');
        if (!tablesContainer) {
          console.error('❌ Tables container not found');
          return;
        }
        
        // Create a print-friendly version
        const printContent = document.createElement('div');
        printContent.className = 'print-content';
        
        // Get all tables
        const tables = tablesContainer.querySelectorAll('table');
        
        // Helper function to create page header
        function createPageHeader() {
          const headerDiv = document.createElement('div');
          headerDiv.className = 'page-header';
          
          // Add main title "T&C"
          const mainTitle = document.createElement('h1');
          mainTitle.className = 'print-main-title';
          mainTitle.innerHTML = 'T&amp;C';
          headerDiv.appendChild(mainTitle);
          
          // Add subtitle with period
          const subtitle = document.createElement('h2');
          subtitle.className = 'print-subtitle';
          subtitle.textContent = periodTitle;
          headerDiv.appendChild(subtitle);
          
          return headerDiv;
        }
        
        // Helper function to create page footer with date and time
        function createPageFooter() {
          const footerDiv = document.createElement('div');
          footerDiv.className = 'print-footer';
          
          // Get current date and time
          const now = new Date();
          const dateTime = now.toLocaleString('en-GB', {
            day: '2-digit',
            month: '2-digit', 
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: false
          });
          
          const footerText = document.createElement('div');
          footerText.className = 'print-footer-text';
          footerText.textContent = `Printed: ${dateTime}`;
          footerDiv.appendChild(footerText);
          
          return footerDiv;
        }
        
        // Create first page with weeks 1 and 2
        const firstPage = document.createElement('div');
        firstPage.className = 'print-page';
        
        // Add page header to first page
        firstPage.appendChild(createPageHeader());
        
        // Add week 1 with title
        if (tables[0]) {
          const week1Title = document.createElement('h3');
          week1Title.className = 'week-title';
          week1Title.textContent = 'Week 1';
          firstPage.appendChild(week1Title);
          
          const week1Clone = tables[0].cloneNode(true);
          removeHolidayRows(week1Clone);
          removeFlagText(week1Clone);
          removeFlagIndicators(week1Clone);
          preserveStyles(week1Clone);
          firstPage.appendChild(week1Clone);
        }
        
        // Add week 2 with title
        if (tables[1]) {
          const week2Title = document.createElement('h3');
          week2Title.className = 'week-title';
          week2Title.textContent = 'Week 2';
          firstPage.appendChild(week2Title);
          
          const week2Clone = tables[1].cloneNode(true);
          removeHolidayRows(week2Clone);
          removeFlagText(week2Clone);
          removeFlagIndicators(week2Clone);
          preserveStyles(week2Clone);
          firstPage.appendChild(week2Clone);
        }
        
        // Add page footer to first page
        firstPage.appendChild(createPageFooter());
        
        printContent.appendChild(firstPage);
        
        // Create second page with weeks 3 and 4
        const secondPage = document.createElement('div');
        secondPage.className = 'print-page';
        
        // Add page header to second page
        secondPage.appendChild(createPageHeader());
        
        // Add week 3 with title
        if (tables[2]) {
          const week3Title = document.createElement('h3');
          week3Title.className = 'week-title';
          week3Title.textContent = 'Week 3';
          secondPage.appendChild(week3Title);
          
          const week3Clone = tables[2].cloneNode(true);
          removeHolidayRows(week3Clone);
          removeFlagText(week3Clone);
          removeFlagIndicators(week3Clone);
          preserveStyles(week3Clone);
          secondPage.appendChild(week3Clone);
        }
        
        // Add week 4 with title
        if (tables[3]) {
          const week4Title = document.createElement('h3');
          week4Title.className = 'week-title';
          week4Title.textContent = 'Week 4';
          secondPage.appendChild(week4Title);
          
          const week4Clone = tables[3].cloneNode(true);
          removeHolidayRows(week4Clone);
          removeFlagText(week4Clone);
          removeFlagIndicators(week4Clone);
          preserveStyles(week4Clone);
          secondPage.appendChild(week4Clone);
        }
        
        // Add page footer to second page
        secondPage.appendChild(createPageFooter());
        
        printContent.appendChild(secondPage);
        
        // Temporarily add to body
        document.body.appendChild(printContent);
        
        // Trigger print
        window.print();
        
        // Clean up
        document.body.removeChild(printContent);
        
        console.log('✅ Print dialog opened successfully');
        
      } catch (error) {
        console.error('❌ Error printing rota tables:', error);
        alert('Error printing rota tables. Please try again.');
      }
    }
    
    // Helper function to remove holiday rows completely
    function removeHolidayRows(table) {
      const rows = table.querySelectorAll('tr');
      rows.forEach(row => {
        const cells = row.querySelectorAll('td');
        let isHolidayRow = false;
        
        cells.forEach(cell => {
          const cellText = cell.textContent.toLowerCase();
          if (cellText.includes('holiday') || cellText.includes('🏖️')) {
            isHolidayRow = true;
          }
        });
        
        if (isHolidayRow) {
          row.remove();
        }
      });
    }
    
    // Helper function to remove flag text from headers
    function removeFlagText(table) {
      const headers = table.querySelectorAll('th');
      headers.forEach(header => {
        const smallElements = header.querySelectorAll('small');
        smallElements.forEach(small => {
          if (small.textContent.includes('Click to set flags')) {
            small.remove();
          }
        });
      });
    }
    
    // Helper function to remove flag indicators from cells
    function removeFlagIndicators(table) {
      const cells = table.querySelectorAll('td');
      cells.forEach((cell, index) => {
        // Skip the first column (shift type column) to preserve full shift type names
        const isFirstColumn = cell.closest('tr') && cell === cell.closest('tr').querySelector('td:first-child');
        if (isFirstColumn) {
          return; // Don't process the shift type column
        }
        
        let cellText = cell.textContent;
        
        // Remove flag emojis and indicators
        const flagEmojis = ['🚨', '🎓', '⚡', '💰', '📅', '🏖️', '🔴', '🟡', '🟢', '📝', '💬', '📋', '🔔', '📞', '⏰', '🎯', '⭐', '🔥', '💡', '🎪', '🎨', '🎭', '🎪', '🎯', '🎲', '🎳', '🎸', '🎺', '🎻', '🎼', '🎵', '🎶', '🎤', '🎧', '🎬', '🎭', '🎨', '🎪', '🎫', '🎬', '🎭', '🎨', '🎪', '🎫', '🎬', '🎭', '🎨', '🎪', '🎫', '🎬', '🎭', '🎨', '🎪', '🎫', '👥', '👤', '👨', '👩', '👨‍💼', '👩‍💼', '👨‍💻', '👩‍💻', '👨‍🔧', '👩‍🔧', '👨‍🏫', '👩‍🏫', '👨‍⚕️', '👩‍⚕️', '👨‍⚖️', '👩‍⚖️', '👨‍✈️', '👩‍✈️', '👨‍🚀', '👩‍🚀', '👨‍🚒', '👩‍🚒', '👨‍🎨', '👩‍🎨', '👨‍🎤', '👩‍🎤', '👨‍🎭', '👩‍🎭', '👨‍🎪', '👩‍🎪', '👨‍🎨', '👩‍🎨', '👨‍🎤', '👩‍🎤', '👨‍🎭', '👩‍🎭', '👨‍🎪', '👩‍🎪'];
        flagEmojis.forEach(emoji => {
          cellText = cellText.replace(new RegExp(emoji, 'g'), '');
        });
        
        // Define comprehensive flag text patterns to remove (order matters - specific first)
        const flagTextPatterns = [
          // Specific concatenated/compound words
          /SoloTraining/gi,
          /SoloCallout/gi,
          /SoloOvertime/gi,
          /ShortOverti\s*me/gi,
          /ShortNotice/gi,
          /PaymentPeriodEnd/gi,
          /FinancialYearEnd/gi,
          
          // Numerical flags like <12h, <8h, etc.
          /\s*<\d+h\b/gi,
          /\s*<\d+\s*hours?\b/gi,
          /\s*<\d+\s*hrs?\b/gi,
          
          // Compound phrases with flexible spacing
          /\bsolo\s*training\b/gi,
          /\bsolo\s*callout\b/gi,
          /\bsolo\s*overtime\b/gi,
          /\bshort\s*notice\s*shift\b/gi,
          /\bovertime\s*shift\b/gi,
          /\btraining\s*shift\b/gi,
          /\bholiday\s*shift\b/gi,
          /\bsolo\s*shift\b/gi,
          /\bpayment\s*period\s*end\b/gi,
          /\bfinancial\s*year\s*end\b/gi,
          /\bshort\s*overtime\b/gi,
          /\bshort\s*notice\b/gi,
          
          // Abbreviated forms
          /\bpp\s*end\b/gi,
          /\bfy\s*end\b/gi,
          
          // Individual flag names
          /\bsolo\b/gi,
          /\btraining\b/gi,
          /\bovertime\b/gi,
          /\bholiday\b/gi,
          /\bnotes\b/gi,
          /\bcall\s*out\b/gi,
          /\bcallout\b/gi,
          /\bshort\b/gi,
          /\bnotice\b/gi,
          /\bpayment\b/gi,
          /\bperiod\b/gi,
          /\bfinancial\b/gi,
          /\byear\b/gi,
          /\bend\b/gi,
          
          // Remove brackets and parentheses content
          /\s*\[.*?\]\s*/g,
          /\s*\(.*?\)\s*/g,
          
          // Remove separators
          /\s*-\s*/g,
          /\s*,\s*/g,
        ];
        
        // Apply all patterns
        flagTextPatterns.forEach(pattern => {
          cellText = cellText.replace(pattern, '');
        });
        
        // Final cleanup - remove any remaining flag-related content
        cellText = cellText
          .replace(/\s+/g, ' ') // Replace multiple spaces with single space
          .replace(/^[^a-zA-Z0-9\s]*/, '') // Remove leading non-alphanumeric characters
          .replace(/[^a-zA-Z0-9\s]*$/, '') // Remove trailing non-alphanumeric characters
          .trim(); // Remove leading/trailing spaces
        
        // Handle concatenated staff names (like "JohnAnne" -> "John, Anne")
        if (cellText.length > 0) {
          // List of known staff names for proper separation
          const staffNames = ['Anne', 'Annie', 'Clara', 'Fung', 'Helen', 'Janet', 'John', 'Lisa', 'Matt', 'Vania', 'Yasser'];
          
          // Try to separate concatenated names
          let separatedNames = [];
          let remainingText = cellText;
          
          // Find and separate staff names
          for (const name of staffNames) {
            if (remainingText.includes(name)) {
              separatedNames.push(name);
              remainingText = remainingText.replace(name, '');
            }
          }
          
          // If we found separated names, join them with commas
          if (separatedNames.length > 0) {
            cellText = separatedNames.join(', ');
          } else {
            // If no known names found, keep only the first word (staff name)
            const words = cellText.split(/\s+/);
            if (words.length > 1) {
              cellText = words[0];
            }
          }
        }
        
        // Final emoji removal - remove any remaining emojis after all processing
        cellText = cellText.replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '');
        
        // Remove any remaining non-printable characters and extra spaces
        cellText = cellText.replace(/[^\w\s,]/g, '').replace(/\s+/g, ' ').trim();
        
        cell.textContent = cellText;
      });
    }
    // Helper function to preserve styles
    function preserveStyles(element) {
      const allElements = element.querySelectorAll('*');
      allElements.forEach(el => {
        // Preserve existing classes
        if (el.className) {
          el.setAttribute('class', el.className);
        }
        // Preserve existing styles
        if (el.style && el.style.cssText) {
          el.setAttribute('style', el.style.cssText);
        }
      });
    }

  </script>
</body>
</html>